<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Definitions SYSTEM "widlprocxml.dtd">
<Definitions>
<Module name="Vehicle" id="::Vehicle">
<webidl>  module Vehicle {
[NoInterfaceObject] interface VehicleManagerObject {
    readonly    attribute <ref>Vehicle</ref> vehicle;
};

<ref>Navigator</ref> implements <ref>VehicleManagerObject</ref>;

[NoInterfaceObject]
interface Vehicle {
    readonly    attribute <ref>VehicleConfigurationInterface</ref> identification;
    readonly    attribute <ref>VehicleConfigurationInterface</ref> sizeConfiguration;
    readonly    attribute <ref>VehicleConfigurationInterface</ref> fuelConfiguration;
    readonly    attribute <ref>VehicleConfigurationInterface</ref> transmissionConfiguration;
    readonly    attribute <ref>VehicleConfigurationInterface</ref> wheelConfiguration;
    readonly    attribute <ref>VehicleSignalInterface</ref>        steeringWheelConfiguration;

    readonly    attribute <ref>VehicleSignalInterface</ref> vehicleSpeed;
    readonly    attribute <ref>VehicleSignalInterface</ref> wheelSpeed;
    readonly    attribute <ref>VehicleSignalInterface</ref> engineSpeed;
    readonly    attribute <ref>VehicleSignalInterface</ref> powerTrainTorque;
    readonly    attribute <ref>VehicleSignalInterface</ref> acceleratorPedalPosition;
    readonly    attribute <ref>VehicleSignalInterface</ref> throttlePosition;
    readonly    attribute <ref>VehicleSignalInterface</ref> tripMeters;
    readonly    attribute <ref>VehicleSignalInterface</ref> transmission;
    readonly    attribute <ref>VehicleSignalInterface</ref> cruiseControlStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> lightStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> interiorLightStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> horn;
    readonly    attribute <ref>VehicleSignalInterface</ref> chime;
    readonly    attribute <ref>VehicleSignalInterface</ref> fuel;
    readonly    attribute <ref>VehicleSignalInterface</ref> engineOil;
    readonly    attribute <ref>VehicleSignalInterface</ref> acceleration;
    readonly    attribute <ref>VehicleSignalInterface</ref> engineCoolant;
    readonly    attribute <ref>VehicleSignalInterface</ref> steeringWheel;
    readonly    attribute <ref>VehicleSignalInterface</ref> ignitionTime;
    readonly    attribute <ref>VehicleSignalInterface</ref> yawRate;
    readonly    attribute <ref>VehicleSignalInterface</ref> brakeOperation;
    readonly    attribute <ref>VehicleSignalInterface</ref> wheelTick;
    readonly    attribute <ref>VehicleSignalInterface</ref> buttonEvent;
    readonly    attribute <ref>VehicleSignalInterface</ref> drivingMode;
    readonly    attribute <ref>VehicleSignalInterface</ref> nightMode;

    readonly    attribute <ref>VehicleSignalInterface</ref> odometer;
    readonly    attribute <ref>VehicleSignalInterface</ref> transmissionOil;
    readonly    attribute <ref>VehicleSignalInterface</ref> transmissionClutch;
    readonly    attribute <ref>VehicleSignalInterface</ref> brakeMaintenance;
    readonly    attribute <ref>VehicleSignalInterface</ref> washerFluid;
    readonly    attribute <ref>VehicleSignalInterface</ref> malfunctionIndicator;
    readonly    attribute <ref>VehicleSignalInterface</ref> batteryStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> tire;
    readonly    attribute <ref>VehicleSignalInterface</ref> diagnostic;

    readonly    attribute <ref>VehicleSignalInterface</ref>? languageConfiguration;
    readonly    attribute <ref>VehicleSignalInterface</ref>  unitsOfMeasure;
    readonly    attribute <ref>VehicleSignalInterface</ref>  mirror;
    readonly    attribute <ref>VehicleSignalInterface</ref>  driveMode;
    readonly    attribute <ref>VehicleSignalInterface</ref>  seatAdjustment;
    readonly    attribute <ref>VehicleSignalInterface</ref>  dashboardIllumination;
    readonly    attribute <ref>VehicleSignalInterface</ref>  vehicleSound;

    readonly    attribute <ref>VehicleSignalInterface</ref> antilockBrakingSystem;
    readonly    attribute <ref>VehicleSignalInterface</ref> tractionControlSystem;
    readonly    attribute <ref>VehicleSignalInterface</ref> electronicStabilityControl;
    readonly    attribute <ref>VehicleSignalInterface</ref> topSpeedLimit;
    readonly    attribute <ref>VehicleSignalInterface</ref> airbagStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> door;
    readonly    attribute <ref>VehicleSignalInterface</ref> childSafetyLock;
    readonly    attribute <ref>VehicleSignalInterface</ref> seat;

    readonly    attribute <ref>VehicleSignalInterface</ref> temperature;
    readonly    attribute <ref>VehicleSignalInterface</ref> rainSensor;
    readonly    attribute <ref>VehicleSignalInterface</ref> wiperStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> wiperSetting;
    readonly    attribute <ref>VehicleSignalInterface</ref> defrost;
    readonly    attribute <ref>VehicleSignalInterface</ref> sunroof;
    readonly    attribute <ref>VehicleSignalInterface</ref> convertibleRoof;
    readonly    attribute <ref>VehicleSignalInterface</ref> sideWindow;
    readonly    attribute <ref>VehicleSignalInterface</ref> climateControl;
    readonly    attribute <ref>VehicleSignalInterface</ref> atmosphericPressure;

    readonly    attribute <ref>VehicleSignalInterface</ref> laneDepartureStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> alarm;
    readonly    attribute <ref>VehicleSignalInterface</ref> parkingBrake;
    readonly    attribute <ref>VehicleSignalInterface</ref> parkingLights;
};

enum ZonePosition {
    &quot;front&quot;,
    &quot;middle&quot;,
    &quot;right&quot;,
    &quot;left&quot;,
    &quot;rear&quot;,
    &quot;center&quot;
};

interface Zone {
                attribute DOMString[] value;
    readonly    attribute <ref>Zone</ref>        driver;
    boolean equals (<ref>Zone</ref> zone);
    boolean contains (<ref>Zone</ref> zone);
};

[Callback=FunctionOnly, NoInterfaceObject]
interface VehicleInterfaceCallback {
    void onsuccess(object value);
};

[Callback=FunctionOnly, NoInterfaceObject]
interface AvailableCallback {
    void onsuccess(<ref>Availability</ref> available);
};

enum VehicleError {
    &quot;permission_denied&quot;,
    &quot;invalid_operation&quot;,
    &quot;timeout&quot;,
    &quot;invalid_zone&quot;,
    &quot;unknown&quot;
};

[NoInterfaceObject]
interface VehicleInterfaceError {
    readonly    attribute <ref>VehicleError</ref> error;
    readonly    attribute DOMString    message;
};

interface VehicleInterface {
    <ref>Availability</ref>   availableForRetrieval (DOMString attributeName);
    <ref>Promise</ref>        get (optional <ref>Zone</ref> zone);
    <ref>Promise</ref>        getHistory (Date begin, Date end, optional <ref>Zone</ref> zone);
    short          availabilityChangedListener (<ref>AvailableCallback</ref> callback);
    void           removeAvailabilityChangedListener (short handle);
    readonly       attribute <ref>Zone</ref>[] zones;
    readonly       attribute boolean supported;
    readonly       attribute boolean isLogged;
    readonly       attribute Date ?  from;
    readonly       attribute Date ?  to;
};

[NoInterfaceObject]
interface VehicleConfigurationInterface : <ref>VehicleInterface</ref> {};

[NoInterfaceObject]
interface VehicleSignalInterface : <ref>VehicleInterface</ref> {
    <ref>Availability</ref>   availableForSubscription (DOMString attributeName);
    <ref>Availability</ref>   availableForSetting (DOMString attributeName);
    <ref>Promise</ref>        set (object value, optional <ref>Zone</ref> zone);
    unsigned short subscribe (<ref>VehicleInterfaceCallback</ref> callback, optional <ref>Zone</ref> zone);
    void           unsubscribe (unsigned short handle);
};

enum Availability {
    &quot;available&quot;,
    &quot;not_supported&quot;,
    &quot;not_supported_yet&quot;,
    &quot;not_supported_security_policy&quot;,
    &quot;not_supported_business_policy&quot;,
    &quot;not_supported_other&quot;
};

[NoInterfaceObject]
interface VehicleCommonDataType {
    readonly    attribute <ref>DOMTimeStamp</ref>? timeStamp;
};

enum VehicleTypeEnum {
    &quot;passengerCarMini&quot;,
    &quot;passengerCarLight&quot;,
    &quot;passengerCarCompact&quot;,
    &quot;passengerCarMedium&quot;,
    &quot;passengerCarHeavy&quot;,
    &quot;sportUtilityVehicle&quot;,
    &quot;pickupTruck&quot;,
    &quot;van&quot;
};

[NoInterfaceObject]
interface Identification : <ref>VehicleCommonDataType</ref> {
    readonly    attribute DOMString?       VIN;
    readonly    attribute DOMString?       WMI;
    readonly    attribute <ref>VehicleTypeEnum</ref>? vehicleType;
    readonly    attribute DOMString?       brand;
    readonly    attribute DOMString?       model;
    readonly    attribute unsigned short?  year;
};

[NoInterfaceObject]
interface SizeConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short?   width;
    readonly    attribute unsigned short?   height;
    readonly    attribute unsigned short?   length;
    readonly    attribute unsigned short[]? doorsCount;
    readonly    attribute unsigned short?   totalDoors;
};

enum FuelTypeEnum {
    &quot;gasoline&quot;,
    &quot;methanol&quot;,
    &quot;ethanol&quot;,
    &quot;diesel&quot;,
    &quot;lpg&quot;,
    &quot;cng&quot;,
    &quot;electric&quot;
};

[NoInterfaceObject]
interface FuelConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>FuelTypeEnum</ref>[]? fuelType;
    readonly    attribute <ref>Zone</ref>?           refuelPosition;
};

enum TransmissionGearTypeEnum {
    &quot;auto&quot;,
    &quot;manual&quot;
};

[NoInterfaceObject]
interface TransmissionConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>TransmissionGearTypeEnum</ref>? transmissionGearType;
};

[NoInterfaceObject]
interface WheelConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short? wheelRadius;
    readonly    attribute <ref>Zone</ref>?           zone;
};

[NoInterfaceObject]
interface SteeringWheelConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean?        steeringWheelLeft;
                attribute unsigned short? steeringWheelTelescopingPosition;
                attribute unsigned short? steeringWheelPositionTilt;
};

[NoInterfaceObject]
interface VehicleSpeed : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short speed;
};

[NoInterfaceObject]
interface WheelSpeed : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short speed;
    readonly    attribute <ref>Zone</ref>?          zone;
};

[NoInterfaceObject]
interface EngineSpeed : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned long speed;
};

enum VehiclePowerMode {
    &quot;off&quot;,
    &quot;accessory1&quot;,
    &quot;accessory2&quot;,
    &quot;running&quot;
};

[NoInterfaceObject]
interface VehiclePowerModeType : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>VehiclePowerMode</ref> value;
};

[NoInterfaceObject]
interface PowerTrainTorque : <ref>VehicleCommonDataType</ref> {
    readonly    attribute short value;
};

[NoInterfaceObject]
interface AcceleratorPedalPosition : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short value;
};

[NoInterfaceObject]
interface ThrottlePosition : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short value;
};

[NoInterfaceObject]
interface Trip {
    readonly    attribute unsigned long   distance;
    readonly    attribute unsigned short? averageSpeed;
    readonly    attribute unsigned short? fuelConsumption;
};

[NoInterfaceObject]
interface TripMeters : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>Trip</ref>[] meters;
};

enum TransmissionMode {
    &quot;park&quot;,
    &quot;reverse&quot;,
    &quot;neutral&quot;,
    &quot;low&quot;,
    &quot;drive&quot;,
    &quot;overdrive&quot;
};

[NoInterfaceObject]
interface Transmission : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet?            gear;
    readonly    attribute <ref>TransmissionMode</ref>? mode;
};

[NoInterfaceObject]
interface CruiseControlStatus : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean        status;
    readonly    attribute unsigned short speed;
};

[NoInterfaceObject]
interface LightStatus : <ref>VehicleCommonDataType</ref> {
                attribute boolean  head;
                attribute boolean  rightTurn;
                attribute boolean  leftTurn;
                attribute boolean  brake;
                attribute boolean? fog;
                attribute boolean  hazard;
                attribute boolean  parking;
                attribute boolean  highBeam;
                attribute boolean? automaticHeadlights;
                attribute boolean? dynamicHighBeam;
    readonly    attribute <ref>Zone</ref>?    zone;
};

[NoInterfaceObject]
interface InteriorLightStatus : <ref>VehicleCommonDataType</ref> {
                attribute boolean status;
    readonly    attribute <ref>Zone</ref>?   zone;
};

[NoInterfaceObject]
interface Horn : <ref>VehicleCommonDataType</ref> {
                attribute boolean status;
};

[NoInterfaceObject]
interface Chime : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean status;
};

[NoInterfaceObject]
interface Fuel : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short? level;
    readonly    attribute unsigned long?  range;
    readonly    attribute unsigned long?  instantConsumption;
                attribute unsigned long?  averageConsumption;
    readonly    attribute unsigned long?  fuelConsumedSinceRestart;
    readonly    attribute unsigned long?  timeSinceRestart;
};

[NoInterfaceObject]
interface EngineOil : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short level;
    readonly    attribute unsigned short lifeRemaining;
    readonly    attribute long           temperature;
    readonly    attribute unsigned short pressure;
    readonly    attribute boolean        change;
};

[NoInterfaceObject]
interface Acceleration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute long x;
    readonly    attribute long y;
    readonly    attribute long z;
};

[NoInterfaceObject]
interface EngineCoolant : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet level;
    readonly    attribute short temperature;
};

[NoInterfaceObject]
interface SteeringWheel : <ref>VehicleCommonDataType</ref> {
    readonly    attribute short angle;
};

[NoInterfaceObject]
interface WheelTick : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned long value;
    readonly    attribute <ref>Zone</ref>?         zone;
};

[NoInterfaceObject]
interface IgnitionTime : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>DOMTimeStamp</ref> ignitionOnTime;
    readonly    attribute <ref>DOMTimeStamp</ref> ignitionOffTime;
};

[NoInterfaceObject]
interface YawRate : <ref>VehicleCommonDataType</ref> {
    readonly    attribute short value;
};

[NoInterfaceObject]
interface BrakeOperation : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean brakePedalDepressed;
};

enum Button {
    &quot;home&quot;,
    &quot;back&quot;,
    &quot;search&quot;,
    &quot;call&quot;,
    &quot;end_call&quot;,
    &quot;media_play&quot;,
    &quot;media_next&quot;,
    &quot;media_previous&quot;,
    &quot;media_pause&quot;,
    &quot;voice_recognize&quot;,
    &quot;enter&quot;,
    &quot;left&quot;,
    &quot;right&quot;,
    &quot;up&quot;,
    &quot;down&quot;
};

enum ButtonEventType {
    &quot;press&quot;,
    &quot;long_press&quot;,
    &quot;release&quot;
};

[NoInterfaceObject]
interface VehicleButton {
    readonly    attribute <ref>Button</ref>          button;
    readonly    attribute <ref>ButtonEventType</ref> state;
};

[NoInterfaceObject]
interface ButtonEvent : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>VehicleButton</ref>[] button;
};

[NoInterfaceObject]
interface DrivingMode : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean mode;
};

[NoInterfaceObject]
interface DrivingMode : <ref>VehicleCommonDataType</ref> {
        readonly attribute boolean mode;
};

[NoInterfaceObject]
interface NightMode : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean mode;
};

[NoInterfaceObject]
interface Odometer : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned long? distanceSinceStart;
    readonly    attribute unsigned long  distanceTotal;
};

[NoInterfaceObject]
interface TransmissionOil : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet?  wear;
    readonly    attribute short?  temperature;
};

[NoInterfaceObject]
interface TransmissionClutch : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet wear;
};

[NoInterfaceObject]
interface BrakeMaintenance : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet?   fluidLevel;
    readonly    attribute boolean? fluidLevelLow;
    readonly    attribute octet?   padWear;
    readonly    attribute boolean? brakesWorn;
    readonly    attribute <ref>Zone</ref>?    zone;
};

[NoInterfaceObject]
interface WasherFluid : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short? level;
    readonly    attribute boolean?        levelLow;
};

[NoInterfaceObject]
interface MalfunctionIndicator : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean on;
};

[NoInterfaceObject]
interface BatteryStatus : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short? chargeLevel;
    readonly    attribute unsigned short? voltage;
    readonly    attribute unsigned short? current;
    readonly    attribute <ref>Zone</ref>?           zone;
};

[NoInterfaceObject]
interface Tire : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean?        pressureLow;
    readonly    attribute unsigned short? pressure;
    readonly    attribute short?          temperature;
    readonly    attribute <ref>Zone</ref>?           zone;
};

[NoInterfaceObject]
interface Diagnostic : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned long accumulatedEngineRuntime;
    readonly    attribute unsigned long distanceWithMILOn;
    readonly    attribute unsigned long distanceSinceCodeCleared;
    readonly    attribute unsigned long timeRunMILOn;
    readonly    attribute unsigned long timeTroubleCodeClear;
};

[NoInterfaceObject]
interface LanguageConfiguration : <ref>VehicleCommonDataType</ref> {
                attribute DOMString? language;
};

[NoInterfaceObject]
interface UnitsOfMeasure : <ref>VehicleCommonDataType</ref> {
                attribute boolean?   isMKSSystem;
                attribute DOMString? unitsFuelVolume;
                attribute DOMString? unitsDistance;
                attribute DOMString? unitsSpeed;
                attribute DOMString? unitsFuelConsumption;
};

[NoInterfaceObject]
interface Mirror : <ref>VehicleCommonDataType</ref> {
                attribute unsigned short? mirrorTilt;
                attribute unsigned short? mirrorPan;
    readonly    attribute <ref>Zone</ref>?           zone;
};

[NoInterfaceObject]
interface SeatAdjustment : <ref>VehicleCommonDataType</ref> {
                attribute unsigned short? reclineSeatBack;
                attribute unsigned short? seatSlide;
                attribute unsigned short? seatCushionHeight;
                attribute unsigned short? seatHeadrest;
                attribute unsigned short? seatBackCushion;
                attribute unsigned short? seatSideCushion;
    readonly    attribute <ref>Zone</ref>?           zone;
};

enum DriveModeEnum {
    &quot;comfort&quot;,
    &quot;auto&quot;,
    &quot;sport&quot;,
    &quot;eco&quot;,
    &quot;manual&quot;,
    &quot;winter&quot;
};

[NoInterfaceObject]
interface DriveMode : <ref>VehicleCommonDataType</ref> {
                attribute <ref>DriveModeEnum</ref>? driveMode;
};

[NoInterfaceObject]
interface DashboardIllumination : <ref>VehicleCommonDataType</ref> {
                attribute DOMString? dashboardIllumination;
};

[NoInterfaceObject]
interface VehicleSound : <ref>VehicleCommonDataType</ref> {
                attribute boolean    activeNoiseControlMode;
                attribute DOMString? engineSoundEnhancementMode;
};

[NoInterfaceObject]
interface AntilockBrakingSystem : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean enabled;
    readonly    attribute boolean engaged;
};

[NoInterfaceObject]
interface TractionControlSystem : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean enabled;
    readonly    attribute boolean engaged;
};

[NoInterfaceObject]
interface ElectronicStabilityControl : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean enabled;
    readonly    attribute boolean engaged;
};

[NoInterfaceObject]
interface TopSpeedLimit : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short speed;
};

[NoInterfaceObject]
interface AirbagStatus : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean activated;
    readonly    attribute boolean deployed;
    readonly    attribute <ref>Zone</ref>?   zone;
};

enum DoorOpenStatus {
    &quot;open&quot;,
    &quot;ajar&quot;,
    &quot;closed&quot;
};

[NoInterfaceObject]
interface Door : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>DoorOpenStatus</ref> status;
                attribute boolean        lock;
    readonly    attribute <ref>Zone</ref>?          zone;
};

[NoInterfaceObject]
interface ChildSafetyLock : <ref>VehicleCommonDataType</ref> {
                attribute boolean lock;
    readonly    attribute <ref>Zone</ref>?   zone;
};

enum OccupantStatus {
    &quot;adult&quot;,
    &quot;child&quot;,
    &quot;vacant&quot;
};

enum IdentificationType {
    &quot;pin&quot;,
    &quot;keyfob&quot;,
    &quot;Bluetooth&quot;,
    &quot;NFC&quot;,
    &quot;fingerprint&quot;,
    &quot;camera&quot;,
    &quot;voice&quot;
};

[NoInterfaceObject]
interface Seat : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>OccupantStatus</ref>     occupant;
    readonly    attribute boolean            seatbelt;
    readonly    attribute DOMString?         occupantName;
    readonly    attribute <ref>IdentificationType</ref> identificationType;
    readonly    attribute <ref>Zone</ref>?              zone;
};

[NoInterfaceObject]
interface Temperature : <ref>VehicleCommonDataType</ref> {
    readonly    attribute float interiorTemperature;
    readonly    attribute float exteriorTemperature;
};

[NoInterfaceObject]
interface RainSensor : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short rain;
    readonly    attribute <ref>Zone</ref>?          zone;
};

[NoInterfaceObject]
interface WiperStatus : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short wiperSpeed;
    readonly    attribute <ref>Zone</ref>?          zone;
};

enum WiperControl {
    &quot;off&quot;,
    &quot;once&quot;,
    &quot;slowest&quot;,
    &quot;slow&quot;,
    &quot;middle&quot;,
    &quot;fast&quot;,
    &quot;fastest&quot;,
    &quot;auto&quot;
};

[NoInterfaceObject]
interface WiperSetting : <ref>VehicleCommonDataType</ref> {
                attribute <ref>WiperControl</ref> wiperControl;
    readonly    attribute <ref>Zone</ref>?        zone;
};

[NoInterfaceObject]
interface Defrost : <ref>VehicleCommonDataType</ref> {
                attribute boolean? defrostWindow;
                attribute boolean? defrostMirrors;
    readonly    attribute <ref>Zone</ref>?    zone;
};

[NoInterfaceObject]
interface Sunroof : <ref>VehicleCommonDataType</ref> {
                attribute unsigned short openness;
                attribute unsigned short tilt;
    readonly    attribute <ref>Zone</ref>?          zone;
};

enum ConvertibleRoofStatus {
    &quot;closed&quot;,
    &quot;closing&quot;,
    &quot;opening&quot;,
    &quot;opened&quot;
};

[NoInterfaceObject]
interface ConvertibleRoof : <ref>VehicleCommonDataType</ref> {
                attribute <ref>ConvertibleRoofStatus</ref> status;
};

[NoInterfaceObject]
interface SideWindow : <ref>VehicleCommonDataType</ref> {
                attribute boolean?        lock;
                attribute unsigned short? openness;
    readonly    attribute <ref>Zone</ref>?           zone;
};

enum AirflowDirection {
    &quot;frontpanel&quot;,
    &quot;floorduct&quot;,
    &quot;bilevel&quot;,
    &quot;defrostfloor&quot;
};

[NoInterfaceObject]
interface ClimateControl : <ref>VehicleCommonDataType</ref> {
                attribute <ref>AirflowDirection</ref>  airflowDirection;
                attribute unsigned short    fanSpeedLevel;
                attribute short?            targetTemperature;
                attribute boolean           airConditioning;
                attribute boolean           heater;
                attribute unsigned short?   seatHeater;
                attribute unsigned short?   seatCooler;
                attribute boolean           airRecirculation;
                attribute unsigned short?   steeringWheelHeater;
    readonly    attribute <ref>Zone</ref>?             zone;
};

[NoInterfaceObject]
interface AtmosphericPressure : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short pressure;
};

enum LaneDepartureStatus {
    &quot;off&quot;,
    &quot;pause&quot;,
    &quot;running&quot;
};

[NoInterfaceObject]
interface LaneDepartureDetection : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>LaneDepartureStatus</ref> status;
};

enum AlarmStatus {
    &quot;disarmed&quot;,
    &quot;preArmed&quot;,
    &quot;armed&quot;,
    &quot;alarmed&quot;
};

[NoInterfaceObject]
interface Alarm : <ref>VehicleCommonDataType</ref> {
                attribute <ref>AlarmStatus</ref> status;
};

enum ParkingBrakeStatus {
    &quot;inactive&quot;,
    &quot;active&quot;,
    &quot;error&quot;
};

[NoInterfaceObject]
interface ParkingBrake : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>ParkingBrakeStatus</ref> status;
};

[NoInterfaceObject]
interface ParkingLights : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean status;
                attribute boolean setting;
};</webidl>
  <Interface name="VehicleManagerObject" id="::VehicleManagerObject">
    <webidl>[NoInterfaceObject] interface VehicleManagerObject {
    readonly    attribute <ref>Vehicle</ref> vehicle;
};</webidl>
    <Attribute readonly="readonly" name="vehicle" id="::VehicleManagerObject::vehicle">
      <webidl>    readonly attribute <ref>Vehicle</ref> vehicle;</webidl>
      <Type name="Vehicle"/>
    </Attribute>
  </Interface>
  <Implements name1="Navigator" name2="VehicleManagerObject">
    <webidl><ref>Navigator</ref> implements <ref>VehicleManagerObject</ref>;</webidl>
  </Implements>
  <Interface name="Vehicle" id="::Vehicle">
    <webidl>[NoInterfaceObject]
interface Vehicle {
    readonly    attribute <ref>VehicleConfigurationInterface</ref> identification;
    readonly    attribute <ref>VehicleConfigurationInterface</ref> sizeConfiguration;
    readonly    attribute <ref>VehicleConfigurationInterface</ref> fuelConfiguration;
    readonly    attribute <ref>VehicleConfigurationInterface</ref> transmissionConfiguration;
    readonly    attribute <ref>VehicleConfigurationInterface</ref> wheelConfiguration;
    readonly    attribute <ref>VehicleSignalInterface</ref>        steeringWheelConfiguration;

    readonly    attribute <ref>VehicleSignalInterface</ref> vehicleSpeed;
    readonly    attribute <ref>VehicleSignalInterface</ref> wheelSpeed;
    readonly    attribute <ref>VehicleSignalInterface</ref> engineSpeed;
    readonly    attribute <ref>VehicleSignalInterface</ref> powerTrainTorque;
    readonly    attribute <ref>VehicleSignalInterface</ref> acceleratorPedalPosition;
    readonly    attribute <ref>VehicleSignalInterface</ref> throttlePosition;
    readonly    attribute <ref>VehicleSignalInterface</ref> tripMeters;
    readonly    attribute <ref>VehicleSignalInterface</ref> transmission;
    readonly    attribute <ref>VehicleSignalInterface</ref> cruiseControlStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> lightStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> interiorLightStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> horn;
    readonly    attribute <ref>VehicleSignalInterface</ref> chime;
    readonly    attribute <ref>VehicleSignalInterface</ref> fuel;
    readonly    attribute <ref>VehicleSignalInterface</ref> engineOil;
    readonly    attribute <ref>VehicleSignalInterface</ref> acceleration;
    readonly    attribute <ref>VehicleSignalInterface</ref> engineCoolant;
    readonly    attribute <ref>VehicleSignalInterface</ref> steeringWheel;
    readonly    attribute <ref>VehicleSignalInterface</ref> ignitionTime;
    readonly    attribute <ref>VehicleSignalInterface</ref> yawRate;
    readonly    attribute <ref>VehicleSignalInterface</ref> brakeOperation;
    readonly    attribute <ref>VehicleSignalInterface</ref> wheelTick;
    readonly    attribute <ref>VehicleSignalInterface</ref> buttonEvent;
    readonly    attribute <ref>VehicleSignalInterface</ref> drivingMode;
    readonly    attribute <ref>VehicleSignalInterface</ref> nightMode;

    readonly    attribute <ref>VehicleSignalInterface</ref> odometer;
    readonly    attribute <ref>VehicleSignalInterface</ref> transmissionOil;
    readonly    attribute <ref>VehicleSignalInterface</ref> transmissionClutch;
    readonly    attribute <ref>VehicleSignalInterface</ref> brakeMaintenance;
    readonly    attribute <ref>VehicleSignalInterface</ref> washerFluid;
    readonly    attribute <ref>VehicleSignalInterface</ref> malfunctionIndicator;
    readonly    attribute <ref>VehicleSignalInterface</ref> batteryStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> tire;
    readonly    attribute <ref>VehicleSignalInterface</ref> diagnostic;

    readonly    attribute <ref>VehicleSignalInterface</ref>? languageConfiguration;
    readonly    attribute <ref>VehicleSignalInterface</ref>  unitsOfMeasure;
    readonly    attribute <ref>VehicleSignalInterface</ref>  mirror;
    readonly    attribute <ref>VehicleSignalInterface</ref>  driveMode;
    readonly    attribute <ref>VehicleSignalInterface</ref>  seatAdjustment;
    readonly    attribute <ref>VehicleSignalInterface</ref>  dashboardIllumination;
    readonly    attribute <ref>VehicleSignalInterface</ref>  vehicleSound;

    readonly    attribute <ref>VehicleSignalInterface</ref> antilockBrakingSystem;
    readonly    attribute <ref>VehicleSignalInterface</ref> tractionControlSystem;
    readonly    attribute <ref>VehicleSignalInterface</ref> electronicStabilityControl;
    readonly    attribute <ref>VehicleSignalInterface</ref> topSpeedLimit;
    readonly    attribute <ref>VehicleSignalInterface</ref> airbagStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> door;
    readonly    attribute <ref>VehicleSignalInterface</ref> childSafetyLock;
    readonly    attribute <ref>VehicleSignalInterface</ref> seat;

    readonly    attribute <ref>VehicleSignalInterface</ref> temperature;
    readonly    attribute <ref>VehicleSignalInterface</ref> rainSensor;
    readonly    attribute <ref>VehicleSignalInterface</ref> wiperStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> wiperSetting;
    readonly    attribute <ref>VehicleSignalInterface</ref> defrost;
    readonly    attribute <ref>VehicleSignalInterface</ref> sunroof;
    readonly    attribute <ref>VehicleSignalInterface</ref> convertibleRoof;
    readonly    attribute <ref>VehicleSignalInterface</ref> sideWindow;
    readonly    attribute <ref>VehicleSignalInterface</ref> climateControl;
    readonly    attribute <ref>VehicleSignalInterface</ref> atmosphericPressure;

    readonly    attribute <ref>VehicleSignalInterface</ref> laneDepartureStatus;
    readonly    attribute <ref>VehicleSignalInterface</ref> alarm;
    readonly    attribute <ref>VehicleSignalInterface</ref> parkingBrake;
    readonly    attribute <ref>VehicleSignalInterface</ref> parkingLights;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="identification" id="::Vehicle::identification">
      <webidl>    readonly    attribute <ref>VehicleConfigurationInterface</ref> identification;</webidl>
      <Type name="VehicleConfigurationInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="sizeConfiguration" id="::Vehicle::sizeConfiguration">
      <webidl>    readonly    attribute <ref>VehicleConfigurationInterface</ref> sizeConfiguration;</webidl>
      <Type name="VehicleConfigurationInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="fuelConfiguration" id="::Vehicle::fuelConfiguration">
      <webidl>    readonly    attribute <ref>VehicleConfigurationInterface</ref> fuelConfiguration;</webidl>
      <Type name="VehicleConfigurationInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="transmissionConfiguration" id="::Vehicle::transmissionConfiguration">
      <webidl>    readonly    attribute <ref>VehicleConfigurationInterface</ref> transmissionConfiguration;</webidl>
      <Type name="VehicleConfigurationInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="wheelConfiguration" id="::Vehicle::wheelConfiguration">
      <webidl>    readonly    attribute <ref>VehicleConfigurationInterface</ref> wheelConfiguration;</webidl>
      <Type name="VehicleConfigurationInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="steeringWheelConfiguration" id="::Vehicle::steeringWheelConfiguration">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref>        steeringWheelConfiguration;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="vehicleSpeed" id="::Vehicle::vehicleSpeed">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> vehicleSpeed;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="wheelSpeed" id="::Vehicle::wheelSpeed">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> wheelSpeed;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="engineSpeed" id="::Vehicle::engineSpeed">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> engineSpeed;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="powerTrainTorque" id="::Vehicle::powerTrainTorque">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> powerTrainTorque;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="acceleratorPedalPosition" id="::Vehicle::acceleratorPedalPosition">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> acceleratorPedalPosition;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="throttlePosition" id="::Vehicle::throttlePosition">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> throttlePosition;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="tripMeters" id="::Vehicle::tripMeters">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> tripMeters;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="transmission" id="::Vehicle::transmission">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> transmission;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="cruiseControlStatus" id="::Vehicle::cruiseControlStatus">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> cruiseControlStatus;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="lightStatus" id="::Vehicle::lightStatus">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> lightStatus;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="interiorLightStatus" id="::Vehicle::interiorLightStatus">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> interiorLightStatus;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="horn" id="::Vehicle::horn">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> horn;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="chime" id="::Vehicle::chime">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> chime;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="fuel" id="::Vehicle::fuel">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> fuel;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="engineOil" id="::Vehicle::engineOil">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> engineOil;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="acceleration" id="::Vehicle::acceleration">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> acceleration;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="engineCoolant" id="::Vehicle::engineCoolant">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> engineCoolant;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="steeringWheel" id="::Vehicle::steeringWheel">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> steeringWheel;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="ignitionTime" id="::Vehicle::ignitionTime">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> ignitionTime;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="yawRate" id="::Vehicle::yawRate">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> yawRate;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="brakeOperation" id="::Vehicle::brakeOperation">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> brakeOperation;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="wheelTick" id="::Vehicle::wheelTick">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> wheelTick;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="buttonEvent" id="::Vehicle::buttonEvent">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> buttonEvent;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="drivingMode" id="::Vehicle::drivingMode">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> drivingMode;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="nightMode" id="::Vehicle::nightMode">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> nightMode;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="odometer" id="::Vehicle::odometer">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> odometer;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="transmissionOil" id="::Vehicle::transmissionOil">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> transmissionOil;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="transmissionClutch" id="::Vehicle::transmissionClutch">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> transmissionClutch;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="brakeMaintenance" id="::Vehicle::brakeMaintenance">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> brakeMaintenance;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="washerFluid" id="::Vehicle::washerFluid">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> washerFluid;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="malfunctionIndicator" id="::Vehicle::malfunctionIndicator">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> malfunctionIndicator;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="batteryStatus" id="::Vehicle::batteryStatus">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> batteryStatus;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="tire" id="::Vehicle::tire">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> tire;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="diagnostic" id="::Vehicle::diagnostic">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> diagnostic;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="languageConfiguration" id="::Vehicle::languageConfiguration">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref>? languageConfiguration;</webidl>
      <Type name="VehicleSignalInterface" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="unitsOfMeasure" id="::Vehicle::unitsOfMeasure">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref>  unitsOfMeasure;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="mirror" id="::Vehicle::mirror">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref>  mirror;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="driveMode" id="::Vehicle::driveMode">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref>  driveMode;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="seatAdjustment" id="::Vehicle::seatAdjustment">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref>  seatAdjustment;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="dashboardIllumination" id="::Vehicle::dashboardIllumination">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref>  dashboardIllumination;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="vehicleSound" id="::Vehicle::vehicleSound">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref>  vehicleSound;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="antilockBrakingSystem" id="::Vehicle::antilockBrakingSystem">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> antilockBrakingSystem;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="tractionControlSystem" id="::Vehicle::tractionControlSystem">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> tractionControlSystem;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="electronicStabilityControl" id="::Vehicle::electronicStabilityControl">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> electronicStabilityControl;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="topSpeedLimit" id="::Vehicle::topSpeedLimit">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> topSpeedLimit;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="airbagStatus" id="::Vehicle::airbagStatus">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> airbagStatus;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="door" id="::Vehicle::door">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> door;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="childSafetyLock" id="::Vehicle::childSafetyLock">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> childSafetyLock;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="seat" id="::Vehicle::seat">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> seat;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="temperature" id="::Vehicle::temperature">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> temperature;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="rainSensor" id="::Vehicle::rainSensor">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> rainSensor;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="wiperStatus" id="::Vehicle::wiperStatus">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> wiperStatus;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="wiperSetting" id="::Vehicle::wiperSetting">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> wiperSetting;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="defrost" id="::Vehicle::defrost">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> defrost;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="sunroof" id="::Vehicle::sunroof">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> sunroof;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="convertibleRoof" id="::Vehicle::convertibleRoof">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> convertibleRoof;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="sideWindow" id="::Vehicle::sideWindow">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> sideWindow;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="climateControl" id="::Vehicle::climateControl">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> climateControl;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="atmosphericPressure" id="::Vehicle::atmosphericPressure">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> atmosphericPressure;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="laneDepartureStatus" id="::Vehicle::laneDepartureStatus">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> laneDepartureStatus;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="alarm" id="::Vehicle::alarm">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> alarm;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="parkingBrake" id="::Vehicle::parkingBrake">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> parkingBrake;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
    <Attribute readonly="readonly" name="parkingLights" id="::Vehicle::parkingLights">
      <webidl>    readonly    attribute <ref>VehicleSignalInterface</ref> parkingLights;</webidl>
      <Type name="VehicleSignalInterface"/>
    </Attribute>
  </Interface>
  <Enum name="ZonePosition" id="::ZonePosition">
    <webidl>enum ZonePosition {
    &quot;front&quot;,
    &quot;middle&quot;,
    &quot;right&quot;,
    &quot;left&quot;,
    &quot;rear&quot;,
    &quot;center&quot;
};</webidl>
    <EnumValue stringvalue="front">
      <webidl>    &quot;front</webidl>
    </EnumValue>
    <EnumValue stringvalue="middle">
      <webidl>    &quot;middle</webidl>
    </EnumValue>
    <EnumValue stringvalue="right">
      <webidl>    &quot;right</webidl>
    </EnumValue>
    <EnumValue stringvalue="left">
      <webidl>    &quot;left</webidl>
    </EnumValue>
    <EnumValue stringvalue="rear">
      <webidl>    &quot;rear</webidl>
    </EnumValue>
    <EnumValue stringvalue="center">
      <webidl>    &quot;center</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Zone" id="::Zone">
    <webidl>interface Zone {
                attribute DOMString[] value;
    readonly    attribute <ref>Zone</ref>        driver;
    boolean equals (<ref>Zone</ref> zone);
    boolean contains (<ref>Zone</ref> zone);
};</webidl>
    <Attribute name="value" id="::Zone::value">
      <webidl>                attribute DOMString[] value;</webidl>
      <Type type="array">
        <Type type="DOMString"/>
      </Type>
    </Attribute>
    <Attribute readonly="readonly" name="driver" id="::Zone::driver">
      <webidl>    readonly    attribute <ref>Zone</ref>        driver;</webidl>
      <Type name="Zone"/>
    </Attribute>
    <Operation name="equals" id="::Zone::equals">
      <webidl>    boolean equals (<ref>Zone</ref> zone);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="zone">
          <Type name="Zone"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="contains" id="::Zone::contains">
      <webidl>    boolean contains (<ref>Zone</ref> zone);</webidl>
      <Type type="boolean"/>
      <ArgumentList>
        <Argument name="zone">
          <Type name="Zone"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="VehicleInterfaceCallback" id="::VehicleInterfaceCallback">
    <webidl>[Callback=FunctionOnly, NoInterfaceObject]
interface VehicleInterfaceCallback {
    void onsuccess(object value);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Callback" value="FunctionOnly">
        <webidl>Callback</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl> NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="onsuccess" id="::VehicleInterfaceCallback::onsuccess">
      <webidl>    void onsuccess(object value);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="value">
          <Type type="object"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Interface name="AvailableCallback" id="::AvailableCallback">
    <webidl>[Callback=FunctionOnly, NoInterfaceObject]
interface AvailableCallback {
    void onsuccess(<ref>Availability</ref> available);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="Callback" value="FunctionOnly">
        <webidl>Callback</webidl>
      </ExtendedAttribute>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl> NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="onsuccess" id="::AvailableCallback::onsuccess">
      <webidl>    void onsuccess(<ref>Availability</ref> available);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="available">
          <Type name="Availability"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Enum name="VehicleError" id="::VehicleError">
    <webidl>enum VehicleError {
    &quot;permission_denied&quot;,
    &quot;invalid_operation&quot;,
    &quot;timeout&quot;,
    &quot;invalid_zone&quot;,
    &quot;unknown&quot;
};</webidl>
    <EnumValue stringvalue="permission_denied">
      <webidl>    &quot;permission_denied</webidl>
    </EnumValue>
    <EnumValue stringvalue="invalid_operation">
      <webidl>    &quot;invalid_operation</webidl>
    </EnumValue>
    <EnumValue stringvalue="timeout">
      <webidl>    &quot;timeout</webidl>
    </EnumValue>
    <EnumValue stringvalue="invalid_zone">
      <webidl>    &quot;invalid_zone</webidl>
    </EnumValue>
    <EnumValue stringvalue="unknown">
      <webidl>    &quot;unknown</webidl>
    </EnumValue>
  </Enum>
  <Interface name="VehicleInterfaceError" id="::VehicleInterfaceError">
    <webidl>[NoInterfaceObject]
interface VehicleInterfaceError {
    readonly    attribute <ref>VehicleError</ref> error;
    readonly    attribute DOMString    message;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="error" id="::VehicleInterfaceError::error">
      <webidl>    readonly    attribute <ref>VehicleError</ref> error;</webidl>
      <Type name="VehicleError"/>
    </Attribute>
    <Attribute readonly="readonly" name="message" id="::VehicleInterfaceError::message">
      <webidl>    readonly    attribute DOMString    message;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="VehicleInterface" id="::VehicleInterface">
    <webidl>interface VehicleInterface {
    <ref>Availability</ref>   availableForRetrieval (DOMString attributeName);
    <ref>Promise</ref>        get (optional <ref>Zone</ref> zone);
    <ref>Promise</ref>        getHistory (Date begin, Date end, optional <ref>Zone</ref> zone);
    short          availabilityChangedListener (<ref>AvailableCallback</ref> callback);
    void           removeAvailabilityChangedListener (short handle);
    readonly       attribute <ref>Zone</ref>[] zones;
    readonly       attribute boolean supported;
    readonly       attribute boolean isLogged;
    readonly       attribute Date ?  from;
    readonly       attribute Date ?  to;
};</webidl>
    <Operation name="availableForRetrieval" id="::VehicleInterface::availableForRetrieval">
      <webidl>    <ref>Availability</ref>   availableForRetrieval (DOMString attributeName);</webidl>
      <Type name="Availability"/>
      <ArgumentList>
        <Argument name="attributeName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="get" id="::VehicleInterface::get">
      <webidl>    <ref>Promise</ref>        get (optional <ref>Zone</ref> zone);</webidl>
      <Type name="Promise"/>
      <ArgumentList>
        <Argument optional="optional" name="zone">
          <Type name="Zone"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="getHistory" id="::VehicleInterface::getHistory">
      <webidl>    <ref>Promise</ref>        getHistory (Date begin, Date end, optional <ref>Zone</ref> zone);</webidl>
      <Type name="Promise"/>
      <ArgumentList>
        <Argument name="begin">
          <Type type="Date"/>
        </Argument>
        <Argument name="end">
          <Type type="Date"/>
        </Argument>
        <Argument optional="optional" name="zone">
          <Type name="Zone"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="availabilityChangedListener" id="::VehicleInterface::availabilityChangedListener">
      <webidl>    short          availabilityChangedListener (<ref>AvailableCallback</ref> callback);</webidl>
      <Type type="short"/>
      <ArgumentList>
        <Argument name="callback">
          <Type name="AvailableCallback"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="removeAvailabilityChangedListener" id="::VehicleInterface::removeAvailabilityChangedListener">
      <webidl>    void           removeAvailabilityChangedListener (short handle);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="handle">
          <Type type="short"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Attribute readonly="readonly" name="zones" id="::VehicleInterface::zones">
      <webidl>    readonly       attribute <ref>Zone</ref>[] zones;</webidl>
      <Type type="array">
        <Type name="Zone"/>
      </Type>
    </Attribute>
    <Attribute readonly="readonly" name="supported" id="::VehicleInterface::supported">
      <webidl>    readonly       attribute boolean supported;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="isLogged" id="::VehicleInterface::isLogged">
      <webidl>    readonly       attribute boolean isLogged;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="from" id="::VehicleInterface::from">
      <webidl>    readonly       attribute Date ?  from;</webidl>
      <Type type="Date" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="to" id="::VehicleInterface::to">
      <webidl>    readonly       attribute Date ?  to;</webidl>
      <Type type="Date" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="VehicleConfigurationInterface" id="::VehicleConfigurationInterface">
    <webidl>[NoInterfaceObject]
interface VehicleConfigurationInterface : <ref>VehicleInterface</ref> {};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleInterface"/>
    </InterfaceInheritance>
  </Interface>
  <Interface name="VehicleSignalInterface" id="::VehicleSignalInterface">
    <webidl>[NoInterfaceObject]
interface VehicleSignalInterface : <ref>VehicleInterface</ref> {
    <ref>Availability</ref>   availableForSubscription (DOMString attributeName);
    <ref>Availability</ref>   availableForSetting (DOMString attributeName);
    <ref>Promise</ref>        set (object value, optional <ref>Zone</ref> zone);
    unsigned short subscribe (<ref>VehicleInterfaceCallback</ref> callback, optional <ref>Zone</ref> zone);
    void           unsubscribe (unsigned short handle);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleInterface"/>
    </InterfaceInheritance>
    <Operation name="availableForSubscription" id="::VehicleSignalInterface::availableForSubscription">
      <webidl>    <ref>Availability</ref>   availableForSubscription (DOMString attributeName);</webidl>
      <Type name="Availability"/>
      <ArgumentList>
        <Argument name="attributeName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="availableForSetting" id="::VehicleSignalInterface::availableForSetting">
      <webidl>    <ref>Availability</ref>   availableForSetting (DOMString attributeName);</webidl>
      <Type name="Availability"/>
      <ArgumentList>
        <Argument name="attributeName">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="set" id="::VehicleSignalInterface::set">
      <webidl>    <ref>Promise</ref>        set (object value, optional <ref>Zone</ref> zone);</webidl>
      <Type name="Promise"/>
      <ArgumentList>
        <Argument name="value">
          <Type type="object"/>
        </Argument>
        <Argument optional="optional" name="zone">
          <Type name="Zone"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="subscribe" id="::VehicleSignalInterface::subscribe">
      <webidl>    unsigned short subscribe (<ref>VehicleInterfaceCallback</ref> callback, optional <ref>Zone</ref> zone);</webidl>
      <Type type="unsigned short"/>
      <ArgumentList>
        <Argument name="callback">
          <Type name="VehicleInterfaceCallback"/>
        </Argument>
        <Argument optional="optional" name="zone">
          <Type name="Zone"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="unsubscribe" id="::VehicleSignalInterface::unsubscribe">
      <webidl>    void           unsubscribe (unsigned short handle);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="handle">
          <Type type="unsigned short"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Enum name="Availability" id="::Availability">
    <webidl>enum Availability {
    &quot;available&quot;,
    &quot;not_supported&quot;,
    &quot;not_supported_yet&quot;,
    &quot;not_supported_security_policy&quot;,
    &quot;not_supported_business_policy&quot;,
    &quot;not_supported_other&quot;
};</webidl>
    <EnumValue stringvalue="available">
      <webidl>    &quot;available</webidl>
    </EnumValue>
    <EnumValue stringvalue="not_supported">
      <webidl>    &quot;not_supported</webidl>
    </EnumValue>
    <EnumValue stringvalue="not_supported_yet">
      <webidl>    &quot;not_supported_yet</webidl>
    </EnumValue>
    <EnumValue stringvalue="not_supported_security_policy">
      <webidl>    &quot;not_supported_security_policy</webidl>
    </EnumValue>
    <EnumValue stringvalue="not_supported_business_policy">
      <webidl>    &quot;not_supported_business_policy</webidl>
    </EnumValue>
    <EnumValue stringvalue="not_supported_other">
      <webidl>    &quot;not_supported_other</webidl>
    </EnumValue>
  </Enum>
  <Interface name="VehicleCommonDataType" id="::VehicleCommonDataType">
    <webidl>[NoInterfaceObject]
interface VehicleCommonDataType {
    readonly    attribute <ref>DOMTimeStamp</ref>? timeStamp;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="timeStamp" id="::VehicleCommonDataType::timeStamp">
      <webidl>    readonly    attribute <ref>DOMTimeStamp</ref>? timeStamp;</webidl>
      <Type name="DOMTimeStamp" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="VehicleTypeEnum" id="::VehicleTypeEnum">
    <webidl>enum VehicleTypeEnum {
    &quot;passengerCarMini&quot;,
    &quot;passengerCarLight&quot;,
    &quot;passengerCarCompact&quot;,
    &quot;passengerCarMedium&quot;,
    &quot;passengerCarHeavy&quot;,
    &quot;sportUtilityVehicle&quot;,
    &quot;pickupTruck&quot;,
    &quot;van&quot;
};</webidl>
    <EnumValue stringvalue="passengerCarMini">
      <webidl>    &quot;passengerCarMini</webidl>
    </EnumValue>
    <EnumValue stringvalue="passengerCarLight">
      <webidl>    &quot;passengerCarLight</webidl>
    </EnumValue>
    <EnumValue stringvalue="passengerCarCompact">
      <webidl>    &quot;passengerCarCompact</webidl>
    </EnumValue>
    <EnumValue stringvalue="passengerCarMedium">
      <webidl>    &quot;passengerCarMedium</webidl>
    </EnumValue>
    <EnumValue stringvalue="passengerCarHeavy">
      <webidl>    &quot;passengerCarHeavy</webidl>
    </EnumValue>
    <EnumValue stringvalue="sportUtilityVehicle">
      <webidl>    &quot;sportUtilityVehicle</webidl>
    </EnumValue>
    <EnumValue stringvalue="pickupTruck">
      <webidl>    &quot;pickupTruck</webidl>
    </EnumValue>
    <EnumValue stringvalue="van">
      <webidl>    &quot;van</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Identification" id="::Identification">
    <webidl>[NoInterfaceObject]
interface Identification : <ref>VehicleCommonDataType</ref> {
    readonly    attribute DOMString?       VIN;
    readonly    attribute DOMString?       WMI;
    readonly    attribute <ref>VehicleTypeEnum</ref>? vehicleType;
    readonly    attribute DOMString?       brand;
    readonly    attribute DOMString?       model;
    readonly    attribute unsigned short?  year;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="VIN" id="::Identification::VIN">
      <webidl>    readonly    attribute DOMString?       VIN;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="WMI" id="::Identification::WMI">
      <webidl>    readonly    attribute DOMString?       WMI;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="vehicleType" id="::Identification::vehicleType">
      <webidl>    readonly    attribute <ref>VehicleTypeEnum</ref>? vehicleType;</webidl>
      <Type name="VehicleTypeEnum" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="brand" id="::Identification::brand">
      <webidl>    readonly    attribute DOMString?       brand;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="model" id="::Identification::model">
      <webidl>    readonly    attribute DOMString?       model;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="year" id="::Identification::year">
      <webidl>    readonly    attribute unsigned short?  year;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="SizeConfiguration" id="::SizeConfiguration">
    <webidl>[NoInterfaceObject]
interface SizeConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short?   width;
    readonly    attribute unsigned short?   height;
    readonly    attribute unsigned short?   length;
    readonly    attribute unsigned short[]? doorsCount;
    readonly    attribute unsigned short?   totalDoors;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="width" id="::SizeConfiguration::width">
      <webidl>    readonly    attribute unsigned short?   width;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="height" id="::SizeConfiguration::height">
      <webidl>    readonly    attribute unsigned short?   height;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="length" id="::SizeConfiguration::length">
      <webidl>    readonly    attribute unsigned short?   length;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="doorsCount" id="::SizeConfiguration::doorsCount">
      <webidl>    readonly    attribute unsigned short[]? doorsCount;</webidl>
      <Type type="array" nullable="nullable">
        <Type type="unsigned short"/>
      </Type>
    </Attribute>
    <Attribute readonly="readonly" name="totalDoors" id="::SizeConfiguration::totalDoors">
      <webidl>    readonly    attribute unsigned short?   totalDoors;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="FuelTypeEnum" id="::FuelTypeEnum">
    <webidl>enum FuelTypeEnum {
    &quot;gasoline&quot;,
    &quot;methanol&quot;,
    &quot;ethanol&quot;,
    &quot;diesel&quot;,
    &quot;lpg&quot;,
    &quot;cng&quot;,
    &quot;electric&quot;
};</webidl>
    <EnumValue stringvalue="gasoline">
      <webidl>    &quot;gasoline</webidl>
    </EnumValue>
    <EnumValue stringvalue="methanol">
      <webidl>    &quot;methanol</webidl>
    </EnumValue>
    <EnumValue stringvalue="ethanol">
      <webidl>    &quot;ethanol</webidl>
    </EnumValue>
    <EnumValue stringvalue="diesel">
      <webidl>    &quot;diesel</webidl>
    </EnumValue>
    <EnumValue stringvalue="lpg">
      <webidl>    &quot;lpg</webidl>
    </EnumValue>
    <EnumValue stringvalue="cng">
      <webidl>    &quot;cng</webidl>
    </EnumValue>
    <EnumValue stringvalue="electric">
      <webidl>    &quot;electric</webidl>
    </EnumValue>
  </Enum>
  <Interface name="FuelConfiguration" id="::FuelConfiguration">
    <webidl>[NoInterfaceObject]
interface FuelConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>FuelTypeEnum</ref>[]? fuelType;
    readonly    attribute <ref>Zone</ref>?           refuelPosition;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="fuelType" id="::FuelConfiguration::fuelType">
      <webidl>    readonly    attribute <ref>FuelTypeEnum</ref>[]? fuelType;</webidl>
      <Type type="array" nullable="nullable">
        <Type name="FuelTypeEnum"/>
      </Type>
    </Attribute>
    <Attribute readonly="readonly" name="refuelPosition" id="::FuelConfiguration::refuelPosition">
      <webidl>    readonly    attribute <ref>Zone</ref>?           refuelPosition;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="TransmissionGearTypeEnum" id="::TransmissionGearTypeEnum">
    <webidl>enum TransmissionGearTypeEnum {
    &quot;auto&quot;,
    &quot;manual&quot;
};</webidl>
    <EnumValue stringvalue="auto">
      <webidl>    &quot;auto</webidl>
    </EnumValue>
    <EnumValue stringvalue="manual">
      <webidl>    &quot;manual</webidl>
    </EnumValue>
  </Enum>
  <Interface name="TransmissionConfiguration" id="::TransmissionConfiguration">
    <webidl>[NoInterfaceObject]
interface TransmissionConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>TransmissionGearTypeEnum</ref>? transmissionGearType;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="transmissionGearType" id="::TransmissionConfiguration::transmissionGearType">
      <webidl>    readonly    attribute <ref>TransmissionGearTypeEnum</ref>? transmissionGearType;</webidl>
      <Type name="TransmissionGearTypeEnum" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="WheelConfiguration" id="::WheelConfiguration">
    <webidl>[NoInterfaceObject]
interface WheelConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short? wheelRadius;
    readonly    attribute <ref>Zone</ref>?           zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="wheelRadius" id="::WheelConfiguration::wheelRadius">
      <webidl>    readonly    attribute unsigned short? wheelRadius;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::WheelConfiguration::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?           zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="SteeringWheelConfiguration" id="::SteeringWheelConfiguration">
    <webidl>[NoInterfaceObject]
interface SteeringWheelConfiguration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean?        steeringWheelLeft;
                attribute unsigned short? steeringWheelTelescopingPosition;
                attribute unsigned short? steeringWheelPositionTilt;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="steeringWheelLeft" id="::SteeringWheelConfiguration::steeringWheelLeft">
      <webidl>    readonly    attribute boolean?        steeringWheelLeft;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute name="steeringWheelTelescopingPosition" id="::SteeringWheelConfiguration::steeringWheelTelescopingPosition">
      <webidl>                attribute unsigned short? steeringWheelTelescopingPosition;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="steeringWheelPositionTilt" id="::SteeringWheelConfiguration::steeringWheelPositionTilt">
      <webidl>                attribute unsigned short? steeringWheelPositionTilt;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="VehicleSpeed" id="::VehicleSpeed">
    <webidl>[NoInterfaceObject]
interface VehicleSpeed : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short speed;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="speed" id="::VehicleSpeed::speed">
      <webidl>    readonly    attribute unsigned short speed;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Interface name="WheelSpeed" id="::WheelSpeed">
    <webidl>[NoInterfaceObject]
interface WheelSpeed : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short speed;
    readonly    attribute <ref>Zone</ref>?          zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="speed" id="::WheelSpeed::speed">
      <webidl>    readonly    attribute unsigned short speed;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::WheelSpeed::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?          zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="EngineSpeed" id="::EngineSpeed">
    <webidl>[NoInterfaceObject]
interface EngineSpeed : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned long speed;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="speed" id="::EngineSpeed::speed">
      <webidl>    readonly    attribute unsigned long speed;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
  </Interface>
  <Enum name="VehiclePowerMode" id="::VehiclePowerMode">
    <webidl>enum VehiclePowerMode {
    &quot;off&quot;,
    &quot;accessory1&quot;,
    &quot;accessory2&quot;,
    &quot;running&quot;
};</webidl>
    <EnumValue stringvalue="off">
      <webidl>    &quot;off</webidl>
    </EnumValue>
    <EnumValue stringvalue="accessory1">
      <webidl>    &quot;accessory1</webidl>
    </EnumValue>
    <EnumValue stringvalue="accessory2">
      <webidl>    &quot;accessory2</webidl>
    </EnumValue>
    <EnumValue stringvalue="running">
      <webidl>    &quot;running</webidl>
    </EnumValue>
  </Enum>
  <Interface name="VehiclePowerModeType" id="::VehiclePowerModeType">
    <webidl>[NoInterfaceObject]
interface VehiclePowerModeType : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>VehiclePowerMode</ref> value;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="value" id="::VehiclePowerModeType::value">
      <webidl>    readonly    attribute <ref>VehiclePowerMode</ref> value;</webidl>
      <Type name="VehiclePowerMode"/>
    </Attribute>
  </Interface>
  <Interface name="PowerTrainTorque" id="::PowerTrainTorque">
    <webidl>[NoInterfaceObject]
interface PowerTrainTorque : <ref>VehicleCommonDataType</ref> {
    readonly    attribute short value;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="value" id="::PowerTrainTorque::value">
      <webidl>    readonly    attribute short value;</webidl>
      <Type type="short"/>
    </Attribute>
  </Interface>
  <Interface name="AcceleratorPedalPosition" id="::AcceleratorPedalPosition">
    <webidl>[NoInterfaceObject]
interface AcceleratorPedalPosition : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short value;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="value" id="::AcceleratorPedalPosition::value">
      <webidl>    readonly    attribute unsigned short value;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Interface name="ThrottlePosition" id="::ThrottlePosition">
    <webidl>[NoInterfaceObject]
interface ThrottlePosition : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short value;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="value" id="::ThrottlePosition::value">
      <webidl>    readonly    attribute unsigned short value;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Interface name="Trip" id="::Trip">
    <webidl>[NoInterfaceObject]
interface Trip {
    readonly    attribute unsigned long   distance;
    readonly    attribute unsigned short? averageSpeed;
    readonly    attribute unsigned short? fuelConsumption;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="distance" id="::Trip::distance">
      <webidl>    readonly    attribute unsigned long   distance;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="averageSpeed" id="::Trip::averageSpeed">
      <webidl>    readonly    attribute unsigned short? averageSpeed;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="fuelConsumption" id="::Trip::fuelConsumption">
      <webidl>    readonly    attribute unsigned short? fuelConsumption;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="TripMeters" id="::TripMeters">
    <webidl>[NoInterfaceObject]
interface TripMeters : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>Trip</ref>[] meters;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="meters" id="::TripMeters::meters">
      <webidl>    readonly    attribute <ref>Trip</ref>[] meters;</webidl>
      <Type type="array">
        <Type name="Trip"/>
      </Type>
    </Attribute>
  </Interface>
  <Enum name="TransmissionMode" id="::TransmissionMode">
    <webidl>enum TransmissionMode {
    &quot;park&quot;,
    &quot;reverse&quot;,
    &quot;neutral&quot;,
    &quot;low&quot;,
    &quot;drive&quot;,
    &quot;overdrive&quot;
};</webidl>
    <EnumValue stringvalue="park">
      <webidl>    &quot;park</webidl>
    </EnumValue>
    <EnumValue stringvalue="reverse">
      <webidl>    &quot;reverse</webidl>
    </EnumValue>
    <EnumValue stringvalue="neutral">
      <webidl>    &quot;neutral</webidl>
    </EnumValue>
    <EnumValue stringvalue="low">
      <webidl>    &quot;low</webidl>
    </EnumValue>
    <EnumValue stringvalue="drive">
      <webidl>    &quot;drive</webidl>
    </EnumValue>
    <EnumValue stringvalue="overdrive">
      <webidl>    &quot;overdrive</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Transmission" id="::Transmission">
    <webidl>[NoInterfaceObject]
interface Transmission : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet?            gear;
    readonly    attribute <ref>TransmissionMode</ref>? mode;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="gear" id="::Transmission::gear">
      <webidl>    readonly    attribute octet?            gear;</webidl>
      <Type type="octet" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="mode" id="::Transmission::mode">
      <webidl>    readonly    attribute <ref>TransmissionMode</ref>? mode;</webidl>
      <Type name="TransmissionMode" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="CruiseControlStatus" id="::CruiseControlStatus">
    <webidl>[NoInterfaceObject]
interface CruiseControlStatus : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean        status;
    readonly    attribute unsigned short speed;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="status" id="::CruiseControlStatus::status">
      <webidl>    readonly    attribute boolean        status;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="speed" id="::CruiseControlStatus::speed">
      <webidl>    readonly    attribute unsigned short speed;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Interface name="LightStatus" id="::LightStatus">
    <webidl>[NoInterfaceObject]
interface LightStatus : <ref>VehicleCommonDataType</ref> {
                attribute boolean  head;
                attribute boolean  rightTurn;
                attribute boolean  leftTurn;
                attribute boolean  brake;
                attribute boolean? fog;
                attribute boolean  hazard;
                attribute boolean  parking;
                attribute boolean  highBeam;
                attribute boolean? automaticHeadlights;
                attribute boolean? dynamicHighBeam;
    readonly    attribute <ref>Zone</ref>?    zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="head" id="::LightStatus::head">
      <webidl>                attribute boolean  head;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="rightTurn" id="::LightStatus::rightTurn">
      <webidl>                attribute boolean  rightTurn;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="leftTurn" id="::LightStatus::leftTurn">
      <webidl>                attribute boolean  leftTurn;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="brake" id="::LightStatus::brake">
      <webidl>                attribute boolean  brake;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="fog" id="::LightStatus::fog">
      <webidl>                attribute boolean? fog;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute name="hazard" id="::LightStatus::hazard">
      <webidl>                attribute boolean  hazard;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="parking" id="::LightStatus::parking">
      <webidl>                attribute boolean  parking;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="highBeam" id="::LightStatus::highBeam">
      <webidl>                attribute boolean  highBeam;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="automaticHeadlights" id="::LightStatus::automaticHeadlights">
      <webidl>                attribute boolean? automaticHeadlights;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute name="dynamicHighBeam" id="::LightStatus::dynamicHighBeam">
      <webidl>                attribute boolean? dynamicHighBeam;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::LightStatus::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?    zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="InteriorLightStatus" id="::InteriorLightStatus">
    <webidl>[NoInterfaceObject]
interface InteriorLightStatus : <ref>VehicleCommonDataType</ref> {
                attribute boolean status;
    readonly    attribute <ref>Zone</ref>?   zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="status" id="::InteriorLightStatus::status">
      <webidl>                attribute boolean status;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::InteriorLightStatus::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?   zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Horn" id="::Horn">
    <webidl>[NoInterfaceObject]
interface Horn : <ref>VehicleCommonDataType</ref> {
                attribute boolean status;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="status" id="::Horn::status">
      <webidl>                attribute boolean status;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="Chime" id="::Chime">
    <webidl>[NoInterfaceObject]
interface Chime : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean status;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="status" id="::Chime::status">
      <webidl>    readonly    attribute boolean status;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="Fuel" id="::Fuel">
    <webidl>[NoInterfaceObject]
interface Fuel : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short? level;
    readonly    attribute unsigned long?  range;
    readonly    attribute unsigned long?  instantConsumption;
                attribute unsigned long?  averageConsumption;
    readonly    attribute unsigned long?  fuelConsumedSinceRestart;
    readonly    attribute unsigned long?  timeSinceRestart;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="level" id="::Fuel::level">
      <webidl>    readonly    attribute unsigned short? level;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="range" id="::Fuel::range">
      <webidl>    readonly    attribute unsigned long?  range;</webidl>
      <Type type="unsigned long" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="instantConsumption" id="::Fuel::instantConsumption">
      <webidl>    readonly    attribute unsigned long?  instantConsumption;</webidl>
      <Type type="unsigned long" nullable="nullable"/>
    </Attribute>
    <Attribute name="averageConsumption" id="::Fuel::averageConsumption">
      <webidl>                attribute unsigned long?  averageConsumption;</webidl>
      <Type type="unsigned long" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="fuelConsumedSinceRestart" id="::Fuel::fuelConsumedSinceRestart">
      <webidl>    readonly    attribute unsigned long?  fuelConsumedSinceRestart;</webidl>
      <Type type="unsigned long" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="timeSinceRestart" id="::Fuel::timeSinceRestart">
      <webidl>    readonly    attribute unsigned long?  timeSinceRestart;</webidl>
      <Type type="unsigned long" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="EngineOil" id="::EngineOil">
    <webidl>[NoInterfaceObject]
interface EngineOil : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short level;
    readonly    attribute unsigned short lifeRemaining;
    readonly    attribute long           temperature;
    readonly    attribute unsigned short pressure;
    readonly    attribute boolean        change;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="level" id="::EngineOil::level">
      <webidl>    readonly    attribute unsigned short level;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="lifeRemaining" id="::EngineOil::lifeRemaining">
      <webidl>    readonly    attribute unsigned short lifeRemaining;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="temperature" id="::EngineOil::temperature">
      <webidl>    readonly    attribute long           temperature;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="pressure" id="::EngineOil::pressure">
      <webidl>    readonly    attribute unsigned short pressure;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="change" id="::EngineOil::change">
      <webidl>    readonly    attribute boolean        change;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="Acceleration" id="::Acceleration">
    <webidl>[NoInterfaceObject]
interface Acceleration : <ref>VehicleCommonDataType</ref> {
    readonly    attribute long x;
    readonly    attribute long y;
    readonly    attribute long z;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="x" id="::Acceleration::x">
      <webidl>    readonly    attribute long x;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="y" id="::Acceleration::y">
      <webidl>    readonly    attribute long y;</webidl>
      <Type type="long"/>
    </Attribute>
    <Attribute readonly="readonly" name="z" id="::Acceleration::z">
      <webidl>    readonly    attribute long z;</webidl>
      <Type type="long"/>
    </Attribute>
  </Interface>
  <Interface name="EngineCoolant" id="::EngineCoolant">
    <webidl>[NoInterfaceObject]
interface EngineCoolant : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet level;
    readonly    attribute short temperature;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="level" id="::EngineCoolant::level">
      <webidl>    readonly    attribute octet level;</webidl>
      <Type type="octet"/>
    </Attribute>
    <Attribute readonly="readonly" name="temperature" id="::EngineCoolant::temperature">
      <webidl>    readonly    attribute short temperature;</webidl>
      <Type type="short"/>
    </Attribute>
  </Interface>
  <Interface name="SteeringWheel" id="::SteeringWheel">
    <webidl>[NoInterfaceObject]
interface SteeringWheel : <ref>VehicleCommonDataType</ref> {
    readonly    attribute short angle;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="angle" id="::SteeringWheel::angle">
      <webidl>    readonly    attribute short angle;</webidl>
      <Type type="short"/>
    </Attribute>
  </Interface>
  <Interface name="WheelTick" id="::WheelTick">
    <webidl>[NoInterfaceObject]
interface WheelTick : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned long value;
    readonly    attribute <ref>Zone</ref>?         zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="value" id="::WheelTick::value">
      <webidl>    readonly    attribute unsigned long value;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::WheelTick::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?         zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="IgnitionTime" id="::IgnitionTime">
    <webidl>[NoInterfaceObject]
interface IgnitionTime : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>DOMTimeStamp</ref> ignitionOnTime;
    readonly    attribute <ref>DOMTimeStamp</ref> ignitionOffTime;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="ignitionOnTime" id="::IgnitionTime::ignitionOnTime">
      <webidl>    readonly    attribute <ref>DOMTimeStamp</ref> ignitionOnTime;</webidl>
      <Type name="DOMTimeStamp"/>
    </Attribute>
    <Attribute readonly="readonly" name="ignitionOffTime" id="::IgnitionTime::ignitionOffTime">
      <webidl>    readonly    attribute <ref>DOMTimeStamp</ref> ignitionOffTime;</webidl>
      <Type name="DOMTimeStamp"/>
    </Attribute>
  </Interface>
  <Interface name="YawRate" id="::YawRate">
    <webidl>[NoInterfaceObject]
interface YawRate : <ref>VehicleCommonDataType</ref> {
    readonly    attribute short value;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="value" id="::YawRate::value">
      <webidl>    readonly    attribute short value;</webidl>
      <Type type="short"/>
    </Attribute>
  </Interface>
  <Interface name="BrakeOperation" id="::BrakeOperation">
    <webidl>[NoInterfaceObject]
interface BrakeOperation : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean brakePedalDepressed;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="brakePedalDepressed" id="::BrakeOperation::brakePedalDepressed">
      <webidl>    readonly    attribute boolean brakePedalDepressed;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Enum name="Button" id="::Button">
    <webidl>enum Button {
    &quot;home&quot;,
    &quot;back&quot;,
    &quot;search&quot;,
    &quot;call&quot;,
    &quot;end_call&quot;,
    &quot;media_play&quot;,
    &quot;media_next&quot;,
    &quot;media_previous&quot;,
    &quot;media_pause&quot;,
    &quot;voice_recognize&quot;,
    &quot;enter&quot;,
    &quot;left&quot;,
    &quot;right&quot;,
    &quot;up&quot;,
    &quot;down&quot;
};</webidl>
    <EnumValue stringvalue="home">
      <webidl>    &quot;home</webidl>
    </EnumValue>
    <EnumValue stringvalue="back">
      <webidl>    &quot;back</webidl>
    </EnumValue>
    <EnumValue stringvalue="search">
      <webidl>    &quot;search</webidl>
    </EnumValue>
    <EnumValue stringvalue="call">
      <webidl>    &quot;call</webidl>
    </EnumValue>
    <EnumValue stringvalue="end_call">
      <webidl>    &quot;end_call</webidl>
    </EnumValue>
    <EnumValue stringvalue="media_play">
      <webidl>    &quot;media_play</webidl>
    </EnumValue>
    <EnumValue stringvalue="media_next">
      <webidl>    &quot;media_next</webidl>
    </EnumValue>
    <EnumValue stringvalue="media_previous">
      <webidl>    &quot;media_previous</webidl>
    </EnumValue>
    <EnumValue stringvalue="media_pause">
      <webidl>    &quot;media_pause</webidl>
    </EnumValue>
    <EnumValue stringvalue="voice_recognize">
      <webidl>    &quot;voice_recognize</webidl>
    </EnumValue>
    <EnumValue stringvalue="enter">
      <webidl>    &quot;enter</webidl>
    </EnumValue>
    <EnumValue stringvalue="left">
      <webidl>    &quot;left</webidl>
    </EnumValue>
    <EnumValue stringvalue="right">
      <webidl>    &quot;right</webidl>
    </EnumValue>
    <EnumValue stringvalue="up">
      <webidl>    &quot;up</webidl>
    </EnumValue>
    <EnumValue stringvalue="down">
      <webidl>    &quot;down</webidl>
    </EnumValue>
  </Enum>
  <Enum name="ButtonEventType" id="::ButtonEventType">
    <webidl>enum ButtonEventType {
    &quot;press&quot;,
    &quot;long_press&quot;,
    &quot;release&quot;
};</webidl>
    <EnumValue stringvalue="press">
      <webidl>    &quot;press</webidl>
    </EnumValue>
    <EnumValue stringvalue="long_press">
      <webidl>    &quot;long_press</webidl>
    </EnumValue>
    <EnumValue stringvalue="release">
      <webidl>    &quot;release</webidl>
    </EnumValue>
  </Enum>
  <Interface name="VehicleButton" id="::VehicleButton">
    <webidl>[NoInterfaceObject]
interface VehicleButton {
    readonly    attribute <ref>Button</ref>          button;
    readonly    attribute <ref>ButtonEventType</ref> state;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="button" id="::VehicleButton::button">
      <webidl>    readonly    attribute <ref>Button</ref>          button;</webidl>
      <Type name="Button"/>
    </Attribute>
    <Attribute readonly="readonly" name="state" id="::VehicleButton::state">
      <webidl>    readonly    attribute <ref>ButtonEventType</ref> state;</webidl>
      <Type name="ButtonEventType"/>
    </Attribute>
  </Interface>
  <Interface name="ButtonEvent" id="::ButtonEvent">
    <webidl>[NoInterfaceObject]
interface ButtonEvent : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>VehicleButton</ref>[] button;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="button" id="::ButtonEvent::button">
      <webidl>    readonly    attribute <ref>VehicleButton</ref>[] button;</webidl>
      <Type type="array">
        <Type name="VehicleButton"/>
      </Type>
    </Attribute>
  </Interface>
  <Interface name="DrivingMode" id="::DrivingMode">
    <webidl>[NoInterfaceObject]
interface DrivingMode : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean mode;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="mode" id="::DrivingMode::mode">
      <webidl>    readonly    attribute boolean mode;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="DrivingMode" id="::DrivingMode">
    <webidl>[NoInterfaceObject]
interface DrivingMode : <ref>VehicleCommonDataType</ref> {
        readonly attribute boolean mode;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="mode" id="::DrivingMode::mode">
      <webidl>        readonly attribute boolean mode;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="NightMode" id="::NightMode">
    <webidl>[NoInterfaceObject]
interface NightMode : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean mode;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="mode" id="::NightMode::mode">
      <webidl>    readonly    attribute boolean mode;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="Odometer" id="::Odometer">
    <webidl>[NoInterfaceObject]
interface Odometer : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned long? distanceSinceStart;
    readonly    attribute unsigned long  distanceTotal;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="distanceSinceStart" id="::Odometer::distanceSinceStart">
      <webidl>    readonly    attribute unsigned long? distanceSinceStart;</webidl>
      <Type type="unsigned long" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="distanceTotal" id="::Odometer::distanceTotal">
      <webidl>    readonly    attribute unsigned long  distanceTotal;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
  </Interface>
  <Interface name="TransmissionOil" id="::TransmissionOil">
    <webidl>[NoInterfaceObject]
interface TransmissionOil : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet?  wear;
    readonly    attribute short?  temperature;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="wear" id="::TransmissionOil::wear">
      <webidl>    readonly    attribute octet?  wear;</webidl>
      <Type type="octet" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="temperature" id="::TransmissionOil::temperature">
      <webidl>    readonly    attribute short?  temperature;</webidl>
      <Type type="short" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="TransmissionClutch" id="::TransmissionClutch">
    <webidl>[NoInterfaceObject]
interface TransmissionClutch : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet wear;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="wear" id="::TransmissionClutch::wear">
      <webidl>    readonly    attribute octet wear;</webidl>
      <Type type="octet"/>
    </Attribute>
  </Interface>
  <Interface name="BrakeMaintenance" id="::BrakeMaintenance">
    <webidl>[NoInterfaceObject]
interface BrakeMaintenance : <ref>VehicleCommonDataType</ref> {
    readonly    attribute octet?   fluidLevel;
    readonly    attribute boolean? fluidLevelLow;
    readonly    attribute octet?   padWear;
    readonly    attribute boolean? brakesWorn;
    readonly    attribute <ref>Zone</ref>?    zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="fluidLevel" id="::BrakeMaintenance::fluidLevel">
      <webidl>    readonly    attribute octet?   fluidLevel;</webidl>
      <Type type="octet" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="fluidLevelLow" id="::BrakeMaintenance::fluidLevelLow">
      <webidl>    readonly    attribute boolean? fluidLevelLow;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="padWear" id="::BrakeMaintenance::padWear">
      <webidl>    readonly    attribute octet?   padWear;</webidl>
      <Type type="octet" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="brakesWorn" id="::BrakeMaintenance::brakesWorn">
      <webidl>    readonly    attribute boolean? brakesWorn;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::BrakeMaintenance::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?    zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="WasherFluid" id="::WasherFluid">
    <webidl>[NoInterfaceObject]
interface WasherFluid : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short? level;
    readonly    attribute boolean?        levelLow;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="level" id="::WasherFluid::level">
      <webidl>    readonly    attribute unsigned short? level;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="levelLow" id="::WasherFluid::levelLow">
      <webidl>    readonly    attribute boolean?        levelLow;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="MalfunctionIndicator" id="::MalfunctionIndicator">
    <webidl>[NoInterfaceObject]
interface MalfunctionIndicator : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean on;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="on" id="::MalfunctionIndicator::on">
      <webidl>    readonly    attribute boolean on;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="BatteryStatus" id="::BatteryStatus">
    <webidl>[NoInterfaceObject]
interface BatteryStatus : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short? chargeLevel;
    readonly    attribute unsigned short? voltage;
    readonly    attribute unsigned short? current;
    readonly    attribute <ref>Zone</ref>?           zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="chargeLevel" id="::BatteryStatus::chargeLevel">
      <webidl>    readonly    attribute unsigned short? chargeLevel;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="voltage" id="::BatteryStatus::voltage">
      <webidl>    readonly    attribute unsigned short? voltage;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="current" id="::BatteryStatus::current">
      <webidl>    readonly    attribute unsigned short? current;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::BatteryStatus::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?           zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Tire" id="::Tire">
    <webidl>[NoInterfaceObject]
interface Tire : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean?        pressureLow;
    readonly    attribute unsigned short? pressure;
    readonly    attribute short?          temperature;
    readonly    attribute <ref>Zone</ref>?           zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="pressureLow" id="::Tire::pressureLow">
      <webidl>    readonly    attribute boolean?        pressureLow;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="pressure" id="::Tire::pressure">
      <webidl>    readonly    attribute unsigned short? pressure;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="temperature" id="::Tire::temperature">
      <webidl>    readonly    attribute short?          temperature;</webidl>
      <Type type="short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::Tire::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?           zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Diagnostic" id="::Diagnostic">
    <webidl>[NoInterfaceObject]
interface Diagnostic : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned long accumulatedEngineRuntime;
    readonly    attribute unsigned long distanceWithMILOn;
    readonly    attribute unsigned long distanceSinceCodeCleared;
    readonly    attribute unsigned long timeRunMILOn;
    readonly    attribute unsigned long timeTroubleCodeClear;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="accumulatedEngineRuntime" id="::Diagnostic::accumulatedEngineRuntime">
      <webidl>    readonly    attribute unsigned long accumulatedEngineRuntime;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="distanceWithMILOn" id="::Diagnostic::distanceWithMILOn">
      <webidl>    readonly    attribute unsigned long distanceWithMILOn;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="distanceSinceCodeCleared" id="::Diagnostic::distanceSinceCodeCleared">
      <webidl>    readonly    attribute unsigned long distanceSinceCodeCleared;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="timeRunMILOn" id="::Diagnostic::timeRunMILOn">
      <webidl>    readonly    attribute unsigned long timeRunMILOn;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
    <Attribute readonly="readonly" name="timeTroubleCodeClear" id="::Diagnostic::timeTroubleCodeClear">
      <webidl>    readonly    attribute unsigned long timeTroubleCodeClear;</webidl>
      <Type type="unsigned long"/>
    </Attribute>
  </Interface>
  <Interface name="LanguageConfiguration" id="::LanguageConfiguration">
    <webidl>[NoInterfaceObject]
interface LanguageConfiguration : <ref>VehicleCommonDataType</ref> {
                attribute DOMString? language;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="language" id="::LanguageConfiguration::language">
      <webidl>                attribute DOMString? language;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="UnitsOfMeasure" id="::UnitsOfMeasure">
    <webidl>[NoInterfaceObject]
interface UnitsOfMeasure : <ref>VehicleCommonDataType</ref> {
                attribute boolean?   isMKSSystem;
                attribute DOMString? unitsFuelVolume;
                attribute DOMString? unitsDistance;
                attribute DOMString? unitsSpeed;
                attribute DOMString? unitsFuelConsumption;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="isMKSSystem" id="::UnitsOfMeasure::isMKSSystem">
      <webidl>                attribute boolean?   isMKSSystem;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute name="unitsFuelVolume" id="::UnitsOfMeasure::unitsFuelVolume">
      <webidl>                attribute DOMString? unitsFuelVolume;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="unitsDistance" id="::UnitsOfMeasure::unitsDistance">
      <webidl>                attribute DOMString? unitsDistance;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="unitsSpeed" id="::UnitsOfMeasure::unitsSpeed">
      <webidl>                attribute DOMString? unitsSpeed;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute name="unitsFuelConsumption" id="::UnitsOfMeasure::unitsFuelConsumption">
      <webidl>                attribute DOMString? unitsFuelConsumption;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Mirror" id="::Mirror">
    <webidl>[NoInterfaceObject]
interface Mirror : <ref>VehicleCommonDataType</ref> {
                attribute unsigned short? mirrorTilt;
                attribute unsigned short? mirrorPan;
    readonly    attribute <ref>Zone</ref>?           zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="mirrorTilt" id="::Mirror::mirrorTilt">
      <webidl>                attribute unsigned short? mirrorTilt;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="mirrorPan" id="::Mirror::mirrorPan">
      <webidl>                attribute unsigned short? mirrorPan;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::Mirror::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?           zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="SeatAdjustment" id="::SeatAdjustment">
    <webidl>[NoInterfaceObject]
interface SeatAdjustment : <ref>VehicleCommonDataType</ref> {
                attribute unsigned short? reclineSeatBack;
                attribute unsigned short? seatSlide;
                attribute unsigned short? seatCushionHeight;
                attribute unsigned short? seatHeadrest;
                attribute unsigned short? seatBackCushion;
                attribute unsigned short? seatSideCushion;
    readonly    attribute <ref>Zone</ref>?           zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="reclineSeatBack" id="::SeatAdjustment::reclineSeatBack">
      <webidl>                attribute unsigned short? reclineSeatBack;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="seatSlide" id="::SeatAdjustment::seatSlide">
      <webidl>                attribute unsigned short? seatSlide;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="seatCushionHeight" id="::SeatAdjustment::seatCushionHeight">
      <webidl>                attribute unsigned short? seatCushionHeight;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="seatHeadrest" id="::SeatAdjustment::seatHeadrest">
      <webidl>                attribute unsigned short? seatHeadrest;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="seatBackCushion" id="::SeatAdjustment::seatBackCushion">
      <webidl>                attribute unsigned short? seatBackCushion;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="seatSideCushion" id="::SeatAdjustment::seatSideCushion">
      <webidl>                attribute unsigned short? seatSideCushion;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::SeatAdjustment::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?           zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="DriveModeEnum" id="::DriveModeEnum">
    <webidl>enum DriveModeEnum {
    &quot;comfort&quot;,
    &quot;auto&quot;,
    &quot;sport&quot;,
    &quot;eco&quot;,
    &quot;manual&quot;,
    &quot;winter&quot;
};</webidl>
    <EnumValue stringvalue="comfort">
      <webidl>    &quot;comfort</webidl>
    </EnumValue>
    <EnumValue stringvalue="auto">
      <webidl>    &quot;auto</webidl>
    </EnumValue>
    <EnumValue stringvalue="sport">
      <webidl>    &quot;sport</webidl>
    </EnumValue>
    <EnumValue stringvalue="eco">
      <webidl>    &quot;eco</webidl>
    </EnumValue>
    <EnumValue stringvalue="manual">
      <webidl>    &quot;manual</webidl>
    </EnumValue>
    <EnumValue stringvalue="winter">
      <webidl>    &quot;winter</webidl>
    </EnumValue>
  </Enum>
  <Interface name="DriveMode" id="::DriveMode">
    <webidl>[NoInterfaceObject]
interface DriveMode : <ref>VehicleCommonDataType</ref> {
                attribute <ref>DriveModeEnum</ref>? driveMode;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="driveMode" id="::DriveMode::driveMode">
      <webidl>                attribute <ref>DriveModeEnum</ref>? driveMode;</webidl>
      <Type name="DriveModeEnum" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="DashboardIllumination" id="::DashboardIllumination">
    <webidl>[NoInterfaceObject]
interface DashboardIllumination : <ref>VehicleCommonDataType</ref> {
                attribute DOMString? dashboardIllumination;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="dashboardIllumination" id="::DashboardIllumination::dashboardIllumination">
      <webidl>                attribute DOMString? dashboardIllumination;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="VehicleSound" id="::VehicleSound">
    <webidl>[NoInterfaceObject]
interface VehicleSound : <ref>VehicleCommonDataType</ref> {
                attribute boolean    activeNoiseControlMode;
                attribute DOMString? engineSoundEnhancementMode;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="activeNoiseControlMode" id="::VehicleSound::activeNoiseControlMode">
      <webidl>                attribute boolean    activeNoiseControlMode;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="engineSoundEnhancementMode" id="::VehicleSound::engineSoundEnhancementMode">
      <webidl>                attribute DOMString? engineSoundEnhancementMode;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="AntilockBrakingSystem" id="::AntilockBrakingSystem">
    <webidl>[NoInterfaceObject]
interface AntilockBrakingSystem : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean enabled;
    readonly    attribute boolean engaged;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="enabled" id="::AntilockBrakingSystem::enabled">
      <webidl>    readonly    attribute boolean enabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="engaged" id="::AntilockBrakingSystem::engaged">
      <webidl>    readonly    attribute boolean engaged;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="TractionControlSystem" id="::TractionControlSystem">
    <webidl>[NoInterfaceObject]
interface TractionControlSystem : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean enabled;
    readonly    attribute boolean engaged;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="enabled" id="::TractionControlSystem::enabled">
      <webidl>    readonly    attribute boolean enabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="engaged" id="::TractionControlSystem::engaged">
      <webidl>    readonly    attribute boolean engaged;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="ElectronicStabilityControl" id="::ElectronicStabilityControl">
    <webidl>[NoInterfaceObject]
interface ElectronicStabilityControl : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean enabled;
    readonly    attribute boolean engaged;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="enabled" id="::ElectronicStabilityControl::enabled">
      <webidl>    readonly    attribute boolean enabled;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="engaged" id="::ElectronicStabilityControl::engaged">
      <webidl>    readonly    attribute boolean engaged;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
  <Interface name="TopSpeedLimit" id="::TopSpeedLimit">
    <webidl>[NoInterfaceObject]
interface TopSpeedLimit : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short speed;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="speed" id="::TopSpeedLimit::speed">
      <webidl>    readonly    attribute unsigned short speed;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Interface name="AirbagStatus" id="::AirbagStatus">
    <webidl>[NoInterfaceObject]
interface AirbagStatus : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean activated;
    readonly    attribute boolean deployed;
    readonly    attribute <ref>Zone</ref>?   zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="activated" id="::AirbagStatus::activated">
      <webidl>    readonly    attribute boolean activated;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="deployed" id="::AirbagStatus::deployed">
      <webidl>    readonly    attribute boolean deployed;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::AirbagStatus::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?   zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="DoorOpenStatus" id="::DoorOpenStatus">
    <webidl>enum DoorOpenStatus {
    &quot;open&quot;,
    &quot;ajar&quot;,
    &quot;closed&quot;
};</webidl>
    <EnumValue stringvalue="open">
      <webidl>    &quot;open</webidl>
    </EnumValue>
    <EnumValue stringvalue="ajar">
      <webidl>    &quot;ajar</webidl>
    </EnumValue>
    <EnumValue stringvalue="closed">
      <webidl>    &quot;closed</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Door" id="::Door">
    <webidl>[NoInterfaceObject]
interface Door : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>DoorOpenStatus</ref> status;
                attribute boolean        lock;
    readonly    attribute <ref>Zone</ref>?          zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="status" id="::Door::status">
      <webidl>    readonly    attribute <ref>DoorOpenStatus</ref> status;</webidl>
      <Type name="DoorOpenStatus"/>
    </Attribute>
    <Attribute name="lock" id="::Door::lock">
      <webidl>                attribute boolean        lock;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::Door::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?          zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="ChildSafetyLock" id="::ChildSafetyLock">
    <webidl>[NoInterfaceObject]
interface ChildSafetyLock : <ref>VehicleCommonDataType</ref> {
                attribute boolean lock;
    readonly    attribute <ref>Zone</ref>?   zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="lock" id="::ChildSafetyLock::lock">
      <webidl>                attribute boolean lock;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::ChildSafetyLock::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?   zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="OccupantStatus" id="::OccupantStatus">
    <webidl>enum OccupantStatus {
    &quot;adult&quot;,
    &quot;child&quot;,
    &quot;vacant&quot;
};</webidl>
    <EnumValue stringvalue="adult">
      <webidl>    &quot;adult</webidl>
    </EnumValue>
    <EnumValue stringvalue="child">
      <webidl>    &quot;child</webidl>
    </EnumValue>
    <EnumValue stringvalue="vacant">
      <webidl>    &quot;vacant</webidl>
    </EnumValue>
  </Enum>
  <Enum name="IdentificationType" id="::IdentificationType">
    <webidl>enum IdentificationType {
    &quot;pin&quot;,
    &quot;keyfob&quot;,
    &quot;Bluetooth&quot;,
    &quot;NFC&quot;,
    &quot;fingerprint&quot;,
    &quot;camera&quot;,
    &quot;voice&quot;
};</webidl>
    <EnumValue stringvalue="pin">
      <webidl>    &quot;pin</webidl>
    </EnumValue>
    <EnumValue stringvalue="keyfob">
      <webidl>    &quot;keyfob</webidl>
    </EnumValue>
    <EnumValue stringvalue="Bluetooth">
      <webidl>    &quot;Bluetooth</webidl>
    </EnumValue>
    <EnumValue stringvalue="NFC">
      <webidl>    &quot;NFC</webidl>
    </EnumValue>
    <EnumValue stringvalue="fingerprint">
      <webidl>    &quot;fingerprint</webidl>
    </EnumValue>
    <EnumValue stringvalue="camera">
      <webidl>    &quot;camera</webidl>
    </EnumValue>
    <EnumValue stringvalue="voice">
      <webidl>    &quot;voice</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Seat" id="::Seat">
    <webidl>[NoInterfaceObject]
interface Seat : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>OccupantStatus</ref>     occupant;
    readonly    attribute boolean            seatbelt;
    readonly    attribute DOMString?         occupantName;
    readonly    attribute <ref>IdentificationType</ref> identificationType;
    readonly    attribute <ref>Zone</ref>?              zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="occupant" id="::Seat::occupant">
      <webidl>    readonly    attribute <ref>OccupantStatus</ref>     occupant;</webidl>
      <Type name="OccupantStatus"/>
    </Attribute>
    <Attribute readonly="readonly" name="seatbelt" id="::Seat::seatbelt">
      <webidl>    readonly    attribute boolean            seatbelt;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="occupantName" id="::Seat::occupantName">
      <webidl>    readonly    attribute DOMString?         occupantName;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="identificationType" id="::Seat::identificationType">
      <webidl>    readonly    attribute <ref>IdentificationType</ref> identificationType;</webidl>
      <Type name="IdentificationType"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::Seat::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?              zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Temperature" id="::Temperature">
    <webidl>[NoInterfaceObject]
interface Temperature : <ref>VehicleCommonDataType</ref> {
    readonly    attribute float interiorTemperature;
    readonly    attribute float exteriorTemperature;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="interiorTemperature" id="::Temperature::interiorTemperature">
      <webidl>    readonly    attribute float interiorTemperature;</webidl>
      <Type type="float"/>
    </Attribute>
    <Attribute readonly="readonly" name="exteriorTemperature" id="::Temperature::exteriorTemperature">
      <webidl>    readonly    attribute float exteriorTemperature;</webidl>
      <Type type="float"/>
    </Attribute>
  </Interface>
  <Interface name="RainSensor" id="::RainSensor">
    <webidl>[NoInterfaceObject]
interface RainSensor : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short rain;
    readonly    attribute <ref>Zone</ref>?          zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="rain" id="::RainSensor::rain">
      <webidl>    readonly    attribute unsigned short rain;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::RainSensor::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?          zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="WiperStatus" id="::WiperStatus">
    <webidl>[NoInterfaceObject]
interface WiperStatus : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short wiperSpeed;
    readonly    attribute <ref>Zone</ref>?          zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="wiperSpeed" id="::WiperStatus::wiperSpeed">
      <webidl>    readonly    attribute unsigned short wiperSpeed;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::WiperStatus::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?          zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="WiperControl" id="::WiperControl">
    <webidl>enum WiperControl {
    &quot;off&quot;,
    &quot;once&quot;,
    &quot;slowest&quot;,
    &quot;slow&quot;,
    &quot;middle&quot;,
    &quot;fast&quot;,
    &quot;fastest&quot;,
    &quot;auto&quot;
};</webidl>
    <EnumValue stringvalue="off">
      <webidl>    &quot;off</webidl>
    </EnumValue>
    <EnumValue stringvalue="once">
      <webidl>    &quot;once</webidl>
    </EnumValue>
    <EnumValue stringvalue="slowest">
      <webidl>    &quot;slowest</webidl>
    </EnumValue>
    <EnumValue stringvalue="slow">
      <webidl>    &quot;slow</webidl>
    </EnumValue>
    <EnumValue stringvalue="middle">
      <webidl>    &quot;middle</webidl>
    </EnumValue>
    <EnumValue stringvalue="fast">
      <webidl>    &quot;fast</webidl>
    </EnumValue>
    <EnumValue stringvalue="fastest">
      <webidl>    &quot;fastest</webidl>
    </EnumValue>
    <EnumValue stringvalue="auto">
      <webidl>    &quot;auto</webidl>
    </EnumValue>
  </Enum>
  <Interface name="WiperSetting" id="::WiperSetting">
    <webidl>[NoInterfaceObject]
interface WiperSetting : <ref>VehicleCommonDataType</ref> {
                attribute <ref>WiperControl</ref> wiperControl;
    readonly    attribute <ref>Zone</ref>?        zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="wiperControl" id="::WiperSetting::wiperControl">
      <webidl>                attribute <ref>WiperControl</ref> wiperControl;</webidl>
      <Type name="WiperControl"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::WiperSetting::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?        zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Defrost" id="::Defrost">
    <webidl>[NoInterfaceObject]
interface Defrost : <ref>VehicleCommonDataType</ref> {
                attribute boolean? defrostWindow;
                attribute boolean? defrostMirrors;
    readonly    attribute <ref>Zone</ref>?    zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="defrostWindow" id="::Defrost::defrostWindow">
      <webidl>                attribute boolean? defrostWindow;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute name="defrostMirrors" id="::Defrost::defrostMirrors">
      <webidl>                attribute boolean? defrostMirrors;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::Defrost::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?    zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="Sunroof" id="::Sunroof">
    <webidl>[NoInterfaceObject]
interface Sunroof : <ref>VehicleCommonDataType</ref> {
                attribute unsigned short openness;
                attribute unsigned short tilt;
    readonly    attribute <ref>Zone</ref>?          zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="openness" id="::Sunroof::openness">
      <webidl>                attribute unsigned short openness;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="tilt" id="::Sunroof::tilt">
      <webidl>                attribute unsigned short tilt;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::Sunroof::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?          zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="ConvertibleRoofStatus" id="::ConvertibleRoofStatus">
    <webidl>enum ConvertibleRoofStatus {
    &quot;closed&quot;,
    &quot;closing&quot;,
    &quot;opening&quot;,
    &quot;opened&quot;
};</webidl>
    <EnumValue stringvalue="closed">
      <webidl>    &quot;closed</webidl>
    </EnumValue>
    <EnumValue stringvalue="closing">
      <webidl>    &quot;closing</webidl>
    </EnumValue>
    <EnumValue stringvalue="opening">
      <webidl>    &quot;opening</webidl>
    </EnumValue>
    <EnumValue stringvalue="opened">
      <webidl>    &quot;opened</webidl>
    </EnumValue>
  </Enum>
  <Interface name="ConvertibleRoof" id="::ConvertibleRoof">
    <webidl>[NoInterfaceObject]
interface ConvertibleRoof : <ref>VehicleCommonDataType</ref> {
                attribute <ref>ConvertibleRoofStatus</ref> status;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="status" id="::ConvertibleRoof::status">
      <webidl>                attribute <ref>ConvertibleRoofStatus</ref> status;</webidl>
      <Type name="ConvertibleRoofStatus"/>
    </Attribute>
  </Interface>
  <Interface name="SideWindow" id="::SideWindow">
    <webidl>[NoInterfaceObject]
interface SideWindow : <ref>VehicleCommonDataType</ref> {
                attribute boolean?        lock;
                attribute unsigned short? openness;
    readonly    attribute <ref>Zone</ref>?           zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="lock" id="::SideWindow::lock">
      <webidl>                attribute boolean?        lock;</webidl>
      <Type type="boolean" nullable="nullable"/>
    </Attribute>
    <Attribute name="openness" id="::SideWindow::openness">
      <webidl>                attribute unsigned short? openness;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::SideWindow::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?           zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Enum name="AirflowDirection" id="::AirflowDirection">
    <webidl>enum AirflowDirection {
    &quot;frontpanel&quot;,
    &quot;floorduct&quot;,
    &quot;bilevel&quot;,
    &quot;defrostfloor&quot;
};</webidl>
    <EnumValue stringvalue="frontpanel">
      <webidl>    &quot;frontpanel</webidl>
    </EnumValue>
    <EnumValue stringvalue="floorduct">
      <webidl>    &quot;floorduct</webidl>
    </EnumValue>
    <EnumValue stringvalue="bilevel">
      <webidl>    &quot;bilevel</webidl>
    </EnumValue>
    <EnumValue stringvalue="defrostfloor">
      <webidl>    &quot;defrostfloor</webidl>
    </EnumValue>
  </Enum>
  <Interface name="ClimateControl" id="::ClimateControl">
    <webidl>[NoInterfaceObject]
interface ClimateControl : <ref>VehicleCommonDataType</ref> {
                attribute <ref>AirflowDirection</ref>  airflowDirection;
                attribute unsigned short    fanSpeedLevel;
                attribute short?            targetTemperature;
                attribute boolean           airConditioning;
                attribute boolean           heater;
                attribute unsigned short?   seatHeater;
                attribute unsigned short?   seatCooler;
                attribute boolean           airRecirculation;
                attribute unsigned short?   steeringWheelHeater;
    readonly    attribute <ref>Zone</ref>?             zone;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="airflowDirection" id="::ClimateControl::airflowDirection">
      <webidl>                attribute <ref>AirflowDirection</ref>  airflowDirection;</webidl>
      <Type name="AirflowDirection"/>
    </Attribute>
    <Attribute name="fanSpeedLevel" id="::ClimateControl::fanSpeedLevel">
      <webidl>                attribute unsigned short    fanSpeedLevel;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
    <Attribute name="targetTemperature" id="::ClimateControl::targetTemperature">
      <webidl>                attribute short?            targetTemperature;</webidl>
      <Type type="short" nullable="nullable"/>
    </Attribute>
    <Attribute name="airConditioning" id="::ClimateControl::airConditioning">
      <webidl>                attribute boolean           airConditioning;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="heater" id="::ClimateControl::heater">
      <webidl>                attribute boolean           heater;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="seatHeater" id="::ClimateControl::seatHeater">
      <webidl>                attribute unsigned short?   seatHeater;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="seatCooler" id="::ClimateControl::seatCooler">
      <webidl>                attribute unsigned short?   seatCooler;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute name="airRecirculation" id="::ClimateControl::airRecirculation">
      <webidl>                attribute boolean           airRecirculation;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="steeringWheelHeater" id="::ClimateControl::steeringWheelHeater">
      <webidl>                attribute unsigned short?   steeringWheelHeater;</webidl>
      <Type type="unsigned short" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="zone" id="::ClimateControl::zone">
      <webidl>    readonly    attribute <ref>Zone</ref>?             zone;</webidl>
      <Type name="Zone" nullable="nullable"/>
    </Attribute>
  </Interface>
  <Interface name="AtmosphericPressure" id="::AtmosphericPressure">
    <webidl>[NoInterfaceObject]
interface AtmosphericPressure : <ref>VehicleCommonDataType</ref> {
    readonly    attribute unsigned short pressure;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="pressure" id="::AtmosphericPressure::pressure">
      <webidl>    readonly    attribute unsigned short pressure;</webidl>
      <Type type="unsigned short"/>
    </Attribute>
  </Interface>
  <Enum name="LaneDepartureStatus" id="::LaneDepartureStatus">
    <webidl>enum LaneDepartureStatus {
    &quot;off&quot;,
    &quot;pause&quot;,
    &quot;running&quot;
};</webidl>
    <EnumValue stringvalue="off">
      <webidl>    &quot;off</webidl>
    </EnumValue>
    <EnumValue stringvalue="pause">
      <webidl>    &quot;pause</webidl>
    </EnumValue>
    <EnumValue stringvalue="running">
      <webidl>    &quot;running</webidl>
    </EnumValue>
  </Enum>
  <Interface name="LaneDepartureDetection" id="::LaneDepartureDetection">
    <webidl>[NoInterfaceObject]
interface LaneDepartureDetection : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>LaneDepartureStatus</ref> status;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="status" id="::LaneDepartureDetection::status">
      <webidl>    readonly    attribute <ref>LaneDepartureStatus</ref> status;</webidl>
      <Type name="LaneDepartureStatus"/>
    </Attribute>
  </Interface>
  <Enum name="AlarmStatus" id="::AlarmStatus">
    <webidl>enum AlarmStatus {
    &quot;disarmed&quot;,
    &quot;preArmed&quot;,
    &quot;armed&quot;,
    &quot;alarmed&quot;
};</webidl>
    <EnumValue stringvalue="disarmed">
      <webidl>    &quot;disarmed</webidl>
    </EnumValue>
    <EnumValue stringvalue="preArmed">
      <webidl>    &quot;preArmed</webidl>
    </EnumValue>
    <EnumValue stringvalue="armed">
      <webidl>    &quot;armed</webidl>
    </EnumValue>
    <EnumValue stringvalue="alarmed">
      <webidl>    &quot;alarmed</webidl>
    </EnumValue>
  </Enum>
  <Interface name="Alarm" id="::Alarm">
    <webidl>[NoInterfaceObject]
interface Alarm : <ref>VehicleCommonDataType</ref> {
                attribute <ref>AlarmStatus</ref> status;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute name="status" id="::Alarm::status">
      <webidl>                attribute <ref>AlarmStatus</ref> status;</webidl>
      <Type name="AlarmStatus"/>
    </Attribute>
  </Interface>
  <Enum name="ParkingBrakeStatus" id="::ParkingBrakeStatus">
    <webidl>enum ParkingBrakeStatus {
    &quot;inactive&quot;,
    &quot;active&quot;,
    &quot;error&quot;
};</webidl>
    <EnumValue stringvalue="inactive">
      <webidl>    &quot;inactive</webidl>
    </EnumValue>
    <EnumValue stringvalue="active">
      <webidl>    &quot;active</webidl>
    </EnumValue>
    <EnumValue stringvalue="error">
      <webidl>    &quot;error</webidl>
    </EnumValue>
  </Enum>
  <Interface name="ParkingBrake" id="::ParkingBrake">
    <webidl>[NoInterfaceObject]
interface ParkingBrake : <ref>VehicleCommonDataType</ref> {
    readonly    attribute <ref>ParkingBrakeStatus</ref> status;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="status" id="::ParkingBrake::status">
      <webidl>    readonly    attribute <ref>ParkingBrakeStatus</ref> status;</webidl>
      <Type name="ParkingBrakeStatus"/>
    </Attribute>
  </Interface>
  <Interface name="ParkingLights" id="::ParkingLights">
    <webidl>[NoInterfaceObject]
interface ParkingLights : <ref>VehicleCommonDataType</ref> {
    readonly    attribute boolean status;
                attribute boolean setting;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="VehicleCommonDataType"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="status" id="::ParkingLights::status">
      <webidl>    readonly    attribute boolean status;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute name="setting" id="::ParkingLights::setting">
      <webidl>                attribute boolean setting;</webidl>
      <Type type="boolean"/>
    </Attribute>
  </Interface>
</Module>
<Module name="MediaServer" id="::MediaServer">
  <webidl>  module MediaServer {
[NoInterfaceObject]
interface MediaContainer : <ref>MediaObject</ref> {
    readonly    attribute unsigned long? childCount;
    readonly    attribute boolean        canCreateContainer;
    readonly    attribute boolean        canDelete;
    readonly    attribute boolean        canUpload;
    readonly    attribute boolean        canRename;
    <ref>Promise</ref> upload (DOMString title, DOMString path);
    <ref>Promise</ref> createFolder (DOMString title);
};

<ref>Navigator</ref> implements <ref>MediaServerManagerObject</ref>;

[NoInterfaceObject]
interface Navigator {
    readonly     attribute <ref>MediaServerManager</ref> mediaServer;
};

[NoInterfaceObject]
interface MediaServerManager  {
    void scanNetwork();
                attribute <ref>EventHandler</ref> onserverfound;
                attribute <ref>EventHandler</ref> onserverlost;
};

interface MediaServerEvent : <ref>Event</ref> {
    readonly    attribute <ref>MediaServer</ref> server;
};

interface MediaServerIdEvent : <ref>Event</ref> {
    readonly    attribute DOMString id;
};

[NoInterfaceObject]
interface MediaServer {
    readonly    attribute DOMString       id;
    readonly    attribute DOMString       friendlyName;
    readonly    attribute DOMString?      manufacturer;
    readonly    attribute DOMString?      manufacturerURL;
    readonly    attribute DOMString?      modelDescription;
    readonly    attribute DOMString?      modelName;
    readonly    attribute DOMString?      modelNumber;
    readonly    attribute DOMString?      serialNumber;
    readonly    attribute DOMString?      UDN;
    readonly    attribute DOMString?      presentationURL;
    readonly    attribute DOMString?      iconURL;
    readonly    attribute DOMString?      deviceType;
    readonly    attribute <ref>MediaContainer</ref>? root;
    readonly    attribute boolean         canCreateContainer;
    readonly    attribute boolean         canUpload;
    readonly    attribute DOMString[]     searchAttrs;
    readonly    attribute DOMString[]     sortAttrs;
    <ref>Promise</ref> upload (DOMString path);
    <ref>Promise</ref> browse(DOMString containerId, DOMString? sortMode, unsigned long? count, unsigned long? offset);
    <ref>Promise</ref> find(DOMString containerId, DOMString searchFilter, DOMString? sortMode, unsigned long? count, unsigned long? offset);
    <ref>Promise</ref> cancel ();
                attribute <ref>EventHandler</ref>    oncontainerchanged;

};

interface MediaContainerIdEvent : <ref>Event</ref> {
    readonly    attribute DOMString id;
};</webidl>
  <Interface name="MediaContainer" id="::MediaContainer">
    <webidl>[NoInterfaceObject]
interface MediaContainer : <ref>MediaObject</ref> {
    readonly    attribute unsigned long? childCount;
    readonly    attribute boolean        canCreateContainer;
    readonly    attribute boolean        canDelete;
    readonly    attribute boolean        canUpload;
    readonly    attribute boolean        canRename;
    <ref>Promise</ref> upload (DOMString title, DOMString path);
    <ref>Promise</ref> createFolder (DOMString title);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <InterfaceInheritance>
      <Name name="MediaObject"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="childCount" id="::MediaContainer::childCount">
      <webidl>    readonly    attribute unsigned long? childCount;</webidl>
      <Type type="unsigned long" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="canCreateContainer" id="::MediaContainer::canCreateContainer">
      <webidl>    readonly    attribute boolean        canCreateContainer;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="canDelete" id="::MediaContainer::canDelete">
      <webidl>    readonly    attribute boolean        canDelete;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="canUpload" id="::MediaContainer::canUpload">
      <webidl>    readonly    attribute boolean        canUpload;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="canRename" id="::MediaContainer::canRename">
      <webidl>    readonly    attribute boolean        canRename;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Operation name="upload" id="::MediaContainer::upload">
      <webidl>    <ref>Promise</ref> upload (DOMString title, DOMString path);</webidl>
      <Type name="Promise"/>
      <ArgumentList>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="path">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="createFolder" id="::MediaContainer::createFolder">
      <webidl>    <ref>Promise</ref> createFolder (DOMString title);</webidl>
      <Type name="Promise"/>
      <ArgumentList>
        <Argument name="title">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
  <Implements name1="Navigator" name2="MediaServerManagerObject">
    <webidl><ref>Navigator</ref> implements <ref>MediaServerManagerObject</ref>;</webidl>
  </Implements>
  <Interface name="Navigator" id="::Navigator">
    <webidl>[NoInterfaceObject]
interface Navigator {
    readonly     attribute <ref>MediaServerManager</ref> mediaServer;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="mediaServer" id="::Navigator::mediaServer">
      <webidl>    readonly     attribute <ref>MediaServerManager</ref> mediaServer;</webidl>
      <Type name="MediaServerManager"/>
    </Attribute>
  </Interface>
  <Interface name="MediaServerManager" id="::MediaServerManager">
    <webidl>[NoInterfaceObject]
interface MediaServerManager  {
    void scanNetwork();
                attribute <ref>EventHandler</ref> onserverfound;
                attribute <ref>EventHandler</ref> onserverlost;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="scanNetwork" id="::MediaServerManager::scanNetwork">
      <webidl>    void scanNetwork();</webidl>
      <Type type="void"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="onserverfound" id="::MediaServerManager::onserverfound">
      <webidl>                attribute <ref>EventHandler</ref> onserverfound;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
    <Attribute name="onserverlost" id="::MediaServerManager::onserverlost">
      <webidl>                attribute <ref>EventHandler</ref> onserverlost;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="MediaServerEvent" id="::MediaServerEvent">
    <webidl>interface MediaServerEvent : <ref>Event</ref> {
    readonly    attribute <ref>MediaServer</ref> server;
};</webidl>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="server" id="::MediaServerEvent::server">
      <webidl>    readonly    attribute <ref>MediaServer</ref> server;</webidl>
      <Type name="MediaServer"/>
    </Attribute>
  </Interface>
  <Interface name="MediaServerIdEvent" id="::MediaServerIdEvent">
    <webidl>interface MediaServerIdEvent : <ref>Event</ref> {
    readonly    attribute DOMString id;
};</webidl>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="id" id="::MediaServerIdEvent::id">
      <webidl>    readonly    attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
  <Interface name="MediaServer" id="::MediaServer">
    <webidl>[NoInterfaceObject]
interface MediaServer {
    readonly    attribute DOMString       id;
    readonly    attribute DOMString       friendlyName;
    readonly    attribute DOMString?      manufacturer;
    readonly    attribute DOMString?      manufacturerURL;
    readonly    attribute DOMString?      modelDescription;
    readonly    attribute DOMString?      modelName;
    readonly    attribute DOMString?      modelNumber;
    readonly    attribute DOMString?      serialNumber;
    readonly    attribute DOMString?      UDN;
    readonly    attribute DOMString?      presentationURL;
    readonly    attribute DOMString?      iconURL;
    readonly    attribute DOMString?      deviceType;
    readonly    attribute <ref>MediaContainer</ref>? root;
    readonly    attribute boolean         canCreateContainer;
    readonly    attribute boolean         canUpload;
    readonly    attribute DOMString[]     searchAttrs;
    readonly    attribute DOMString[]     sortAttrs;
    <ref>Promise</ref> upload (DOMString path);
    <ref>Promise</ref> browse(DOMString containerId, DOMString? sortMode, unsigned long? count, unsigned long? offset);
    <ref>Promise</ref> find(DOMString containerId, DOMString searchFilter, DOMString? sortMode, unsigned long? count, unsigned long? offset);
    <ref>Promise</ref> cancel ();
                attribute <ref>EventHandler</ref>    oncontainerchanged;

};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="id" id="::MediaServer::id">
      <webidl>    readonly    attribute DOMString       id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="friendlyName" id="::MediaServer::friendlyName">
      <webidl>    readonly    attribute DOMString       friendlyName;</webidl>
      <Type type="DOMString"/>
    </Attribute>
    <Attribute readonly="readonly" name="manufacturer" id="::MediaServer::manufacturer">
      <webidl>    readonly    attribute DOMString?      manufacturer;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="manufacturerURL" id="::MediaServer::manufacturerURL">
      <webidl>    readonly    attribute DOMString?      manufacturerURL;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="modelDescription" id="::MediaServer::modelDescription">
      <webidl>    readonly    attribute DOMString?      modelDescription;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="modelName" id="::MediaServer::modelName">
      <webidl>    readonly    attribute DOMString?      modelName;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="modelNumber" id="::MediaServer::modelNumber">
      <webidl>    readonly    attribute DOMString?      modelNumber;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="serialNumber" id="::MediaServer::serialNumber">
      <webidl>    readonly    attribute DOMString?      serialNumber;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="UDN" id="::MediaServer::UDN">
      <webidl>    readonly    attribute DOMString?      UDN;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="presentationURL" id="::MediaServer::presentationURL">
      <webidl>    readonly    attribute DOMString?      presentationURL;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="iconURL" id="::MediaServer::iconURL">
      <webidl>    readonly    attribute DOMString?      iconURL;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="deviceType" id="::MediaServer::deviceType">
      <webidl>    readonly    attribute DOMString?      deviceType;</webidl>
      <Type type="DOMString" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="root" id="::MediaServer::root">
      <webidl>    readonly    attribute <ref>MediaContainer</ref>? root;</webidl>
      <Type name="MediaContainer" nullable="nullable"/>
    </Attribute>
    <Attribute readonly="readonly" name="canCreateContainer" id="::MediaServer::canCreateContainer">
      <webidl>    readonly    attribute boolean         canCreateContainer;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="canUpload" id="::MediaServer::canUpload">
      <webidl>    readonly    attribute boolean         canUpload;</webidl>
      <Type type="boolean"/>
    </Attribute>
    <Attribute readonly="readonly" name="searchAttrs" id="::MediaServer::searchAttrs">
      <webidl>    readonly    attribute DOMString[]     searchAttrs;</webidl>
      <Type type="array">
        <Type type="DOMString"/>
      </Type>
    </Attribute>
    <Attribute readonly="readonly" name="sortAttrs" id="::MediaServer::sortAttrs">
      <webidl>    readonly    attribute DOMString[]     sortAttrs;</webidl>
      <Type type="array">
        <Type type="DOMString"/>
      </Type>
    </Attribute>
    <Operation name="upload" id="::MediaServer::upload">
      <webidl>    <ref>Promise</ref> upload (DOMString path);</webidl>
      <Type name="Promise"/>
      <ArgumentList>
        <Argument name="path">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="browse" id="::MediaServer::browse">
      <webidl>    <ref>Promise</ref> browse(DOMString containerId, DOMString? sortMode, unsigned long? count, unsigned long? offset);</webidl>
      <Type name="Promise"/>
      <ArgumentList>
        <Argument name="containerId">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="sortMode">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="count">
          <Type type="unsigned long" nullable="nullable"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="find" id="::MediaServer::find">
      <webidl>    <ref>Promise</ref> find(DOMString containerId, DOMString searchFilter, DOMString? sortMode, unsigned long? count, unsigned long? offset);</webidl>
      <Type name="Promise"/>
      <ArgumentList>
        <Argument name="containerId">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="searchFilter">
          <Type type="DOMString"/>
        </Argument>
        <Argument name="sortMode">
          <Type type="DOMString" nullable="nullable"/>
        </Argument>
        <Argument name="count">
          <Type type="unsigned long" nullable="nullable"/>
        </Argument>
        <Argument name="offset">
          <Type type="unsigned long" nullable="nullable"/>
        </Argument>
      </ArgumentList>
    </Operation>
    <Operation name="cancel" id="::MediaServer::cancel">
      <webidl>    <ref>Promise</ref> cancel ();</webidl>
      <Type name="Promise"/>
      <ArgumentList/>
    </Operation>
    <Attribute name="oncontainerchanged" id="::MediaServer::oncontainerchanged">
      <webidl>                attribute <ref>EventHandler</ref>    oncontainerchanged;</webidl>
      <Type name="EventHandler"/>
    </Attribute>
  </Interface>
  <Interface name="MediaContainerIdEvent" id="::MediaContainerIdEvent">
    <webidl>interface MediaContainerIdEvent : <ref>Event</ref> {
    readonly    attribute DOMString id;
};</webidl>
    <InterfaceInheritance>
      <Name name="Event"/>
    </InterfaceInheritance>
    <Attribute readonly="readonly" name="id" id="::MediaContainerIdEvent::id">
      <webidl>    readonly    attribute DOMString id;</webidl>
      <Type type="DOMString"/>
    </Attribute>
  </Interface>
</Module>
<Module name="Speech" id="::Speech">
<webidl>  module Speech {
[NoInterfaceObject] interface SpeechManagerObject {
        readonly attribute <ref>SpeechManager</ref> speech;
};

<ref>Tizen</ref> implements <ref>SpeechManagerObject</ref>;

[NoInterfaceObject] interface SpeechManager {
    void vocalizeString(DOMString speakString);
};</webidl>
  <Interface name="SpeechManagerObject" id="::SpeechManagerObject">
    <webidl>[NoInterfaceObject] interface SpeechManagerObject {
        readonly attribute <ref>SpeechManager</ref> speech;
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Attribute readonly="readonly" name="speech" id="::SpeechManagerObject::speech">
      <webidl>        readonly attribute <ref>SpeechManager</ref> speech;</webidl>
      <Type name="SpeechManager"/>
    </Attribute>
  </Interface>
  <Implements name1="Tizen" name2="SpeechManagerObject">
    <webidl><ref>Tizen</ref> implements <ref>SpeechManagerObject</ref>;</webidl>
  </Implements>
  <Interface name="SpeechManager" id="::SpeechManager">
    <webidl>[NoInterfaceObject] interface SpeechManager {
    void vocalizeString(DOMString speakString);
};</webidl>
    <ExtendedAttributeList>
      <ExtendedAttribute name="NoInterfaceObject">
        <webidl>NoInterfaceObject</webidl>
      </ExtendedAttribute>
    </ExtendedAttributeList>
    <Operation name="vocalizeString" id="::SpeechManager::vocalizeString">
      <webidl>    void vocalizeString(DOMString speakString);</webidl>
      <Type type="void"/>
      <ArgumentList>
        <Argument name="speakString">
          <Type type="DOMString"/>
        </Argument>
      </ArgumentList>
    </Operation>
  </Interface>
</Module>
  <Module name="Alarm" id="::Alarm">
    <webidl>module Alarm {&#13;
&#13;
    typedef DOMString AlarmId;&#13;
&#13;
&#13;
&#13;
    [NoInterfaceObject] interface AlarmManagerObject {&#13;
        readonly attribute <ref>AlarmManager</ref> alarm;&#13;
    };&#13;
    <ref>Tizen</ref> implements <ref>AlarmManagerObject</ref>;&#13;
&#13;
&#13;
    [NoInterfaceObject] interface AlarmManager {&#13;
&#13;
        const long PERIOD_MINUTE = 60;&#13;
        &#13;
&#13;
        const long PERIOD_HOUR = 3600;&#13;
         &#13;
&#13;
        const long PERIOD_DAY = 86400;&#13;
        &#13;
&#13;
        const long PERIOD_WEEK = 604800;&#13;
&#13;
&#13;
        void add(<ref>Alarm</ref> alarm, <ref>ApplicationId</ref> applicationId, optional <ref>ApplicationControl</ref>? appControl) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        void remove(<ref>AlarmId</ref> id) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        void removeAll() raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        <ref>Alarm</ref> get(<ref>AlarmId</ref> id) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        <ref>Alarm</ref>[] getAll() raises(<ref>WebAPIException</ref>);&#13;
    };&#13;
&#13;
&#13;
    [NoInterfaceObject] interface Alarm {&#13;
&#13;
        readonly attribute <ref>AlarmId</ref>? id;&#13;
    };&#13;
 &#13;
    [Constructor(long delay, optional long? period)]&#13;
&#13;
    interface AlarmRelative : <ref>Alarm</ref> {&#13;
&#13;
        readonly attribute long delay;&#13;
        &#13;
&#13;
        readonly attribute long? period;&#13;
&#13;
&#13;
        long? getRemainingSeconds() raises(<ref>WebAPIException</ref>);&#13;
    };&#13;
&#13;
    [Constructor(Date date),&#13;
&#13;
     Constructor(Date date, <ref>ByDayValue</ref>[] daysOfTheWeek),&#13;
&#13;
     Constructor(Date date, long period)]&#13;
&#13;
    interface AlarmAbsolute : <ref>Alarm</ref> {&#13;
&#13;
        readonly attribute Date date;&#13;
&#13;
&#13;
        readonly attribute long? period;&#13;
&#13;
&#13;
        readonly attribute <ref>ByDayValue</ref>[] daysOfTheWeek;&#13;
&#13;
&#13;
        Date? getNextScheduledDate() raises(<ref>WebAPIException</ref>);&#13;
    };&#13;
};</webidl>
    <descriptive>
        <brief>
 This API provides the functionality for scheduling the system alarm.
It allows you to run other applications and have them perform operations at the specific time.
You can schedule an alarm to go off once or to repeat at specific intervals.
        </brief>
       <description>
        <p>
Each application has its own individual alarm storage, that is, applications cannot view or edit alarms set by other applications.
        </p>
        <p>
Once an alarm goes off, it will be removed from the alarm storage automatically.
<em>AlarmManager</em> provides methods to manage alarms such as adding and removing.
For more information on the Alarm features, see <a href="../../org.tizen.web.appprogramming/html/guide/app_guide/alarm.htm">Alarm Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
    </descriptive>
    <Typedef name="AlarmId" id="::Alarm::AlarmId">
      <webidl>    typedef DOMString AlarmId;</webidl>
      <descriptive>
          <brief>
 An alarm identifier.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Interface name="AlarmManagerObject" id="::Alarm::AlarmManagerObject">
      <webidl>    [NoInterfaceObject] interface AlarmManagerObject {&#13;
        readonly attribute <ref>AlarmManager</ref> alarm;&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen </em>object from the Tizen Platform.
There will be a <em>tizen.alarm </em>object that allows access to the functionality of the Alarm API.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="alarm" id="::Alarm::AlarmManagerObject::alarm">
        <webidl>        readonly attribute <ref>AlarmManager</ref> alarm;</webidl>
        <Type name="AlarmManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="AlarmManagerObject">
      <webidl>    <ref>Tizen</ref> implements <ref>AlarmManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="AlarmManager" id="::Alarm::AlarmManager">
      <webidl>    [NoInterfaceObject] interface AlarmManager {&#13;
&#13;
        const long PERIOD_MINUTE = 60;&#13;
        &#13;
&#13;
        const long PERIOD_HOUR = 3600;&#13;
         &#13;
&#13;
        const long PERIOD_DAY = 86400;&#13;
        &#13;
&#13;
        const long PERIOD_WEEK = 604800;&#13;
&#13;
&#13;
        void add(<ref>Alarm</ref> alarm, <ref>ApplicationId</ref> applicationId, optional <ref>ApplicationControl</ref>? appControl) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        void remove(<ref>AlarmId</ref> id) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        void removeAll() raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        <ref>Alarm</ref> get(<ref>AlarmId</ref> id) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        <ref>Alarm</ref>[] getAll() raises(<ref>WebAPIException</ref>);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface provides methods to manage alarms.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Const name="PERIOD_MINUTE" value="60" id="::Alarm::AlarmManager::PERIOD_MINUTE">
        <webidl>        const long PERIOD_MINUTE = 60;</webidl>
        <descriptive>
            <brief>
 The period of a minute.
It defines the number of seconds per minute.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Const>
      <Const name="PERIOD_HOUR" value="3600" id="::Alarm::AlarmManager::PERIOD_HOUR">
        <webidl>        const long PERIOD_HOUR = 3600;</webidl>
        <descriptive>
            <brief>
 The period of an hour.
It defines the number of seconds per hour.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Const>
      <Const name="PERIOD_DAY" value="86400" id="::Alarm::AlarmManager::PERIOD_DAY">
        <webidl>        const long PERIOD_DAY = 86400;</webidl>
        <descriptive>
            <brief>
 The period of a day.
It defines the number of seconds per day.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Const>
      <Const name="PERIOD_WEEK" value="604800" id="::Alarm::AlarmManager::PERIOD_WEEK">
        <webidl>        const long PERIOD_WEEK = 604800;</webidl>
        <descriptive>
            <brief>
 The period of a week.
It defines the number of seconds in a week.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Const>
      <Operation name="add" id="::Alarm::AlarmManager::add">
        <webidl>        void add(<ref>Alarm</ref> alarm, <ref>ApplicationId</ref> applicationId, optional <ref>ApplicationControl</ref>? appControl) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds an alarm to the storage.
            </brief>
           <description>
            <p>
Set an alarm with the application ID to be run. You should definitely provide the application ID to run
and the <a href=" ../../org.tizen.web.appprogramming/html/guide/app_guide/application_service.htm">application control </a>information if it is necessary.
For more information about the application contorl, see <a href="../../org.tizen.web.device.apireference/tizen/application.html">The Application API</a>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/alarm
            </privilege>
            <Code> // Triggers an alarm on a given date/time
 var alarm = new tizen.AlarmAbsolute(new Date(2014, 10, 4, 8, 0));
 var appControl = new tizen.ApplicationControl(&quot;http://tizen.org/appcontrol/operation/view&quot;);
 tizen.alarm.add(alarm, tizen.application.getCurrentApplication().appInfo.id, appControl);
 console.log(&quot;Alarm added with id: &quot; + alarm.id);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="alarm">
            <descriptive>
                <description><p>
 An alarm to add. It can be either <em>AlarmRelative </em> or <em>AlarmAbsolute</em>.
                </p></description>
            </descriptive>
            <Type name="Alarm"/>
          </Argument>
          <Argument name="applicationId">
            <descriptive>
                <description><p>
 The application ID to run when the alarm is triggered.
                </p></description>
            </descriptive>
            <Type name="ApplicationId"/>
          </Argument>
          <Argument optional="optional" name="appControl">
            <descriptive>
                <description><p>
 The data structure describing application control details.
                </p></description>
            </descriptive>
            <Type name="ApplicationControl" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter does not contain a valid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::Alarm::AlarmManager::remove">
        <webidl>        void remove(<ref>AlarmId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes an alarm from the storage.
            </brief>
           <description>
            <p>
If an alarm goes off, it will be removed from the storage automatically.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/alarm
            </privilege>
            <Code> var alarms = tizen.alarm.getAll();

 // Removes the first alarm
 if (alarms.length > 0) {
   try {
     tizen.alarm.remove(alarms[0].id);
     console.log(&quot;Successfully removed the first alarm.&quot;);
   } catch(error) {
     console.log(&quot;Failed to remove the first alarm.&quot;);
   }
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The ID of the alarm to remove
                </p></description>
            </descriptive>
            <Type name="AlarmId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if this alarm identifier cannot be found in the storage.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter does not contain a valid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if the method cannot be completed because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeAll" id="::Alarm::AlarmManager::removeAll">
        <webidl>        void removeAll() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes all alarms added by an application.
            </brief>
           <description>
            <p>
Because each application has its own alarm storage, this method removes alarms only added by the calling application.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/alarm
            </privilege>
            <Code> tizen.alarm.removeAll();
 console.log(&quot;remove all registered alarms in the storage.&quot;);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if the method cannot be completed because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="get" id="::Alarm::AlarmManager::get">
        <webidl>        <ref>Alarm</ref> get(<ref>AlarmId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns an alarm as per the specified identifier.
            </brief>
            <version>
 1.0
            </version>
            <Code> // Sets an alarm
 var date = new Date();
 date.setHours(date.getHours()+1);
 var abs_alarm = new tizen.AlarmAbsolute(date);

 // Adds an alarm
 tizen.alarm.add(abs_alarm, tizen.application.getCurrentApplication().appInfo.id);

 // Gets an alarm
 var alarm = tizen.alarm.get(abs_alarm.id);
 console.log(&quot;The alarm will trigger at &quot; + alarm.getNextScheduledDate());
 </Code>
        </descriptive>
        <Type name="Alarm">
          <descriptive>
              <description><p>
 Alarm An alarm object with the specified ID.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The alarm ID to retrieve.
                </p></description>
            </descriptive>
            <Type name="AlarmId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if this alarm identifier cannot be found in the storage.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter does not contain a valid value.
                </p></description>
                <description><p>
 with error type UnknownError, if the method cannot be completed because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAll" id="::Alarm::AlarmManager::getAll">
        <webidl>        <ref>Alarm</ref>[] getAll() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Retrieves all alarms in an application storage..
            </brief>
           <description>
            <p>
Alarms that have already been triggered are removed automatically from the storage.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var alarms = tizen.alarm.getAll();
 console.log(alarms.length + &quot; alarms present in the storage.&quot;);
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 Alarm[] All Alarm objects.
              </p></description>
          </descriptive>
          <Type name="Alarm"/>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the method cannot be completed because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Alarm" id="::Alarm::Alarm">
      <webidl>    [NoInterfaceObject] interface Alarm {&#13;
&#13;
        readonly attribute <ref>AlarmId</ref>? id;&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface is an abstract interface for alarm types.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Alarm::Alarm::id">
        <webidl>        readonly attribute <ref>AlarmId</ref>? id;</webidl>
        <descriptive>
            <brief>
 The alarm identifier.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="AlarmId" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="AlarmRelative" id="::Alarm::AlarmRelative">
      <webidl>    [Constructor(long delay, optional long? period)]&#13;
&#13;
    interface AlarmRelative : <ref>Alarm</ref> {&#13;
&#13;
        readonly attribute long delay;&#13;
        &#13;
&#13;
        readonly attribute long? period;&#13;
&#13;
&#13;
        long? getRemainingSeconds() raises(<ref>WebAPIException</ref>);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface provides the relative alarm, which occurs at a fixed interval in future.
          </brief>
         <description>
          <p>
This alarm triggers after a duration mentioned in <em>delay</em> attribute from the moment the alarm is added.
If a <em>period</em> is provided, the alarm keeps triggering for the given interval.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> // Gets the current application id.
 var appId = tizen.application.getCurrentApplication().appInfo.id;

 // Sets an alarm in 3 hours from now
 var alarm1 = new tizen.AlarmRelative(3 * tizen.alarm.PERIOD_HOUR);
 tizen.alarm.add(alarm1, appId);

 // Sets an alarm in one hour, recurring after every 2 minutes
 var alarm2 = new tizen.AlarmRelative(tizen.alarm.PERIOD_HOUR, 2 * tizen.alarm.PERIOD_MINUTE);
 tizen.alarm.add(alarm2, appId);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(long delay, optional long? period)</webidl>
          <ArgumentList>
            <Argument name="delay">
              <Type type="long"/>
            </Argument>
            <Argument optional="optional" name="period">
              <Type type="long" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="Alarm"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="delay" id="::Alarm::AlarmRelative::delay">
        <webidl>        readonly attribute long delay;</webidl>
        <descriptive>
            <brief>
 An attribute to store the difference in time (in seconds) between when an alarm is added and it is triggered.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="period" id="::Alarm::AlarmRelative::period">
        <webidl>        readonly attribute long? period;</webidl>
        <descriptive>
            <brief>
 An attribute to store the duration in seconds between each trigger of an alarm.
By default, this attribute is set to <var>null</var>, indicating that this alarm does not repeat.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long" nullable="nullable"/>
      </Attribute>
      <Operation name="getRemainingSeconds" id="::Alarm::AlarmRelative::getRemainingSeconds">
        <webidl>        long? getRemainingSeconds() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns duration in seconds before the next alarm is triggered.
            </brief>
           <description>
            <p>
If the alarm has expired, this method returns <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // Gets the current application id.
 var appId = tizen.application.getCurrentApplication().appInfo.id;

 // Sets an alarm in 3 hours from now
 var alarm = new tizen.AlarmRelative(3 * tizen.alarm.PERIOD_HOUR);
 tizen.alarm.add(alarm, appId);

 var sec = alarm.getRemainingSeconds();
 console.log(&quot;remaining time is &quot; + sec);
 </Code>
        </descriptive>
        <Type type="long" nullable="nullable">
          <descriptive>
              <description><p>
 long The duration before the next alarm trigger.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the method cannot be completed because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="AlarmAbsolute" id="::Alarm::AlarmAbsolute">
      <webidl>    [Constructor(Date date),&#13;
&#13;
     Constructor(Date date, <ref>ByDayValue</ref>[] daysOfTheWeek),&#13;
&#13;
     Constructor(Date date, long period)]&#13;
&#13;
    interface AlarmAbsolute : <ref>Alarm</ref> {&#13;
&#13;
        readonly attribute Date date;&#13;
&#13;
&#13;
        readonly attribute long? period;&#13;
&#13;
&#13;
        readonly attribute <ref>ByDayValue</ref>[] daysOfTheWeek;&#13;
&#13;
&#13;
        Date? getNextScheduledDate() raises(<ref>WebAPIException</ref>);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface provides an absolute alarm, which triggers at a specified absolute date.
          </brief>
         <description>
          <p>
If a <em>period</em> is provided, the alarm keeps triggering for the given interval. If the <em>daysOfTheWeek</em> array is not empty, the alarm triggers every week, for the given days, at the time defined by <em>date</em> attribute.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> // Gets the current application id.
 var appId = tizen.application.getCurrentApplication().appInfo.id;

 // Sets an alarm on January 1st 2014 08:00
 var date = new Date(2014, 0, 1, 8, 0);
 var alarm1 = new tizen.AlarmAbsolute(date);
 tizen.alarm.add(alarm1, appId);

 // Sets an alarm on January 1st 2014 08:00, repeating every 2 days
 var alarm2 = new tizen.AlarmAbsolute(date, 2 * tizen.alarm.PERIOD_DAY);
 tizen.alarm.add(alarm2, appId);

 // Sets an alarm occurring on every Saturday and Sunday, at 08:00, starting from January 1st 2014
 var alarm3 = new tizen.AlarmAbsolute(date, [&quot;SA&quot;, &quot;SU&quot;]);
 tizen.alarm.add(alarm3, appId);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(Date date)</webidl>
          <ArgumentList>
            <Argument name="date">
              <Type type="Date"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>     Constructor(Date date, <ref>ByDayValue</ref>[] daysOfTheWeek)</webidl>
          <ArgumentList>
            <Argument name="date">
              <Type type="Date"/>
            </Argument>
            <Argument name="daysOfTheWeek">
              <Type type="array">
                <Type name="ByDayValue"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>     Constructor(Date date, long period)</webidl>
          <ArgumentList>
            <Argument name="date">
              <Type type="Date"/>
            </Argument>
            <Argument name="period">
              <Type type="long"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="Alarm"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="date" id="::Alarm::AlarmAbsolute::date">
        <webidl>        readonly attribute Date date;</webidl>
        <descriptive>
            <brief>
 An attribute to store the absolute date/time when the alarm is initially triggered.
            </brief>
           <description>
            <p>
This attribute is precise to the second. Milliseconds will be ignored.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
      <Attribute readonly="readonly" name="period" id="::Alarm::AlarmAbsolute::period">
        <webidl>        readonly attribute long? period;</webidl>
        <descriptive>
            <brief>
 An attribute to store the duration in seconds between each trigger of the alarm.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>, indicating that this alarm does not repeat.
The <em>period</em> and <em>daysOfTheWeek</em> attributes are mutually exclusive.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="daysOfTheWeek" id="::Alarm::AlarmAbsolute::daysOfTheWeek">
        <webidl>        readonly attribute <ref>ByDayValue</ref>[] daysOfTheWeek;</webidl>
        <descriptive>
            <brief>
 An attribute to store the days of the week associated with the recurrence rule.
            </brief>
           <description>
            <p>
By default, this attribute is set to an empty array.
The <em>period</em> and <em>daysOfTheWeek</em> attributes are mutually exclusive.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="ByDayValue"/>
        </Type>
      </Attribute>
      <Operation name="getNextScheduledDate" id="::Alarm::AlarmAbsolute::getNextScheduledDate">
        <webidl>        Date? getNextScheduledDate() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns the date / time of the next alarm trigger.
            </brief>
           <description>
            <p>
If the alarm has expired, this method returns <var>null</var>. The returned date is precise to the second.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // Gets the current application id.
 var appId = tizen.application.getCurrentApplication().appInfo.id;

 // Sets an alarm on January 1st 2014 08:00
 var date = new Date(2014, 0, 1, 8, 0);
 var alarm1 = new tizen.AlarmAbsolute(date);
 tizen.alarm.add(alarm1, appId);

 var date = alarm1.getNextScheduledDate();
 console.log(&quot;next scheduled time is &quot; + date);
 </Code>
        </descriptive>
        <Type type="Date" nullable="nullable">
          <descriptive>
              <description><p>
 Date The date/time of the next alarm trigger.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the method cannot be completed because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
  </Module>
  <Module name="Application" id="::Application">
    <webidl>module Application {

  typedef DOMString ApplicationId;

  typedef DOMString ApplicationContextId;

  [NoInterfaceObject] interface ApplicationManagerObject {
    readonly attribute <ref>ApplicationManager</ref> application;
  };
  <ref>Tizen</ref> implements <ref>ApplicationManagerObject</ref>;

  [NoInterfaceObject] interface ApplicationManager {

    <ref>Application</ref> getCurrentApplication() raises(<ref>WebAPIException</ref>);

    void kill(<ref>ApplicationContextId</ref> contextId,
              optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void launch(<ref>ApplicationId</ref> id,
                optional <ref>SuccessCallback</ref>? successCallback,
                optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void launchAppControl(<ref>ApplicationControl</ref> appControl,
                          optional <ref>ApplicationId</ref>? id,
                          optional <ref>SuccessCallback</ref>? successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback,
                          optional <ref>ApplicationControlDataArrayReplyCallback</ref>? replyCallback) raises(<ref>WebAPIException</ref>);

    void findAppControl(<ref>ApplicationControl</ref> appControl,
                        <ref>FindAppControlSuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void getAppsContext(<ref>ApplicationContextArraySuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    <ref>ApplicationContext</ref> getAppContext(optional <ref>ApplicationContextId</ref>? contextId) raises(<ref>WebAPIException</ref>);

    void getAppsInfo(<ref>ApplicationInformationArraySuccessCallback</ref> successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    <ref>ApplicationInformation</ref> getAppInfo(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);

    <ref>ApplicationCertificate</ref>[] getAppCerts(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);

    DOMString getAppSharedURI(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);

    <ref>ApplicationMetaData</ref>[] getAppMetaData(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);

    long addAppInfoEventListener(<ref>ApplicationInformationEventCallback</ref> eventCallback) raises(<ref>WebAPIException</ref>);

    void removeAppInfoEventListener(long watchId) raises(<ref>WebAPIException</ref>);

  };

  [NoInterfaceObject] interface Application {

    readonly attribute <ref>ApplicationInformation</ref> appInfo;

    readonly attribute <ref>ApplicationContextId</ref> contextId;

    void exit() raises(<ref>WebAPIException</ref>);

    void hide() raises(<ref>WebAPIException</ref>);

    <ref>RequestedApplicationControl</ref> getRequestedAppControl() raises(<ref>WebAPIException</ref>);
  };


  [NoInterfaceObject] interface ApplicationInformation {

    readonly attribute <ref>ApplicationId</ref> id;

    readonly attribute DOMString name;

    readonly attribute DOMString iconPath;

    readonly attribute DOMString version;

    readonly attribute boolean show;

    readonly attribute DOMString[] categories;

    readonly attribute Date installDate;

    readonly attribute long size raises(<ref>WebAPIException</ref>);

    readonly attribute <ref>PackageId</ref> packageId;
  };

  [NoInterfaceObject] interface ApplicationContext {

    readonly attribute <ref>ApplicationContextId</ref> id;

    readonly attribute <ref>ApplicationId</ref> appId;

  };

  [Constructor(DOMString key, DOMString[] value)]
  interface ApplicationControlData {

    attribute DOMString key;

    attribute DOMString[] value;

  };

  [Constructor(DOMString operation, optional DOMString? uri,
               optional DOMString? mime, optional DOMString? category,
               optional <ref>ApplicationControlData</ref>[]? data)]
  interface ApplicationControl {

    attribute DOMString operation;

    attribute DOMString? uri;

    attribute DOMString? mime;

    attribute DOMString? category;

    attribute <ref>ApplicationControlData</ref>[] data;

  };

  [NoInterfaceObject] interface RequestedApplicationControl {

    readonly attribute <ref>ApplicationControl</ref> appControl;

    readonly attribute <ref>ApplicationId</ref> callerAppId;

    void replyResult(optional <ref>ApplicationControlData</ref>[]? data) raises(<ref>WebAPIException</ref>);

    void replyFailure() raises(<ref>WebAPIException</ref>);

  };


  [NoInterfaceObject] interface ApplicationCertificate {

    readonly attribute DOMString type;

    readonly attribute DOMString value;

  };


  [NoInterfaceObject] interface ApplicationMetaData {

    readonly attribute DOMString key;

    readonly attribute DOMString value;

  };


  [Callback=FunctionOnly, NoInterfaceObject] interface ApplicationInformationArraySuccessCallback {
    void onsuccess(<ref>ApplicationInformation</ref>[] informationArray);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface FindAppControlSuccessCallback {
    void onsuccess(<ref>ApplicationInformation</ref>[] informationArray, <ref>ApplicationControl</ref> appControl);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface ApplicationContextArraySuccessCallback {
    void onsuccess(<ref>ApplicationContext</ref>[] contexts);
  };

  [Callback, NoInterfaceObject] interface ApplicationControlDataArrayReplyCallback {
    void onsuccess(optional <ref>ApplicationControlData</ref>[]? data);

    void onfailure();
  };

  [Callback, NoInterfaceObject] interface ApplicationInformationEventCallback {
    void oninstalled(<ref>ApplicationInformation</ref> info);

    void onupdated(<ref>ApplicationInformation</ref> info);

    void onuninstalled(<ref>ApplicationId</ref> id);
  };

};</webidl>
    <descriptive>
        <brief>
 This API provides a way to launch other applications and access
application management.
        </brief>
       <description>
        <p>
The <em>ApplicationManager</em> interface also provides methods to launch other applications
explicitly and implicitly through the <em>ApplicationControl</em> interface.
The <em>ApplicationControl</em> interface consists of an operation, URI, and MIME type
and also describes an action to be performed by other
applications and can carry the result from the subsequent application.
The <em>ApplicationManager</em> interface also provides methods to handle the application
lifecycle, to access the installed applications on the device, and to let
an application be notified of a change in the application list.
        </p>
        <p>
The <em>Application</em> interface defines the current application's information and
the basic operations for current application such as exit or hide.
        </p>
        <p>
For more information on the Application features, see <a href="../../org.tizen.web.appprogramming/html/guide/app_guide/application.htm">Application Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
    </descriptive>
    <Typedef name="ApplicationId" id="::Application::ApplicationId">
      <webidl>  typedef DOMString ApplicationId;</webidl>
      <descriptive>
          <brief>
 The unique ID for an installed application.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="ApplicationContextId" id="::Application::ApplicationContextId">
      <webidl>  typedef DOMString ApplicationContextId;</webidl>
      <descriptive>
          <brief>
 The unique ID for a running application.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Interface name="ApplicationManagerObject" id="::Application::ApplicationManagerObject">
      <webidl>  [NoInterfaceObject] interface ApplicationManagerObject {
    readonly attribute <ref>ApplicationManager</ref> application;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen </em>object by the Tizen Platform.
          </brief>
         <description>
          <p>
There will be a <em>tizen.application </em>object that allows access to Application API functionality.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="application" id="::Application::ApplicationManagerObject::application">
        <webidl>    readonly attribute <ref>ApplicationManager</ref> application;</webidl>
        <Type name="ApplicationManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="ApplicationManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>ApplicationManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="ApplicationManager" id="::Application::ApplicationManager">
      <webidl>  [NoInterfaceObject] interface ApplicationManager {

    <ref>Application</ref> getCurrentApplication() raises(<ref>WebAPIException</ref>);

    void kill(<ref>ApplicationContextId</ref> contextId,
              optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void launch(<ref>ApplicationId</ref> id,
                optional <ref>SuccessCallback</ref>? successCallback,
                optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void launchAppControl(<ref>ApplicationControl</ref> appControl,
                          optional <ref>ApplicationId</ref>? id,
                          optional <ref>SuccessCallback</ref>? successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback,
                          optional <ref>ApplicationControlDataArrayReplyCallback</ref>? replyCallback) raises(<ref>WebAPIException</ref>);

    void findAppControl(<ref>ApplicationControl</ref> appControl,
                        <ref>FindAppControlSuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void getAppsContext(<ref>ApplicationContextArraySuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    <ref>ApplicationContext</ref> getAppContext(optional <ref>ApplicationContextId</ref>? contextId) raises(<ref>WebAPIException</ref>);

    void getAppsInfo(<ref>ApplicationInformationArraySuccessCallback</ref> successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    <ref>ApplicationInformation</ref> getAppInfo(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);

    <ref>ApplicationCertificate</ref>[] getAppCerts(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);

    DOMString getAppSharedURI(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);

    <ref>ApplicationMetaData</ref>[] getAppMetaData(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);

    long addAppInfoEventListener(<ref>ApplicationInformationEventCallback</ref> eventCallback) raises(<ref>WebAPIException</ref>);

    void removeAppInfoEventListener(long watchId) raises(<ref>WebAPIException</ref>);

  };</webidl>
      <descriptive>
          <brief>
 This section defines the application manager interface.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getCurrentApplication" id="::Application::ApplicationManager::getCurrentApplication">
        <webidl>    <ref>Application</ref> getCurrentApplication() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the <em>Application </em>object defining the current application.
            </brief>
            <version>
 2.0
            </version>
            <Code> var app = tizen.application.getCurrentApplication();
 console.log(&quot;Current application's app id is &quot; + app.appInfo.id);
 </Code>
        </descriptive>
        <Type name="Application">
          <descriptive>
              <description><p>
 Application The data structure that defines current application.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the application cannot be retrieved because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="kill" id="::Application::ApplicationManager::kill">
        <webidl>    void kill(<ref>ApplicationContextId</ref> contextId,
              optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Kills an application with the specified application context ID.
            </brief>
           <description>
            <p>
The <em>ErrorCallback() </em>is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If the context is not found with specified context ID.              </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value
or if the specified context ID matches the context ID of the calling application.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/appmanager.kill
            </privilege>
            <Code> function onKillSuccess() {
     console.log(&quot;Application terminated successfully&quot;);
 }

 function onRunningAppsContext(contexts) {
    // let's assume that the application &quot;targetApp0.main&quot; has been installed.
    var targetId = &quot;targetApp0.main&quot;;

    for (var i = 0; i &#60; contexts.length; i++) {
        if (contexts[i].appId == targetId) {
            tizen.application.kill(contexts[i].id, onKillSuccess);
        }
    }
 }

 tizen.application.getAppsContext(onRunningAppsContext);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contextId">
            <descriptive>
                <description><p>
 The identifier of the application to kill
                </p></description>
            </descriptive>
            <Type name="ApplicationContextId"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when an application is killed successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="launch" id="::Application::ApplicationManager::launch">
        <webidl>    void launch(<ref>ApplicationId</ref> id,
                optional <ref>SuccessCallback</ref>? successCallback,
                optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Launches an application with the given application ID.
            </brief>
           <description>
            <p>
The <em>ErrorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If the application is not found with given ID.              </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/application.launch
            </privilege>
            <Code> function onsuccess() {
     console.log(&quot;The application has launched successfully&quot;);
 }

 // let's assume that application &quot;targetApp0.main&quot; has been installed
 tizen.application.launch(&quot;targetApp0.main&quot;, onsuccess);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 A unique string representing application ID.
                </p></description>
            </descriptive>
            <Type name="ApplicationId"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="launchAppControl" id="::Application::ApplicationManager::launchAppControl">
        <webidl>    void launchAppControl(<ref>ApplicationControl</ref> appControl,
                          optional <ref>ApplicationId</ref>? id,
                          optional <ref>SuccessCallback</ref>? successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback,
                          optional <ref>ApplicationControlDataArrayReplyCallback</ref>? replyCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Launches an application with the specified application control.
            </brief>
           <description>
            <p>
An application can launch other applications with the application control,
and get back the results from the launched applications.
            </p>
            <p>
The application control consists of an operation, URI, and MIME type, and describes
the request to be performed by the newly launched application. The
application control is passed to the <em>launchAppControl()</em> method to launch an
application. The system tries to find the proper application
to perform the requested application control, then launches the selected application.
            </p>
            <p>
The application control request is passed to the newly launched application
and it can be accessed by <em>getRequestedAppControl() </em>method. The passed
application control contains the reason the application was launched and
information about what the application is doing. The launched application
can send a result to the caller application with the <em>replyResult() </em>method of
<em>RequestedApplicationControl</em> interface.
            </p>
            <p>
The <em>ErrorCallback() </em>is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If system cannot find the application that matches the specified application control.              </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError: If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/application.launch
            </privilege>
            <Code> var appControl = new tizen.ApplicationControl(
     &quot;http://tizen.org/appcontrol/operation/pick&quot;,
     null,
     &quot;image/jpeg&quot;,
     null);

 var appControlReplyCallback = {
     // callee sent a reply
     onsuccess: function(data) {
         for (var i = 0; i &#60; data.length; i++) {
             if (data[i].key == &quot;http://tizen.org/appcontrol/data/selected&quot;) {
                 console.log('Selected image is ' + data[i].value[0]);
             }
         }
     },
     // callee returned failure
     onfailure: function() {
         console.log('The launch application control failed');
     }
 }

 tizen.application.launchAppControl(
     appControl,
     null,
     function() {console.log(&quot;launch application control succeed&quot;); },
     function(e) {console.log(&quot;launch application control failed. reason: &quot; + e.message); },
     appControlReplyCallback );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="appControl">
            <descriptive>
                <description><p>
 The data structure describing application control details.
                </p></description>
            </descriptive>
            <Type name="ApplicationControl"/>
          </Argument>
          <Argument optional="optional" name="id">
            <descriptive>
                <description><p>
 An identifier of the application to be launched. If the ID is <var>null </var>or not specified, then the system tries to find the application to be launched for the requested application control.
                </p></description>
            </descriptive>
            <Type name="ApplicationId" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="replyCallback">
            <descriptive>
                <description><p>
 The method to invoke when the application gets back results from the launched application.
                </p></description>
            </descriptive>
            <Type name="ApplicationControlDataArrayReplyCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="findAppControl" id="::Application::ApplicationManager::findAppControl">
        <webidl>    void findAppControl(<ref>ApplicationControl</ref> appControl,
                        <ref>FindAppControlSuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Finds application information can be launched with the given application control.
            </brief>
           <description>
            <p>
An application can get a list of other applications can be launched with the application control.
            </p>
            <p>
The <em>ErrorCallback()<em> is launched with these error types:
</em></em>            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <Code> var appControl = new tizen.ApplicationControl(
     &quot;http://tizen.org/appcontrol/operation/pick&quot;,
     null,
     &quot;image/jpeg&quot;,
     null);

 function successCB(appInfos, appControl)
 {
     // em>appControl/em> is same object with the value passed as first parameter to em>findAppControl()/em>
     var appControlReplyCallback = {
         // callee sent a reply
         onsuccess: function(data) {
             for (var i = 0; i &#60; data.length; i++) {
                 if (data[i].key == &quot;http://tizen.org/appcontrol/data/selected&quot;) {
                     console.log('Selected image is ' + data[i].value[0]);
                 }
             }
         },
         // callee returned failure
         onfailure: function() {
             console.log('The launch application control failed');
         }
     }

     var appId = appInfos[0].id; // select first app's id

     tizen.application.launchAppControl(
         appControl,
         appId,
         function() {console.log(&quot;launch application control succeed&quot;); },
        function(e) {console.log(&quot;launch application control failed. reason: &quot; + e.message); },
        appControlReplyCallback );
 }

 tizen.application.findAppControl(appControl, successCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="appControl">
            <descriptive>
                <description><p>
 A data structure describing application control details.
                </p></description>
            </descriptive>
            <Type name="ApplicationControl"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call that returns a list of application information.
                </p></description>
            </descriptive>
            <Type name="FindAppControlSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAppsContext" id="::Application::ApplicationManager::getAppsContext">
        <webidl>    void getAppsContext(<ref>ApplicationContextArraySuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets a list of application contexts for applications that are currently running on a device.
The information contained for each application corresponds to the application state at the time when the list was generated.
            </brief>
           <description>
            <p>
The <em>errorCallback()</em> is launched with this error type:
            </p>
            <ul>
              <li>
UnknownError - If an unknown error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <Code> function onRunningAppsContext(contexts) {
     for (var i = 0; i &#60; contexts.length; i++)
         console.log(&quot;ID : &quot; + contexts[i].id);
 }

 tizen.application.getAppsContext(onRunningAppsContext);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="ApplicationContextArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAppContext" id="::Application::ApplicationManager::getAppContext">
        <webidl>    <ref>ApplicationContext</ref> getAppContext(optional <ref>ApplicationContextId</ref>? contextId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the application context for the specified application context ID.
If the ID is set to<var> null</var> or is not set at all, the method returns the application context of the current application.
The list of running applications and their application IDs is obtained with <em>getAppsContext()</em>.
            </brief>
            <version>
 2.0
            </version>
            <Code> var appContext = tizen.application.getAppContext(null);
 console.log(&quot;Application context retrieved for app &quot; + appContext.appId);
 </Code>
        </descriptive>
        <Type name="ApplicationContext">
          <descriptive>
              <description><p>
 ApplicationContext A data structure that lists running application details.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="contextId">
            <descriptive>
                <description><p>
 A string representing an application context ID. If the ID is not provided, the application context of the calling application will be returned.
                </p></description>
            </descriptive>
            <Type name="ApplicationContextId" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotFoundError, if the application context is not found with provided ID.
                </p></description>
                <description><p>
 with error type UnknownError, if the application context cannot be retrieved because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAppsInfo" id="::Application::ApplicationManager::getAppsInfo">
        <webidl>    void getAppsInfo(<ref>ApplicationInformationArraySuccessCallback</ref> successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the list of installed application's information on a device.
The information contained on each application corresponds to the application state at the moment when the list was generated.
            </brief>
           <description>
            <p>
The <em>errorCallback()</em> is launched with this error type:
            </p>
            <ul>
              <li>
UnknownError - If an unknown error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <Code> function onListInstalledApps(applications) {
     for (var i = 0; i &#60; applications.length; i++)
         console.log(&quot;ID : &quot; + applications[i].id);
 }

 tizen.application.getAppsInfo(onListInstalledApps);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="ApplicationInformationArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAppInfo" id="::Application::ApplicationManager::getAppInfo">
        <webidl>    <ref>ApplicationInformation</ref> getAppInfo(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets application information for a specified application ID.
            </brief>
           <description>
            <p>
If the ID is set to <var>null</var> or not set at all, it returns application information for the current application.
The list of installed applications and their application IDs is obtained with <em>getAppsInfo()</em>.
            </p>
           </description>
            <version>
 2.0
            </version>
            <Code> var appInfo = tizen.application.getAppInfo(null);
 console.log(&quot;Current application name : &quot; + appInfo.name);
 </Code>
        </descriptive>
        <Type name="ApplicationInformation">
          <descriptive>
              <description><p>
 ApplicationInformation The information of an application.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="id">
            <descriptive>
                <description><p>
 A string representing application ID. If the ID is not provided, the application information of the calling application will be returned.
                </p></description>
            </descriptive>
            <Type name="ApplicationId" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotFoundError, if the application is not found with specified ID.
                </p></description>
                <description><p>
 with error type UnknownError, if the application cannot be retrieved because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAppCerts" id="::Application::ApplicationManager::getAppCerts">
        <webidl>    <ref>ApplicationCertificate</ref>[] getAppCerts(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets application certificates for a specified application ID.
            </brief>
           <description>
            <p>
If the ID is set to <var>null</var> or not set at all, it returns application certificates for the current application.
            </p>
            <p>
The certificate types are listed below
            </p>
            <ul>
              <li>
 AUTHOR_ROOT - Author Root Certificate               </li>
              <li>
 AUTHOR_INTERMEDIATE - Author Intermediate Certificate               </li>
              <li>
 AUTHOR_SIGNER - Author Signer Certificate               </li>
              <li>
 DISTRIBUTOR_ROOT - Distributor Root Certificate               </li>
              <li>
 DISTRIBUTOR_INTERMEDIATE - Distributor Intermediate Certificate               </li>
              <li>
 DISTRIBUTOR_SIGNER - Distributor Signer Certificate               </li>
              <li>
 DISTRIBUTOR2_ROOT - Distributor2 Root Certificate               </li>
              <li>
 DISTRIBUTOR2_INTERMEDIATE - Distributor2 Intermediate Certificate               </li>
              <li>
 DISTRIBUTOR2_SIGNER - Distributor2 Signer Certificate               </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/appmanager.certificate
            </privilege>
            <Code> var appCerts = tizen.application.getAppCerts(null);

 for (var i = 0; i &#60; appCerts.length; i++) {
    console.log(&quot;#&quot; + i + &quot; type:&quot; + appCerts[i].type);
    console.log(&quot;#&quot; + i + &quot; value:&quot; + appCerts[i].value);
 }
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 ApplicationCertificate[] Array of certificate information of a specified application
              </p></description>
          </descriptive>
          <Type name="ApplicationCertificate"/>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="id">
            <descriptive>
                <description><p>
 A string representing application ID. If the ID is not provided, the application certificate of the calling application will be returned.
                </p></description>
            </descriptive>
            <Type name="ApplicationId" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotFoundError, if the application is not found with specified ID.
                </p></description>
                <description><p>
 with error type UnknownError, if the application cannot be retrieved because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAppSharedURI" id="::Application::ApplicationManager::getAppSharedURI">
        <webidl>    DOMString getAppSharedURI(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets URI of read-only shared directory of application for a specified application ID.
            </brief>
           <description>
            <p>
The shared directory is used to export data to other applications.
If the ID is set to <var>null</var> or not set at all, it returns shared directory URI for the current application.
            </p>
           </description>
            <version>
 2.1
            </version>
            <Code> var sharedDir = tizen.application.getAppSharedURI(null);
 console.log(&quot;shared directory : &quot; + sharedDir);
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The shared directory URI of application
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="id">
            <descriptive>
                <description><p>
 A string representing application ID. If the ID is not provided, the shared directory URI of the calling application will be returned.
                </p></description>
            </descriptive>
            <Type name="ApplicationId" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotFoundError, if the application is not found with specified ID.
                </p></description>
                <description><p>
 with error type UnknownError, if the application cannot be retrieved because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAppMetaData" id="::Application::ApplicationManager::getAppMetaData">
        <webidl>    <ref>ApplicationMetaData</ref>[] getAppMetaData(optional <ref>ApplicationId</ref>? id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets application meta data array for a specified application ID.
            </brief>
           <description>
            <p>
If the ID is set to <var>null</var> or not set at all, it returns application meta data array for the current application.
            </p>
           </description>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/application.info
            </privilege>
            <Code> var metaDataArray = tizen.application.getAppMetaData(null);
 console.log(&quot;size of metadata : &quot; + metaDataArray.length);

 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 ApplicationMetaData[] Array of meta data of a specified application. If there are no meta data for a specified application,
empty array will be returned
              </p></description>
          </descriptive>
          <Type name="ApplicationMetaData"/>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="id">
            <descriptive>
                <description><p>
 A string representing application ID. If the ID is not provided, the application metadata array of the calling application will be returned.
                </p></description>
            </descriptive>
            <Type name="ApplicationId" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotFoundError, if the application is not found with specified ID.
                </p></description>
                <description><p>
 with error type UnknownError, if the application cannot be retrieved because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addAppInfoEventListener" id="::Application::ApplicationManager::addAppInfoEventListener">
        <webidl>    long addAppInfoEventListener(<ref>ApplicationInformationEventCallback</ref> eventCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a listener for receiving any notification for changes in the list of the installed applications
on a device.
            </brief>
           <description>
            <p>
It install a callback that is triggered every time a change occurs on
the list of installed applications on a device. This change may
be occurred by a new installation, uninstallation, or update of an application.
            </p>
            <p>
When executed, the implementation must immediately return a listener
ID that identifies the listener. After returning the ID, the change
detection operation is started asynchronously.
            </p>
            <p>
The <em>ApplicationInformationEventCallback </em>must be invoked every time a new
application is installed, removed, or updated.
            </p>
            <p>
The change detection must continue until the <em>removeAppInfoEventListener()</em> method is called
with the corresponding listener identifier.
            </p>
           </description>
            <version>
 2.0
            </version>
            <Code> var appEventCallback = {
    oninstalled: function(appInfo) {
       console.log('The application ' + appInfo.name + ' is installed');
    },
    onupdated: function(appInfo) {
       console.log('The application ' + appInfo.name + ' is updated');
    },
    onuninstalled: function(appid) {
       console.log('The application ' + appid + ' is uninstalled');
    }
 };
 var watchId = tizen.application.addAppInfoEventListener(appEventCallback);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long ID of the listener that can be used to remove the listener later.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="eventCallback">
            <descriptive>
                <description><p>
 The method to call when a change on the installed applications is made.
                </p></description>
            </descriptive>
            <Type name="ApplicationInformationEventCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if fails to add listener because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeAppInfoEventListener" id="::Application::ApplicationManager::removeAppInfoEventListener">
        <webidl>    void removeAppInfoEventListener(long watchId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes the listener to stop receiving notifications for changes on the list of installed
applications on a device.
            </brief>
            <version>
 2.0
            </version>
            <Code> tizen.application.removeAppInfoEventListener(watchId);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="watchId">
            <descriptive>
                <description><p>
 An ID that identifies the listener.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type NotFoundError, if the listener is not found with specified ID.
                </p></description>
                <description><p>
 with error type UnknownError, if fails to remove listener because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Application" id="::Application::Application">
      <webidl>  [NoInterfaceObject] interface Application {

    readonly attribute <ref>ApplicationInformation</ref> appInfo;

    readonly attribute <ref>ApplicationContextId</ref> contextId;

    void exit() raises(<ref>WebAPIException</ref>);

    void hide() raises(<ref>WebAPIException</ref>);

    <ref>RequestedApplicationControl</ref> getRequestedAppControl() raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the current application's information and
the basic operations (such as exit or hide) for the current application .
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="appInfo" id="::Application::Application::appInfo">
        <webidl>    readonly attribute <ref>ApplicationInformation</ref> appInfo;</webidl>
        <descriptive>
            <brief>
 An attribute to store the application information for the current application.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ApplicationInformation"/>
      </Attribute>
      <Attribute readonly="readonly" name="contextId" id="::Application::Application::contextId">
        <webidl>    readonly attribute <ref>ApplicationContextId</ref> contextId;</webidl>
        <descriptive>
            <brief>
 An attribute to store the ID of a running application.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ApplicationContextId"/>
      </Attribute>
      <Operation name="exit" id="::Application::Application::exit">
        <webidl>    void exit() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Exits the current application.
            </brief>
            <version>
 2.0
            </version>
            <Code> var app = tizen.application.getCurrentApplication();

 app.exit();
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="hide" id="::Application::Application::hide">
        <webidl>    void hide() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Hides the current application.
            </brief>
            <version>
 2.0
            </version>
            <Code> var app = tizen.application.getCurrentApplication();

 app.hide();
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getRequestedAppControl" id="::Application::Application::getRequestedAppControl">
        <webidl>    <ref>RequestedApplicationControl</ref> getRequestedAppControl() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the requested application control passed to the current application.
            </brief>
           <description>
            <p>
Gets the requested application control that contains the application control
passed by the <em>launchAppControl()</em> method from the calling application.
The requested application control contains the reason the application
was launched and what it has to perform. For example, an application
might be launched to display an image on a page by other
application's request. In all of these cases, the application is
responsible for checking the contents of the application control and responding
appropriately when it is launched.
            </p>
           </description>
            <version>
 2.0
            </version>
            <Code> var reqAppControl = tizen.application.getCurrentApplication().getRequestedAppControl();

 if (reqAppControl) {
     console.log(&quot;Requester AppID : &quot; + reqAppControl.callerAppId);
 }
 </Code>
        </descriptive>
        <Type name="RequestedApplicationControl">
          <descriptive>
              <description><p>
 RequestedApplicationControl The details of an requested application control
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the application control cannot be retrieved because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="ApplicationInformation" id="::Application::ApplicationInformation">
      <webidl>  [NoInterfaceObject] interface ApplicationInformation {

    readonly attribute <ref>ApplicationId</ref> id;

    readonly attribute DOMString name;

    readonly attribute DOMString iconPath;

    readonly attribute DOMString version;

    readonly attribute boolean show;

    readonly attribute DOMString[] categories;

    readonly attribute Date installDate;

    readonly attribute long size raises(<ref>WebAPIException</ref>);

    readonly attribute <ref>PackageId</ref> packageId;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the general information available to an installed application.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Application::ApplicationInformation::id">
        <webidl>    readonly attribute <ref>ApplicationId</ref> id;</webidl>
        <descriptive>
            <brief>
 An attribute to store the identifier of an application for application management.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="ApplicationId"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Application::ApplicationInformation::name">
        <webidl>    readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 An attribute to store the name of an application.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="iconPath" id="::Application::ApplicationInformation::iconPath">
        <webidl>    readonly attribute DOMString iconPath;</webidl>
        <descriptive>
            <brief>
 An attribute to store the icon path of an application.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="version" id="::Application::ApplicationInformation::version">
        <webidl>    readonly attribute DOMString version;</webidl>
        <descriptive>
            <brief>
 An attribute to store the version of an application.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="show" id="::Application::ApplicationInformation::show">
        <webidl>    readonly attribute boolean show;</webidl>
        <descriptive>
            <brief>
 An attribute that determines whether the application information should
be shown (such as in the menus) or not.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="categories" id="::Application::ApplicationInformation::categories">
        <webidl>    readonly attribute DOMString[] categories;</webidl>
        <descriptive>
            <brief>
 An array of attributes to store the categories that the app belongs to.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="installDate" id="::Application::ApplicationInformation::installDate">
        <webidl>    readonly attribute Date installDate;</webidl>
        <descriptive>
            <brief>
 An attribute to store the application install/update time.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
      <Attribute readonly="readonly" name="size" id="::Application::ApplicationInformation::size">
        <webidl>    readonly attribute long size raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the application size (installed space).
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/application.info
            </privilege>
        </descriptive>
        <Type type="long"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="packageId" id="::Application::ApplicationInformation::packageId">
        <webidl>    readonly attribute <ref>PackageId</ref> packageId;</webidl>
        <descriptive>
            <brief>
 An attribute to store the package ID of application.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="PackageId"/>
      </Attribute>
    </Interface>
    <Interface name="ApplicationContext" id="::Application::ApplicationContext">
      <webidl>  [NoInterfaceObject] interface ApplicationContext {

    readonly attribute <ref>ApplicationContextId</ref> id;

    readonly attribute <ref>ApplicationId</ref> appId;

  };</webidl>
      <descriptive>
          <brief>
 This interface defines the information available about a running
application.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Application::ApplicationContext::id">
        <webidl>    readonly attribute <ref>ApplicationContextId</ref> id;</webidl>
        <descriptive>
            <brief>
 An attribute to store the ID of a running application.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="ApplicationContextId"/>
      </Attribute>
      <Attribute readonly="readonly" name="appId" id="::Application::ApplicationContext::appId">
        <webidl>    readonly attribute <ref>ApplicationId</ref> appId;</webidl>
        <descriptive>
            <brief>
 An attribute to store the ID of an installed application.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="ApplicationId"/>
      </Attribute>
    </Interface>
    <Interface name="ApplicationControlData" id="::Application::ApplicationControlData">
      <webidl>  [Constructor(DOMString key, DOMString[] value)]
  interface ApplicationControlData {

    attribute DOMString key;

    attribute DOMString[] value;

  };</webidl>
      <descriptive>
          <brief>
 This interface defines a key/value pair used to pass data
between applications through the <em>ApplicationControl </em>interface.
          </brief>
          <version>
 2.0
          </version>
          <Code> var appControlData = new tizen.ApplicationControlData(&quot;image&quot;, [imagedata1]);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString key, DOMString[] value)</webidl>
          <ArgumentList>
            <Argument name="key">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="value">
              <Type type="array">
                <Type type="DOMString"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="key" id="::Application::ApplicationControlData::key">
        <webidl>    attribute DOMString key;</webidl>
        <descriptive>
            <brief>
 An attribute to store the name of a key.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="value" id="::Application::ApplicationControlData::value">
        <webidl>    attribute DOMString[] value;</webidl>
        <descriptive>
            <brief>
 An attribute to store the value associated with a key.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="ApplicationControl" id="::Application::ApplicationControl">
      <webidl>  [Constructor(DOMString operation, optional DOMString? uri,
               optional DOMString? mime, optional DOMString? category,
               optional <ref>ApplicationControlData</ref>[]? data)]
  interface ApplicationControl {

    attribute DOMString operation;

    attribute DOMString? uri;

    attribute DOMString? mime;

    attribute DOMString? category;

    attribute <ref>ApplicationControlData</ref>[] data;

  };</webidl>
      <descriptive>
          <brief>
 This interface consists of an operation, URI, MIME type,
and data. It describes an action to be performed by other applications
and is passed to launch other applications.
If the system gets the application control request, it finds
the corresponding application to be launched with the delivered application control
and launches the selected application.
          </brief>
          <version>
 2.0
          </version>
          <Code> var appControl =
       new tizen.ApplicationControl(
                  &quot;http://tizen.org/appcontrol/operation/view&quot;,
                  null,
                  &quot;image/jpeg&quot;,
                  null,
                  [new tizen.ApplicationControlData(&quot;images&quot;,
                                                    [imagedata1, imagedata2])] );
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString operation, optional DOMString? uri,
               optional DOMString? mime, optional DOMString? category,
               optional <ref>ApplicationControlData</ref>[]? data)</webidl>
          <ArgumentList>
            <Argument name="operation">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="uri">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="mime">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="category">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="data">
              <Type type="array" nullable="nullable">
                <Type name="ApplicationControlData"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="operation" id="::Application::ApplicationControl::operation">
        <webidl>    attribute DOMString operation;</webidl>
        <descriptive>
            <brief>
 An attribute to store the string that defines the action to be
performed by an application control.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="uri" id="::Application::ApplicationControl::uri">
        <webidl>    attribute DOMString? uri;</webidl>
        <descriptive>
            <brief>
 An attribute to store the URI needed by application control.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="mime" id="::Application::ApplicationControl::mime">
        <webidl>    attribute DOMString? mime;</webidl>
        <descriptive>
            <brief>
 An attribute to store the MIME type of a content.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="category" id="::Application::ApplicationControl::category">
        <webidl>    attribute DOMString? category;</webidl>
        <descriptive>
            <brief>
 An attribute to store the category of the application to be launched.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="data" id="::Application::ApplicationControl::data">
        <webidl>    attribute <ref>ApplicationControlData</ref>[] data;</webidl>
        <descriptive>
            <brief>
 An array of attributes to store the data needed for an application control.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="ApplicationControlData"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="RequestedApplicationControl" id="::Application::RequestedApplicationControl">
      <webidl>  [NoInterfaceObject] interface RequestedApplicationControl {

    readonly attribute <ref>ApplicationControl</ref> appControl;

    readonly attribute <ref>ApplicationId</ref> callerAppId;

    void replyResult(optional <ref>ApplicationControlData</ref>[]? data) raises(<ref>WebAPIException</ref>);

    void replyFailure() raises(<ref>WebAPIException</ref>);

  };</webidl>
      <descriptive>
          <brief>
 This interface has an application control information requested and passed
from other application and is passed to launch other applications. The newly
launched application can get the requested application control through <em>getRequestedAppControl()</em> method, and send the results
to the calling application through the <em>replyResult()</em> method after performing the
required action requested the calling application.
          </brief>
          <version>
 2.0
          </version>
          <Code> var reqAppControl = tizen.application.getCurrentApplication().getRequestedAppControl();
 if (reqAppControl) {
     console.log(&quot;Requester AppID : &quot; + reqAppControl.callerAppId);

     var appControl = reqAppControl.appControl;
     if (appControl.operation == &quot;http://tizen.org/appcontrol/operation/pick&quot;) {
         var data = new tizen.ApplicationControlData(&quot;http://tizen.org/appcontrol/data/selected&quot;, [&quot;Image1.jpg&quot;]);
         reqAppControl.replyResult([data]);
     }
 }
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="appControl" id="::Application::RequestedApplicationControl::appControl">
        <webidl>    readonly attribute <ref>ApplicationControl</ref> appControl;</webidl>
        <descriptive>
            <brief>
 An attribute to store the application control object that describes caller application's request.
It contains the information that the calling application passed to <em>launchAppControl</em>.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ApplicationControl"/>
      </Attribute>
      <Attribute readonly="readonly" name="callerAppId" id="::Application::RequestedApplicationControl::callerAppId">
        <webidl>    readonly attribute <ref>ApplicationId</ref> callerAppId;</webidl>
        <descriptive>
            <brief>
 An attribute to store the caller application's ID
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="ApplicationId"/>
      </Attribute>
      <Operation name="replyResult" id="::Application::RequestedApplicationControl::replyResult">
        <webidl>    void replyResult(optional <ref>ApplicationControlData</ref>[]? data) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sends the results to the caller application.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="data">
            <descriptive>
                <description><p>
 An array of ApplicationControlData objects.
                </p></description>
            </descriptive>
            <Type type="array" nullable="nullable">
              <Type name="ApplicationControlData"/>
            </Type>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotFoundError, if the caller app is not alive or there is no response from the caller app
                </p></description>
                <description><p>
 with error type UnknownError, if the reply request fails because of an unknown error
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="replyFailure" id="::Application::RequestedApplicationControl::replyFailure">
        <webidl>    void replyFailure() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Notifies the calling application that the application failed
to perform the requested action.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the caller app is not alive or there is no response from the caller app
                </p></description>
                <description><p>
 with error type UnknownError, if the reply request fails because of an unknown error
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="ApplicationCertificate" id="::Application::ApplicationCertificate">
      <webidl>  [NoInterfaceObject] interface ApplicationCertificate {

    readonly attribute DOMString type;

    readonly attribute DOMString value;

  };</webidl>
      <descriptive>
          <brief>
 This interface defines the certificate information of an installed application.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="type" id="::Application::ApplicationCertificate::type">
        <webidl>    readonly attribute DOMString type;</webidl>
        <descriptive>
            <brief>
 An attribute to store the type of the application certificate.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="value" id="::Application::ApplicationCertificate::value">
        <webidl>    readonly attribute DOMString value;</webidl>
        <descriptive>
            <brief>
 An attribute to store the value of the application certificate.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="ApplicationMetaData" id="::Application::ApplicationMetaData">
      <webidl>  [NoInterfaceObject] interface ApplicationMetaData {

    readonly attribute DOMString key;

    readonly attribute DOMString value;

  };</webidl>
      <descriptive>
          <brief>
 This interface defines the meta data of an installed application.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="key" id="::Application::ApplicationMetaData::key">
        <webidl>    readonly attribute DOMString key;</webidl>
        <descriptive>
            <brief>
 An attribute to store the key of the application meta data.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="value" id="::Application::ApplicationMetaData::value">
        <webidl>    readonly attribute DOMString value;</webidl>
        <descriptive>
            <brief>
 An attribute to store the value of the application meta data.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="ApplicationInformationArraySuccessCallback" id="::Application::ApplicationInformationArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ApplicationInformationArraySuccessCallback {
    void onsuccess(<ref>ApplicationInformation</ref>[] informationArray);
  };</webidl>
      <descriptive>
          <brief>
 This interface invokes the success callback that is invoked when the installed application list is retrieved.
          </brief>
         <description>
          <p>
This callback interface specifies a success method with an array of
<em>ApplicationInformation </em>objects as an input parameter. It is used in <em>ApplicationManager.getAppsInfo()</em>.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Application::ApplicationInformationArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>ApplicationInformation</ref>[] informationArray);</webidl>
        <descriptive>
            <brief>
 Called when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="informationArray">
            <descriptive>
                <description><p>
 A list of installed applications.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="ApplicationInformation"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="FindAppControlSuccessCallback" id="::Application::FindAppControlSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface FindAppControlSuccessCallback {
    void onsuccess(<ref>ApplicationInformation</ref>[] informationArray, <ref>ApplicationControl</ref> appControl);
  };</webidl>
      <descriptive>
          <brief>
 This interface specified a success callback that is invoked when system finished searching applications which is matched by specific application control .
          </brief>
         <description>
          <p>
This callback interface specifies a success method with an array of
<em>ApplicationInformation </em>objects and application control as an input parameter.
It is used in <em>ApplicationManager.findAppControl()</em>.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Application::FindAppControlSuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>ApplicationInformation</ref>[] informationArray, <ref>ApplicationControl</ref> appControl);</webidl>
        <descriptive>
            <brief>
 Called when the asynchronous call completes successfully.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="informationArray">
            <descriptive>
                <description><p>
 A list of installed applications.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="ApplicationInformation"/>
            </Type>
          </Argument>
          <Argument name="appControl">
            <descriptive>
                <description><p>
 The application control which were passed on <em>ApplicationManager.findAppControl()</em>.
                </p></description>
            </descriptive>
            <Type name="ApplicationControl"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ApplicationContextArraySuccessCallback" id="::Application::ApplicationContextArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ApplicationContextArraySuccessCallback {
    void onsuccess(<ref>ApplicationContext</ref>[] contexts);
  };</webidl>
      <descriptive>
          <brief>
 This callback interface that specifies the success callback that is invoked when the list of running applications is retrieved.
          </brief>
         <description>
          <p>
This callback interface specifies a success method with
an array of <em>ApplicationContext </em>objects as an input parameter. It is used in <em>ApplicationManager.getAppsContext()</em>.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Application::ApplicationContextArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>ApplicationContext</ref>[] contexts);</webidl>
        <descriptive>
            <brief>
 Called when <em>ApplicationManager.getAppsContext() </em>completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contexts">
            <descriptive>
                <description><p>
 A list of running applications.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="ApplicationContext"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ApplicationControlDataArrayReplyCallback" id="::Application::ApplicationControlDataArrayReplyCallback">
      <webidl>  [Callback, NoInterfaceObject] interface ApplicationControlDataArrayReplyCallback {
    void onsuccess(optional <ref>ApplicationControlData</ref>[]? data);

    void onfailure();
  };</webidl>
      <descriptive>
          <brief>
 This callback interface specifies success callbacks that are invoked as a reply from the requested application control within the application control requester.
          </brief>
         <description>
          <p>
This callback interface specifies two methods:
          </p>
          <ul>
            <li>
 <em>onsuccess()</em> - Invoked by the callee application calls <em>RequestedApplicationControl.replyResult()</em>.            </li>
            <li>
 <em>onfailure()</em> - Invoked if the callee application calls <em>RequestedApplicationControl.replyFailure()</em>.            </li>
          </ul>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Application::ApplicationControlDataArrayReplyCallback::onsuccess">
        <webidl>    void onsuccess(optional <ref>ApplicationControlData</ref>[]? data);</webidl>
        <descriptive>
            <brief>
 Called when the callee application calls <em>RequestedApplicationControl.replyResult()</em>.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="data">
            <descriptive>
                <description><p>
 An array of <em>ApplicationControlData </em>objects.
                </p></description>
            </descriptive>
            <Type type="array" nullable="nullable">
              <Type name="ApplicationControlData"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onfailure" id="::Application::ApplicationControlDataArrayReplyCallback::onfailure">
        <webidl>    void onfailure();</webidl>
        <descriptive>
            <brief>
 Called when the callee application calls <em>RequestedApplicationControl.replyFailure()</em>.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Interface name="ApplicationInformationEventCallback" id="::Application::ApplicationInformationEventCallback">
      <webidl>  [Callback, NoInterfaceObject] interface ApplicationInformationEventCallback {
    void oninstalled(<ref>ApplicationInformation</ref> info);

    void onupdated(<ref>ApplicationInformation</ref> info);

    void onuninstalled(<ref>ApplicationId</ref> id);
  };</webidl>
      <descriptive>
          <brief>
 The callback interface to specify for subscribing for notification of changes in the list of installed
applications on a device.
          </brief>
         <description>
          <p>
This callback interface specifies methods that will be invoked when
an application is installed, updated, or uninstalled.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="oninstalled" id="::Application::ApplicationInformationEventCallback::oninstalled">
        <webidl>    void oninstalled(<ref>ApplicationInformation</ref> info);</webidl>
        <descriptive>
            <brief>
 Called when an application is installed.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="info">
            <descriptive>
                <description><p>
 The application information of the installed application.
                </p></description>
            </descriptive>
            <Type name="ApplicationInformation"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onupdated" id="::Application::ApplicationInformationEventCallback::onupdated">
        <webidl>    void onupdated(<ref>ApplicationInformation</ref> info);</webidl>
        <descriptive>
            <brief>
 Called when an application is updated.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="info">
            <descriptive>
                <description><p>
 The application information of the updated application.
                </p></description>
            </descriptive>
            <Type name="ApplicationInformation"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onuninstalled" id="::Application::ApplicationInformationEventCallback::onuninstalled">
        <webidl>    void onuninstalled(<ref>ApplicationId</ref> id);</webidl>
        <descriptive>
            <brief>
 Called when an application is uninstalled.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The ID of the uninstalled application.
                </p></description>
            </descriptive>
            <Type name="ApplicationId"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Bluetooth" id="::Bluetooth">
    <webidl>module Bluetooth {
    typedef DOMString BluetoothAddress;

    typedef DOMString BluetoothUUID;

    enum BluetoothSocketState { &quot;CLOSED&quot;, &quot;OPEN&quot; };

    enum BluetoothProfileType { &quot;HEALTH&quot; };

    enum BluetoothHealthChannelType { &quot;RELIABLE&quot;, &quot;STREAMING&quot; };

    [NoInterfaceObject] interface BluetoothManagerObject {
        readonly attribute <ref>BluetoothManager</ref> bluetooth;
    };
    <ref>Tizen</ref> implements <ref>BluetoothManagerObject</ref>;

    [NoInterfaceObject] interface BluetoothManager {
        readonly attribute <ref>BluetoothClassDeviceMajor</ref> deviceMajor;
        readonly attribute <ref>BluetoothClassDeviceMinor</ref> deviceMinor;
        readonly attribute <ref>BluetoothClassDeviceService</ref> deviceService;
        <ref>BluetoothAdapter</ref> getDefaultAdapter() raises(<ref>WebAPIException</ref>);
    };


    [NoInterfaceObject] interface BluetoothAdapter {
        readonly attribute DOMString name;
        readonly attribute <ref>BluetoothAddress</ref> address;
        readonly attribute boolean powered;
        readonly attribute boolean visible;

        void setName(DOMString name,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void setPowered(boolean state,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void setVisible(boolean mode,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback,
                        optional unsigned short? timeout) raises(<ref>WebAPIException</ref>);

        void setChangeListener(<ref>BluetoothAdapterChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);

        void unsetChangeListener() raises(<ref>WebAPIException</ref>);

        void discoverDevices(<ref>BluetoothDiscoverDevicesSuccessCallback</ref> successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void stopDiscovery(optional <ref>SuccessCallback</ref>? successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void getKnownDevices(<ref>BluetoothDeviceArraySuccessCallback</ref> successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);




        void getDevice(<ref>BluetoothAddress</ref> address,
                       <ref>BluetoothDeviceSuccessCallback</ref> successCallback,
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);




        void createBonding(<ref>BluetoothAddress</ref> address,
                           <ref>BluetoothDeviceSuccessCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void destroyBonding(<ref>BluetoothAddress</ref> address,
                            optional <ref>SuccessCallback</ref>? successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);



        void registerRFCOMMServiceByUUID(<ref>BluetoothUUID</ref> uuid,
                                         DOMString name,
                                         <ref>BluetoothServiceSuccessCallback</ref> successCallback,
                                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        <ref>BluetoothProfileHandler</ref> getBluetoothProfileHandler(<ref>BluetoothProfileType</ref> profileType) raises(<ref>WebAPIException</ref>);

             };
    [NoInterfaceObject] interface BluetoothDevice {
        readonly attribute DOMString name;
        readonly attribute <ref>BluetoothAddress</ref> address;
        readonly attribute <ref>BluetoothClass</ref> deviceClass;
        readonly attribute boolean isBonded;
        readonly attribute boolean isTrusted;
        readonly attribute boolean isConnected;
        readonly attribute <ref>BluetoothUUID</ref>[] uuids;

        void connectToServiceByUUID(<ref>BluetoothUUID</ref> uuid,
                                    <ref>BluetoothSocketSuccessCallback</ref> successCallback,
                                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
    };
    [NoInterfaceObject] interface BluetoothSocket {
        readonly attribute <ref>BluetoothUUID</ref> uuid;
        readonly attribute <ref>BluetoothSocketState</ref> state;
        readonly attribute <ref>BluetoothDevice</ref> peer;
        [TreatNonCallableAsNull] attribute <ref>SuccessCallback</ref>? onmessage raises(<ref>WebAPIException</ref>);
        [TreatNonCallableAsNull] attribute <ref>SuccessCallback</ref>? onclose raises(<ref>WebAPIException</ref>);
        unsigned long writeData(byte[] data) raises(<ref>WebAPIException</ref>);


        byte[] readData() raises(<ref>WebAPIException</ref>);


        void close() raises(<ref>WebAPIException</ref>);
    };

    [NoInterfaceObject] interface BluetoothClass {
        readonly attribute octet major;

        readonly attribute octet minor;

        readonly attribute unsigned short [] services ;

        boolean hasService(unsigned short service) raises(<ref>WebAPIException</ref>);
    };

    [NoInterfaceObject] interface BluetoothClassDeviceMajor {

        const octet MISC = 0x00;
        const octet COMPUTER = 0x01;
        const octet PHONE = 0x02;
        const octet NETWORK = 0x03;
        const octet AUDIO_VIDEO = 0x04;
        const octet PERIPHERAL = 0x05;
        const octet IMAGING = 0x06;
        const octet WEARABLE = 0x07;
        const octet TOY = 0x08;
        const octet HEALTH = 0x09;
        const octet UNCATEGORIZED = 0x1F;
    };

    [NoInterfaceObject] interface BluetoothClassDeviceMinor {
        const octet COMPUTER_UNCATEGORIZED = 0x00;
        const octet COMPUTER_DESKTOP = 0x01;
        const octet COMPUTER_SERVER = 0x02;
        const octet COMPUTER_LAPTOP = 0x03;
        const octet COMPUTER_HANDHELD_PC_OR_PDA = 0x04;
        const octet COMPUTER_PALM_PC_OR_PDA = 0x05;
        const octet COMPUTER_WEARABLE = 0x06;

        const octet PHONE_UNCATEGORIZED = 0x00;
        const octet PHONE_CELLULAR = 0x01;
        const octet PHONE_CORDLESS = 0x02;
        const octet PHONE_SMARTPHONE = 0x03;
        const octet PHONE_MODEM_OR_GATEWAY = 0x04;
        const octet PHONE_ISDN = 0x05;

        const octet AV_UNRECOGNIZED = 0x00;
        const octet AV_WEARABLE_HEADSET = 0x01;
        const octet AV_HANDSFREE = 0x02;
        const octet AV_MICROPHONE = 0x04;
        const octet AV_LOUDSPEAKER = 0x05;
        const octet AV_HEADPHONES = 0x06;
        const octet AV_PORTABLE_AUDIO = 0x07;
        const octet AV_CAR_AUDIO = 0x08;
        const octet AV_SETTOP_BOX = 0x09;
        const octet AV_HIFI = 0x0a;
        const octet AV_VCR = 0x0b;
        const octet AV_VIDEO_CAMERA = 0x0c;
        const octet AV_CAMCORDER = 0x0d;
        const octet AV_MONITOR = 0x0e;
        const octet AV_DISPLAY_AND_LOUDSPEAKER = 0x0f;
        const octet AV_VIDEO_CONFERENCING = 0x10;
        const octet AV_GAMING_TOY = 0x12;

        const octet PERIPHERAL_UNCATEGORIZED = 0;
        const octet PERIPHERAL_KEYBOARD = 0x10;
        const octet PERIPHERAL_POINTING_DEVICE = 0x20;
        const octet PERIPHERAL_KEYBOARD_AND_POINTING_DEVICE = 0x30;
        const octet PERIPHERAL_JOYSTICK = 0x01;
        const octet PERIPHERAL_GAMEPAD = 0x02;
        const octet PERIPHERAL_REMOTE_CONTROL = 0x03;
        const octet PERIPHERAL_SENSING_DEVICE = 0x04;
        const octet PERIPHERAL_DEGITIZER_TABLET = 0x05;
        const octet PERIPHERAL_CARD_READER = 0x06;
        const octet PERIPHERAL_DIGITAL_PEN = 0x07;
        const octet PERIPHERAL_HANDHELD_SCANNER = 0x08;
        const octet PERIPHERAL_HANDHELD_INPUT_DEVICE = 0x09;

        const octet IMAGING_UNCATEGORIZED = 0x00;
        const octet IMAGING_DISPLAY = 0x04;
        const octet IMAGING_CAMERA = 0x08;
        const octet IMAGING_SCANNER = 0x10;
        const octet IMAGING_PRINTER = 0x20;

        const octet WEARABLE_WRITST_WATCH = 0x01;
        const octet WEARABLE_PAGER = 0x02;
        const octet WEARABLE_JACKET = 0x03;
        const octet WEARABLE_HELMET = 0x04;
        const octet WEARABLE_GLASSES = 0x05;

        const octet TOY_ROBOT = 0x01;
        const octet TOY_VEHICLE = 0x02;
        const octet TOY_DOLL = 0x03;
        const octet TOY_CONTROLLER = 0x04;
        const octet TOY_GAME = 0x05;

        const octet HEALTH_UNDEFINED = 0x00;
        const octet HEALTH_BLOOD_PRESSURE_MONITOR = 0x01;
        const octet HEALTH_THERMOMETER = 0x02;
        const octet HEALTH_WEIGHING_SCALE = 0x03;
        const octet HEALTH_GLUCOSE_METER = 0x04;
        const octet HEALTH_PULSE_OXIMETER = 0x05;
        const octet HEALTH_PULSE_RATE_MONITOR = 0x06;
        const octet HEALTH_DATA_DISPLAY = 0x07;
        const octet HEALTH_STEP_COUNTER = 0x08;
        const octet HEALTH_BODY_COMPOSITION_ANALYZER = 0x09;
        const octet HEALTH_PEAK_FLOW_MONITOR = 0x0a;
        const octet HEALTH_MEDICATION_MONITOR = 0x0b;
        const octet HEALTH_KNEE_PROSTHESIS = 0x0c;
        const octet HEALTH_ANKLE_PROSTHESIS = 0x0d;
    };

    [NoInterfaceObject] interface BluetoothClassDeviceService {
        const unsigned short LIMITED_DISCOVERABILITY = 0x0001;
        const unsigned short POSITIONING = 0x0008;
        const unsigned short NETWORKING = 0x0010;
        const unsigned short RENDERING = 0x0020;
        const unsigned short CAPTURING = 0x0040;
        const unsigned short OBJECT_TRANSFER = 0x0080;
        const unsigned short AUDIO = 0x0100;
        const unsigned short TELEPHONY = 0x0200;
        const unsigned short INFORMATION = 0x0400;
    };

    [NoInterfaceObject] interface BluetoothServiceHandler {
        readonly attribute <ref>BluetoothUUID</ref> uuid;
        readonly attribute DOMString name;
        readonly attribute boolean isConnected;
        [TreatNonCallableAsNull] attribute <ref>BluetoothSocketSuccessCallback</ref>? onconnect raises(<ref>WebAPIException</ref>);

        void unregister(optional <ref>SuccessCallback</ref>? successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
    };

    [NoInterfaceObject] interface BluetoothProfileHandler {

        readonly attribute <ref>BluetoothProfileType</ref> profileType;

    };


    [NoInterfaceObject] interface BluetoothHealthProfileHandler : <ref>BluetoothProfileHandler</ref> {

        void registerSinkApplication(unsigned short dataType, DOMString name, <ref>BluetoothHealthApplicationSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void connectToSource(<ref>BluetoothDevice</ref> peer, <ref>BluetoothHealthApplication</ref> application, <ref>BluetoothHealthChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        };


    [NoInterfaceObject] interface BluetoothHealthApplication {

        readonly attribute unsigned short dataType;

        readonly attribute DOMString name;

        [TreatNonCallableAsNull] attribute <ref>BluetoothHealthChannelSuccessCallback</ref>? onconnect raises(<ref>WebAPIException</ref>);

        void unregister(optional <ref>SuccessCallback</ref>? successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    };


    [NoInterfaceObject] interface BluetoothHealthChannel {

        readonly attribute <ref>BluetoothDevice</ref> peer;

        readonly attribute <ref>BluetoothHealthChannelType</ref> channelType;

        readonly attribute <ref>BluetoothHealthApplication</ref> application;

        readonly attribute boolean isConnected;

        void close() raises(<ref>WebAPIException</ref>);

        unsigned long sendData(byte[] data) raises(<ref>WebAPIException</ref>);

        void setListener(<ref>BluetoothHealthChannelChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);

        void unsetListener() raises(<ref>WebAPIException</ref>);

    };


    [Callback, NoInterfaceObject] interface BluetoothAdapterChangeCallback {
        void onstatechanged(boolean powered);
        void onnamechanged(DOMString name);
        void onvisibilitychanged(boolean visible);
    };

    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothDeviceSuccessCallback {
        void onsuccess(<ref>BluetoothDevice</ref> device);
    };

    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothDeviceArraySuccessCallback {
        void onsuccess(<ref>BluetoothDevice</ref>[] devices);
    };

    [Callback, NoInterfaceObject] interface BluetoothDiscoverDevicesSuccessCallback {
        void onstarted();
        void ondevicefound(<ref>BluetoothDevice</ref> device);
        void ondevicedisappeared(<ref>BluetoothAddress</ref> address);
        void onfinished(<ref>BluetoothDevice</ref>[] foundDevices);
    };

    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothSocketSuccessCallback {
        void onsuccess(<ref>BluetoothSocket</ref> socket);
    };

    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothServiceSuccessCallback {
        void onsuccess(<ref>BluetoothServiceHandler</ref> handler);
    };

    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothHealthApplicationSuccessCallback {
        void onsuccess(<ref>BluetoothHealthApplication</ref> application);
    };


    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothHealthChannelSuccessCallback {
        void onsuccess(<ref>BluetoothHealthChannel</ref> channel);
    };

    [Callback, NoInterfaceObject] interface BluetoothHealthChannelChangeCallback {
        void onmessage(byte[] data);

        void onclose();
    };

};</webidl>
    <descriptive>
        <brief>
 This specification defines interfaces and methods to manage Bluetooth.
        </brief>
       <description>
        <p>
The following Bluetooth functionalities are provided:
        </p>
        <ul>
          <li>
Controls local Bluetooth device, that is, turn Bluetooth on/off, etc.          </li>
          <li>
Sets visibility          </li>
          <li>
Discovers nearby Bluetooth devices (Device discovery).          </li>
          <li>
Gets bonded devices information.          </li>
          <li>
Controls bonding.          </li>
          <li>
Connects to a service on a remote device and exchanges data.          </li>
          <li>
Registers a service (RFCOMM) on a local device, which can be consumed by remote devices to exchange data.          </li>
        </ul>
        <p>
For more information on the Bluetooth features, see <a href="../../org.tizen.web.appprogramming/html/guide/communication_guide/bluetooth.htm">Bluetooth Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
        <def-api-feature identifier="http://tizen.org/feature/network.bluetooth">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with Bluetooth feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
    </descriptive>
    <Typedef name="BluetoothAddress" id="::Bluetooth::BluetoothAddress">
      <webidl>    typedef DOMString BluetoothAddress;</webidl>
      <descriptive>
          <brief>
 The address of a Bluetooth device.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="BluetoothUUID" id="::Bluetooth::BluetoothUUID">
      <webidl>    typedef DOMString BluetoothUUID;</webidl>
      <descriptive>
          <brief>
 The UUID of a Bluetooth service.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Enum name="BluetoothSocketState" id="::Bluetooth::BluetoothSocketState">
      <webidl>    enum BluetoothSocketState { &quot;CLOSED&quot;, &quot;OPEN&quot; };</webidl>
      <descriptive>
          <brief>
 The Bluetooth socket state.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="CLOSED">
        <webidl> &quot;CLOSED</webidl>
      </EnumValue>
      <EnumValue stringvalue="OPEN">
        <webidl> &quot;OPEN</webidl>
      </EnumValue>
    </Enum>
    <Enum name="BluetoothProfileType" id="::Bluetooth::BluetoothProfileType">
      <webidl>    enum BluetoothProfileType { &quot;HEALTH&quot; };</webidl>
      <descriptive>
          <brief>
 The Bluetooth profile.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <EnumValue stringvalue="HEALTH">
        <webidl> &quot;HEALTH</webidl>
      </EnumValue>
    </Enum>
    <Enum name="BluetoothHealthChannelType" id="::Bluetooth::BluetoothHealthChannelType">
      <webidl>    enum BluetoothHealthChannelType { &quot;RELIABLE&quot;, &quot;STREAMING&quot; };</webidl>
      <descriptive>
          <brief>
 The channel type of health device profile.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <EnumValue stringvalue="RELIABLE">
        <webidl> &quot;RELIABLE</webidl>
      </EnumValue>
      <EnumValue stringvalue="STREAMING">
        <webidl> &quot;STREAMING</webidl>
      </EnumValue>
    </Enum>
    <Interface name="BluetoothManagerObject" id="::Bluetooth::BluetoothManagerObject">
      <webidl>    [NoInterfaceObject] interface BluetoothManagerObject {
        readonly attribute <ref>BluetoothManager</ref> bluetooth;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen</em> object from the Tizen platform.
          </brief>
         <description>
          <p>
There is a <em>tizen.bluetooth</em> object that allows access to the Bluetooth API.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="bluetooth" id="::Bluetooth::BluetoothManagerObject::bluetooth">
        <webidl>        readonly attribute <ref>BluetoothManager</ref> bluetooth;</webidl>
        <Type name="BluetoothManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="BluetoothManagerObject">
      <webidl>    <ref>Tizen</ref> implements <ref>BluetoothManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="BluetoothManager" id="::Bluetooth::BluetoothManager">
      <webidl>    [NoInterfaceObject] interface BluetoothManager {
        readonly attribute <ref>BluetoothClassDeviceMajor</ref> deviceMajor;
        readonly attribute <ref>BluetoothClassDeviceMinor</ref> deviceMinor;
        readonly attribute <ref>BluetoothClassDeviceService</ref> deviceService;
        <ref>BluetoothAdapter</ref> getDefaultAdapter() raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface provides access to the <em>BluetoothAdapter</em> object.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="deviceMajor" id="::Bluetooth::BluetoothManager::deviceMajor">
        <webidl>        readonly attribute <ref>BluetoothClassDeviceMajor</ref> deviceMajor;</webidl>
        <descriptive>
            <brief>
 An attribute to access to a major device class identifiers of Bluetooth class of device (CoD).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="BluetoothClassDeviceMajor"/>
      </Attribute>
      <Attribute readonly="readonly" name="deviceMinor" id="::Bluetooth::BluetoothManager::deviceMinor">
        <webidl>        readonly attribute <ref>BluetoothClassDeviceMinor</ref> deviceMinor;</webidl>
        <descriptive>
            <brief>
 An attribute to access to a minor device class identifiers of Bluetooth class of device (CoD).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="BluetoothClassDeviceMinor"/>
      </Attribute>
      <Attribute readonly="readonly" name="deviceService" id="::Bluetooth::BluetoothManager::deviceService">
        <webidl>        readonly attribute <ref>BluetoothClassDeviceService</ref> deviceService;</webidl>
        <descriptive>
            <brief>
 Accessor to major service class identifiers of Bluetooth class of device (CoD).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="BluetoothClassDeviceService"/>
      </Attribute>
      <Operation name="getDefaultAdapter" id="::Bluetooth::BluetoothManager::getDefaultAdapter">
        <webidl>        <ref>BluetoothAdapter</ref> getDefaultAdapter() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the default local Bluetooth adapter.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.gap
            </privilege>
            <Code> try {
  var adapter = tizen.bluetooth.getDefaultAdapter() ;
 } catch (err) {
  console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type name="BluetoothAdapter">
          <descriptive>
              <description><p>
 BluetoothAdapter The local <em>BluetoothAdapter </em>object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothAdapter" id="::Bluetooth::BluetoothAdapter">
      <webidl>    [NoInterfaceObject] interface BluetoothAdapter {
        readonly attribute DOMString name;
        readonly attribute <ref>BluetoothAddress</ref> address;
        readonly attribute boolean powered;
        readonly attribute boolean visible;

        void setName(DOMString name,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void setPowered(boolean state,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void setVisible(boolean mode,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback,
                        optional unsigned short? timeout) raises(<ref>WebAPIException</ref>);

        void setChangeListener(<ref>BluetoothAdapterChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);

        void unsetChangeListener() raises(<ref>WebAPIException</ref>);

        void discoverDevices(<ref>BluetoothDiscoverDevicesSuccessCallback</ref> successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void stopDiscovery(optional <ref>SuccessCallback</ref>? successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void getKnownDevices(<ref>BluetoothDeviceArraySuccessCallback</ref> successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);




        void getDevice(<ref>BluetoothAddress</ref> address,
                       <ref>BluetoothDeviceSuccessCallback</ref> successCallback,
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);




        void createBonding(<ref>BluetoothAddress</ref> address,
                           <ref>BluetoothDeviceSuccessCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void destroyBonding(<ref>BluetoothAddress</ref> address,
                            optional <ref>SuccessCallback</ref>? successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);



        void registerRFCOMMServiceByUUID(<ref>BluetoothUUID</ref> uuid,
                                         DOMString name,
                                         <ref>BluetoothServiceSuccessCallback</ref> successCallback,
                                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        <ref>BluetoothProfileHandler</ref> getBluetoothProfileHandler(<ref>BluetoothProfileType</ref> profileType) raises(<ref>WebAPIException</ref>);

             };</webidl>
      <descriptive>
          <brief>
 This interface provides access to control the device's Bluetooth adapter.
          </brief>
         <description>
          <p>
This interface offers methods to control local Bluetooth behavior, such as:
          </p>
          <ul>
            <li>
Turning on/off Bluetooth radio            </li>
            <li>
Changing device visibility            </li>
            <li>
Scanning for remote devices            </li>
            <li>
Accessing known devices            </li>
            <li>
Registering a service in the device service database            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="name" id="::Bluetooth::BluetoothAdapter::name">
        <webidl>        readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 An attribute to store the readable name of the Bluetooth adapter.
            </brief>
            <version>
 1.0
            </version>
            <Code>
 // Access adapter name
 var adapter = tizen.bluetooth.getDefaultAdapter();
 console.log (&quot;Bluetooth adapter name: &quot; + adapter.name);
 </Code>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="address" id="::Bluetooth::BluetoothAdapter::address">
        <webidl>        readonly attribute <ref>BluetoothAddress</ref> address;</webidl>
        <descriptive>
            <brief>
 An attribute to store the unique hardware address of the Bluetooth adapter, also known as the MAC address.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 console.log(&quot;Bluetooth device address: &quot; + adapter.address);
 </Code>
        </descriptive>
        <Type name="BluetoothAddress"/>
      </Attribute>
      <Attribute readonly="readonly" name="powered" id="::Bluetooth::BluetoothAdapter::powered">
        <webidl>        readonly attribute boolean powered;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the current state of the Bluetooth adapter.
This attribute holds one of the following 2 values:
            </brief>
           <description>
            <ul>
              <li>
<var>true</var> - If Bluetooth adapter is currently on              </li>
              <li>
<var>false</var> - If Bluetooth adapter is currently off              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 console.log(&quot;Bluetooth state: &quot; + (adapter.powered ? &quot;On&quot; : &quot;Off&quot;));
 </Code>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="visible" id="::Bluetooth::BluetoothAdapter::visible">
        <webidl>        readonly attribute boolean visible;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the current visibility state of the Bluetooth adapter, that is, whether the local device is discoverable by remote devices or not.
            </brief>
            <version>
 1.0
            </version>
            <Code> // Queries current visible state
 var adapter = tizen.bluetooth.getDefaultAdapter();
 console.log (&quot;Bluetooth Visibility: &quot; + (adapter.visible ? &quot;On&quot; : &quot;Off&quot;));
 </Code>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="setName" id="::Bluetooth::BluetoothAdapter::setName">
        <webidl>        void setName(DOMString name,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the local Bluetooth adapter name.
            </brief>
           <description>
            <p>
Sends a request to Bluetooth hardware to change the name of the local Bluetooth adapter to <em>name</em>.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
 ServiceNotAvailableError: If a Bluetooth device is turned off.               </li>
              <li>
 UnknownError: In any other error case.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.admin
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 function changeName(newName)
 {
      if(adapter.name != newName) {
           // initiate change name
           adapter.setName(newName, function() {
               console.log(&quot;Adapter name changed to &quot; + adapter.name);
           },
           function(e) {
               console.log(&quot;Failed to change name: &quot; + e.message);
           });
      }
 }

 changeName(&quot;myDevice&quot;);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="name">
            <descriptive>
                <description><p>
 The name to set.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setPowered" id="::Bluetooth::BluetoothAdapter::setPowered">
        <webidl>        void setPowered(boolean state,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the state of a Bluetooth adapter to on or off by sending a request to Bluetooth hardware to change the power state.
For most Bluetooth actions, the Bluetooth adapter must be powered on.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error names:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is busy.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.admin
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 function powerOn()
 {
      // If adapter is not powered on
      if(!adapter.powered) {
           // Initiates power on
           adapter.setPowered(true, function() {
               console.log(&quot;Bluetooth powered on success.&quot;);
           },
           function(e) {
               console.log(&quot;Failed to power on Bluetooth: &quot; + e.message);
           });
      }
 }

 function powerOff()
 {
      // If powered on
      if(adapter.powered) {
           // Initiates power off
           adapter.setPowered(false, function() {
               console.log(&quot;Bluetooth powered off successfully.&quot;);
           },
           function(e) {
               console.log(&quot;Failed to power off Bluetooth: &quot; + e.message);
           });
      }
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="state">
            <descriptive>
                <description><p>
 The state to set: <var>true</var> to power on Bluetooth, <var>false</var> to power it off.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke on successful Bluetooth activation/deactivation.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke on failure of a Bluetooth activation/deactivation.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setVisible" id="::Bluetooth::BluetoothAdapter::setVisible">
        <webidl>        void setVisible(boolean mode,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback,
                        optional unsigned short? timeout) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the local device visibility by sending a request to a Bluetooth hardware to change the device visible state to <em>mode</em>.
If <em>mode</em> is <var>true</var>, then the device is visible to other devices, that is, it responds to inquiry calls from remote devices for time period defined (in seconds) by <em>timeout</em>. After the timeout, the device will become invisible.
            </brief>
           <description>
            <p>
If <em>timeout</em> is not passed or an invalid parameter is passed, the <em>timeout </em>defaults to <var>180 </var>seconds (3 minutes). A <em>timeout</em> of <var>0</var> is considered unlimited.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error case occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 platform
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetoothmanager
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 function showMe()
 {
      if (adapter.visible == false) {
          //Shows device
          adapter.setVisible(true,
                             function() { console.log ('Device is visible to other devices for 3 minutes.'); },
                             function(e) { console.log ('Error: ' + e.message + '(' + e.name + ')'); });
      }
      else {
           console.log(&quot;Device is already in discoverable mode.&quot;);
      }
 }

 function hideMe()
 {
     if (adapter.visible) {
          // Hides device
          adapter.setVisible(false,
                             function() { console.log('Device is in-visible now.'); },
                             function(e) { console.log ('Error: ' + e.message + '(' + e.name + ')'); });
     }
     else {
          console.log(&quot;Device is already in invisible mode.&quot;);
     }
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="mode">
            <descriptive>
                <description><p>
 The boolean value to set visibility.
It can either be set to: <var>true</var> - to show the device or <var>false</var> - to hide the device.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when an asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="timeout">
            <descriptive>
                <description><p>
 The visible timeout in seconds, used only when <em>mode</em> is <var>true</var>.
                </p></description>
            </descriptive>
            <Type type="unsigned short" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setChangeListener" id="::Bluetooth::BluetoothAdapter::setChangeListener">
        <webidl>        void setChangeListener(<ref>BluetoothAdapterChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the listener to receive notifications about changes of Bluetooth adapter.
            </brief>
            <version>
 2.2
            </version>
            <Code> var changeListener = {
      onstatechanged: function(powered) {
          console.log (&quot;Power state is changed into: &quot; + powered);
      },
      onnamechanged: function(name) {
          console.log(&quot;Name is changed to: &quot; + name);
      },
      onvisibilitychanged: function(visible) {
          console.log(&quot;Visibility is changed into: &quot; + visible);
      }
 };

 var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.setChangeListener(changeListener);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="listener">
            <descriptive>
                <description><p>
 The Bluetooth Adapter event listener to set.
                </p></description>
            </descriptive>
            <Type name="BluetoothAdapterChangeCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unsetChangeListener" id="::Bluetooth::BluetoothAdapter::unsetChangeListener">
        <webidl>        void unsetChangeListener() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsets the listener, so stop receiving notifications about changes of Bluetooth adapter.
            </brief>
            <version>
 2.2
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 var changeListener = {
      onstatechanged: function(powered) {
          console.log (&quot;Power state is changed into: &quot; + powered);
          if(!powered)
              adapter.unsetChangeListener();
      },
      onnamechanged: function(name) {
          console.log(&quot;Name is changed to: &quot; + name);
      },
      onvisibilitychanged: function(visible) {
          console.log(&quot;Visibility is changed into: &quot; + visible);
      }
 };

 adapter.setChangeListener(changeListener);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="discoverDevices" id="::Bluetooth::BluetoothAdapter::discoverDevices">
        <webidl>        void discoverDevices(<ref>BluetoothDiscoverDevicesSuccessCallback</ref> successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Discovers nearby Bluetooth devices if any, that is, devices within proximity to the local device.
            </brief>
           <description>
            <p>
This method initiates the device discovery process. Depending on the progress of this process the following methods are invoked:
            </p>
            <ul>
              <li>
<em>BluetoothDiscoverDevicesSuccessCallback.onstarted()</em> - when a discovery process starts successfully.              </li>
              <li>
<em>BluetoothDiscoverDevicesSuccessCallback.ondevicefound() </em>- when any device is found in the process and this method is invoked with the device information. If no device is found, this method will never be invoked.              </li>
              <li>
<em>BluetoothDiscoverDevicesSuccessCallback.ondevicedisappeared()</em> - when a device goes out of proximity and this method is invoked with the address of the device.              </li>
              <li>
<em>BluetoothDiscoverDevicesSuccessCallback.onfinished()</em> - when a discovery process is completed.              </li>
            </ul>
            <p>
A discovery process can be canceled anytime, by calling <em>stopDiscovery() </em>on the <em>BluetoothAdapter</em>.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.gap
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 function startDiscovery() {

  var discoverDevicesSuccessCallback = {
      onstarted: function() {
          console.log (&quot;Device discovery started...&quot;);
      },
      ondevicefound: function(device) {
          console.log(&quot;Found device - name: &quot; + device.name + &quot;, Address: &quot;+ device.address);
      },
      ondevicedisappeared: function(address) {
          console.log(&quot;Device disappeared: &quot; + address);
      },
      onfinished: function(devices) {
          console.log(&quot;Found Devices&quot;);
          for (var i = 0; i &#60; devices.length; i++) {
              console.log(&quot;Name: &quot; + devices[i].name + &quot;, Address: &quot; + devices[i].address);
          }
          console.log(&quot;Total: &quot; + devices.length);
      }
  };

  // Starts searching for nearby devices, for about 12 sec.
  adapter.discoverDevices(discoverDevicesSuccessCallback, function(e){
      console.log (&quot;Failed to search devices: &quot; + e.message + &quot;(&quot; + e.name + &quot;)&quot;);
  });
 }

 function onSetPoweredError(e) {
     console.log (&quot;Could not turn on device, reason: &quot; + e.message + &quot;(&quot; + e.name + &quot;)&quot;);
 }

 adapter.setPowered(true, startDiscovery, onSetPoweredError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when an asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="BluetoothDiscoverDevicesSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="stopDiscovery" id="::Bluetooth::BluetoothAdapter::stopDiscovery">
        <webidl>        void stopDiscovery(optional <ref>SuccessCallback</ref>? successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Stops an active device discovery session.
            </brief>
           <description>
            <p>
Device discovery is a heavyweight procedure, hence we recommend stopping discovery as soon as required device is found. This method cancels an active discovery session.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.gap
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 // Calls this method whenever user finds one of the device
 function cancelDiscovery() {
    adapter.stopDiscovery(function() {
        console.log(&quot;Stop discovery success.&quot;);
    },
    function (e) {
        console.log(&quot;Error while stopDiscovery:&quot; + e.message);
    });
 }

 function startDiscovery() {

  var discoverDevicesSuccessCallback = {
      onstarted: function() {
          console.log (&quot;Device discovery started...&quot;) ;
      },
      ondevicefound: function(device) {
          console.log(&quot;Found device - name: &quot; + device.name + &quot;, Address: &quot;+ device.address);
          // Shows the device to user to check if this is the device user is looking for.
          // For example, add this to list view.

          cancelDiscovery();
      },
      ondevicedisappeared: function(address) {
          console.log(&quot;Device disappeared: &quot; + address);
          // Removes from list, as it is no longer valid.
      },
      onfinished: function(devices) {
          console.log(&quot;Found Devices&quot;);
          for (var i = 0; i &#60; devices.length; i++) {
              console.log(&quot;Name: &quot; + devices[i].name + &quot;, Address: &quot; + devices[i].address);
          }
          console.log(&quot;Total: &quot; + devices.length);
      }
  };

  // Starts searching for nearby devices, for about 12 sec.
  adapter.discoverDevices(discoverDevicesSuccessCallback, function(e){
      console.log (&quot;Failed to search devices: &quot; + e.message + &quot;(&quot; + e.name + &quot;)&quot;);
  });
 }

 function onSetPoweredError(e) {
     console.log (&quot;Could not turn on device, reason: &quot; + e.message + &quot;(&quot; + e.name + &quot;)&quot;);
 }

 adapter.setPowered(true, startDiscovery, onSetPoweredError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when an asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getKnownDevices" id="::Bluetooth::BluetoothAdapter::getKnownDevices">
        <webidl>        void getKnownDevices(<ref>BluetoothDeviceArraySuccessCallback</ref> successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets all the known devices that have information stored in the local Bluetooth adapter.
            </brief>
           <description>
            <p>
A known device is one of the following:
            </p>
            <ul>
              <li>
a bonded device              </li>
              <li>
a device found in last inquiry process              </li>
            </ul>
            <p>
On success, it returns the list of currently known devices through <em>BluetoothDeviceArraySuccessCallback</em>.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.gap
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 function onGotDevices(devices) {
    console.log(&quot;Devices&quot;);
    for (var i = 0; i &#60; devices.length; i++) {
        console.log(&quot; Name: &quot; + devices[i].name + &quot;, Address: &quot; + devices[i].address);
    }
    console.log(&quot;Total: &quot; + devices.length);
 }

 function onError(e) {
   console.log (&quot;Error: &quot; + e.message);
 }

 function onBluetoothsetPowered() {
    adapter.getKnownDevices(onGotDevices, onError);
 }

 // Turns on Bluetooth
 adapter.setPowered(true, onBluetoothsetPowered);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke at retrieval of a list of Bluetooth devices that were bonded (paired) to the local Bluetooth adapter.
                </p></description>
            </descriptive>
            <Type name="BluetoothDeviceArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke in case of failure in finding any bonded devices.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getDevice" id="::Bluetooth::BluetoothAdapter::getDevice">
        <webidl>        void getDevice(<ref>BluetoothAddress</ref> address,
                       <ref>BluetoothDeviceSuccessCallback</ref> successCallback,
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the <em>BluetoothDevice</em> object for a given device hardware address.
            </brief>
           <description>
            <p>
This method returns device information stored in the local Bluetooth adapter for the specified device <em>address</em> through
BluetoothDeviceSuccessCallback.
A valid hardware address must be passed, such as &quot;35:F4:59:D1:7A:03&quot;.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 NotFoundError - If there is no device with the given address.              </li>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.gap
            </privilege>
            <Code> function gotDeviceInfo(device) {
    console.log(&quot;Device Name: &quot; + device.name);
    console.log(&quot;Device Address: &quot; + device.address);
    console.log(&quot;Device Class: &quot; + device.deviceClass.major);
    console.log(&quot;Is Bonded: &quot; + (device.isBonded ? &quot;Yes&quot; : &quot;No&quot;));
 }

 function onError(e) {
    console.log (&quot;Could not get device info:&quot; + e.message);
 }

 var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.getDevice(&quot;35:F4:59:D1:7A:03&quot;, gotDeviceInfo, onError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="address">
            <descriptive>
                <description><p>
 The address of a remote Bluetooth device to get.
                </p></description>
            </descriptive>
            <Type name="BluetoothAddress"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when an asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="BluetoothDeviceSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="createBonding" id="::Bluetooth::BluetoothAdapter::createBonding">
        <webidl>        void createBonding(<ref>BluetoothAddress</ref> address,
                           <ref>BluetoothDeviceSuccessCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Creates a bond with a remote device by initiating the bonding process with peer device, using the given MAC address. The remote device must be bonded with the local device in order to connect to services of the remote device and then exchange data with each other.
            </brief>
           <description>
            <p>
If the bonding process is successful, the device information is sent in <em>successCallback</em>.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 NotFoundError - If there is no device with the given address.              </li>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.gap
            </privilege>
            <Code> function onBondingSuccess(device) {
    console.log(&quot;Device Name:&quot; + device.name);
    console.log(&quot;Device Address:&quot; + device.address);
    console.log(&quot;Device Service UUIDs:&quot; + device.uuids.join(&quot;\n&quot;));
 }

 function onError(e) {
    console.log (&quot;Could not create bonding, reason:&quot; + e.message);
 }

 var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.createBonding(&quot;35:F4:59:D1:7A:03&quot;, onBondingSuccess, onError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="address">
            <descriptive>
                <description><p>
 The MAC address of remote Bluetooth address to bond with.
                </p></description>
            </descriptive>
            <Type name="BluetoothAddress"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when an asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="BluetoothDeviceSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="destroyBonding" id="::Bluetooth::BluetoothAdapter::destroyBonding">
        <webidl>        void destroyBonding(<ref>BluetoothAddress</ref> address,
                            optional <ref>SuccessCallback</ref>? successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Destroys the bond with a remote device, that is, this method initiates the process of removing the specified <em>address</em> from the list of bonded devices.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 NotFoundError - If there is no device with the given address.              </li>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.gap
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 function gotDevice(device) {
    if (device.isBonded) {
      // Initiates destroying bonding
      adapter.destroyBonding(device.address, function() {
           console.log(&quot;Succeeded to destroy the bond success with:&quot; + device.address);
       },
       function(e) {
           console.log(&quot;Failed to destroy the bond with &quot; + device.address + &quot;, reason: &quot; + e.message);
       });
    }
 }

 var deviceAddress = &quot;35:F4:59:D1:7A:03&quot;;
 adapter.getDevice(deviceAddress, gotDevice, function(e) {
             console.log(&quot;Failed to get device info for &quot; + deviceAddress + &quot;, reason: &quot; + e.message);
 } );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="address">
            <descriptive>
                <description><p>
 The address of a bonded device.
                </p></description>
            </descriptive>
            <Type name="BluetoothAddress"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when an asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="registerRFCOMMServiceByUUID" id="::Bluetooth::BluetoothAdapter::registerRFCOMMServiceByUUID">
        <webidl>        void registerRFCOMMServiceByUUID(<ref>BluetoothUUID</ref> uuid,
                                         DOMString name,
                                         <ref>BluetoothServiceSuccessCallback</ref> successCallback,
                                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Registers a service record in the device service record database with the specified <em>uuid</em>, <em>name</em>.
            </brief>
           <description>
            <p>
On success of the service registration, it returns a <em>BluetoothServiceHandler</em> object as the first parameter of <em>successCallback</em>, and listens for client connections.
The service handler can be used to be notified on client connections or to unregister the service.
User interaction is mandatory to connect to a registered service.
            </p>
            <p>
If any client(remote device) connects to this service, then <em>BluetoothServiceHandler.onconnect()</em> is invoked with <em>BluetoothSocket</em> object.
            </p>
            <p>
<em>BluetoothServiceHandler.unregister()</em> can be used to unregister the service record from the device service database and stop listening for client connections.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.spp
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 // Holds currently registered service record
 var chatServiceHandler = null;
 // Holds currently open socket
 var serviceSocket = null;

 function chatServiceSuccessCb(recordHandler) {
    console.log(&quot;Chat service registration succeeds!&quot;);
    chatServiceHandler = recordHandler;
    recordHandler.onconnect = function(socket) {
        console.log(&quot;Client connected: &quot; + socket.peer.name + &quot;,&quot; + socket.peer.address);
        serviceSocket = socket;
        // Messages received from remote device
        socket.onmessage = function() {
             var data = socket.readData();
             // Handles message code goes here

        };

        socket.onclose = function() {
            console.log('The socket is closed.');
            serviceSocket = null;
        };
    };
 };

 function publishChatService()
 {
    var CHAT_SERVICE_UUID = &quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;;
    adapter.registerRFCOMMServiceByUUID(CHAT_SERVICE_UUID, &quot;Chat service&quot;, chatServiceSuccessCb,
      // Error handler
      function(e) {
           console.log( &quot;Could not register service record, Error: &quot; + e.message);
      });
 }

 function unregisterChatService()
 {
      if (chatServiceHandler != null) {
          chatServiceHandler.unregister(function() {
               console.log(&quot;Chat service is unregistered&quot;);
               chatServiceHandler = null;
           }, function(e) {
               console.log(&quot;Failed to unregister service: &quot; + e.message);
           });
      }
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="uuid">
            <descriptive>
                <description><p>
 The UUID of the service, to which clients connects.
                </p></description>
            </descriptive>
            <Type name="BluetoothUUID"/>
          </Argument>
          <Argument name="name">
            <descriptive>
                <description><p>
 The Name of a service.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke on successful service registration.
                </p></description>
            </descriptive>
            <Type name="BluetoothServiceSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getBluetoothProfileHandler" id="::Bluetooth::BluetoothAdapter::getBluetoothProfileHandler">
        <webidl>        <ref>BluetoothProfileHandler</ref> getBluetoothProfileHandler(<ref>BluetoothProfileType</ref> profileType) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the profile handler for the given type.
            </brief>
            <version>
 2.2
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var healthProfileHandler = adapter.getBluetoothProfileHandler(&quot;HEALTH&quot;);
 </Code>
        </descriptive>
        <Type name="BluetoothProfileHandler"/>
        <ArgumentList>
          <Argument name="profileType">
            <descriptive>
                <description><p>
 The type of Bluetooth Profile.
                </p></description>
            </descriptive>
            <Type name="BluetoothProfileType"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothDevice" id="::Bluetooth::BluetoothDevice">
      <webidl>    [NoInterfaceObject] interface BluetoothDevice {
        readonly attribute DOMString name;
        readonly attribute <ref>BluetoothAddress</ref> address;
        readonly attribute <ref>BluetoothClass</ref> deviceClass;
        readonly attribute boolean isBonded;
        readonly attribute boolean isTrusted;
        readonly attribute boolean isConnected;
        readonly attribute <ref>BluetoothUUID</ref>[] uuids;

        void connectToServiceByUUID(<ref>BluetoothUUID</ref> uuid,
                                    <ref>BluetoothSocketSuccessCallback</ref> successCallback,
                                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface represents a remote Bluetooth device.
          </brief>
         <description>
          <p>
A <em>BluetoothDevice</em> object can be retrieved using one of the following APIs:
          </p>
          <ul>
            <li>
 BluetoothAdapter.getDevice()            </li>
            <li>
 BluetoothAdapter.getKnownDevices()             </li>
            <li>
 BluetoothAdapter.discoverDevices()             </li>
            <li>
 BluetoothAdapter.createBonding()             </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="name" id="::Bluetooth::BluetoothDevice::name">
        <webidl>        readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 An attribute to store the readable name of this remote device.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.getDevice(&quot;11:22:33:44:55:66&quot;, function(device) {
    console.log(&quot;Device Name: &quot; + device.name);
 });
 </Code>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="address" id="::Bluetooth::BluetoothDevice::address">
        <webidl>        readonly attribute <ref>BluetoothAddress</ref> address;</webidl>
        <descriptive>
            <brief>
 An attribute to store the hardware address of this remote device.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.getDevice(&quot;11:22:33:44:55:66&quot;, function(device) {
    console.log(&quot;Device Address: &quot; + device.address);
 });
 </Code>
        </descriptive>
        <Type name="BluetoothAddress"/>
      </Attribute>
      <Attribute readonly="readonly" name="deviceClass" id="::Bluetooth::BluetoothDevice::deviceClass">
        <webidl>        readonly attribute <ref>BluetoothClass</ref> deviceClass;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate a device class, which represents the type of the device and the services it provides.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.getDevice(&quot;11:22:33:44:55:66&quot;, function(device) {
    console.log(&quot;Device Major Class: &quot; + device.deviceClass.major);
 });
 </Code>
        </descriptive>
        <Type name="BluetoothClass"/>
      </Attribute>
      <Attribute readonly="readonly" name="isBonded" id="::Bluetooth::BluetoothDevice::isBonded">
        <webidl>        readonly attribute boolean isBonded;</webidl>
        <descriptive>
            <brief>
 An attribute to check the bond state of this remote device with the local device.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.getDevice(&quot;11:22:33:44:55:66&quot;, function(device) {
    console.log(&quot;Is bonded: &quot; + (device.isBonded ? &quot;Yes&quot; : &quot;No&quot;));
 });
 </Code>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="isTrusted" id="::Bluetooth::BluetoothDevice::isTrusted">
        <webidl>        readonly attribute boolean isTrusted;</webidl>
        <descriptive>
            <brief>
 An attribute to check whether the local device recognizes this remote device as a trusted device or not.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.getDevice(&quot;11:22:33:44:55:66&quot;, function(device) {
    console.log(&quot;Is trusted: &quot; + (device.isTrusted ? &quot;Yes&quot; : &quot;No&quot;));
 });
 </Code>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="isConnected" id="::Bluetooth::BluetoothDevice::isConnected">
        <webidl>        readonly attribute boolean isConnected;</webidl>
        <descriptive>
            <brief>
 An attribute to check the connection state of this remote device with the local device.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.getDevice(&quot;11:22:33:44:55:66&quot;, function(device) {
    console.log(&quot;Is connected: &quot; + (device.isConnected ? &quot;Yes&quot; : &quot;No&quot;));
 });
 </Code>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="uuids" id="::Bluetooth::BluetoothDevice::uuids">
        <webidl>        readonly attribute <ref>BluetoothUUID</ref>[] uuids;</webidl>
        <descriptive>
            <brief>
 An attribute to store the list of 128 bit service UUIDs available on this remote device.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var CHAT_SERVICE_UUID = &quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;;
 adapter.getDevice(&quot;11:22:33:44:55:66&quot;, function(device) {
    var uuids = device.uuids;
    var services = &quot;&quot;;
    for (var i = 0; i &#60; uuids.length; i++) {
        services += uuids[i] + &quot;\n&quot;;
    }
    console.log (&quot;Services found: &quot; + services);
    if (uuids.indexOf(CHAT_SERVICE_UUID) != -1) {
        // Connects to service
        device.connectToServiceByUUID(CHAT_SERVICE_UUID, function(socket) {
            //
            // Connected to service, handle socket
            //
        }, function (e) {
            console.log(&quot;Could not connect to chat service !!!. Error: &quot; + e.message);
        });
    }
 });
 </Code>
        </descriptive>
        <Type type="array">
          <Type name="BluetoothUUID"/>
        </Type>
      </Attribute>
      <Operation name="connectToServiceByUUID" id="::Bluetooth::BluetoothDevice::connectToServiceByUUID">
        <webidl>        void connectToServiceByUUID(<ref>BluetoothUUID</ref> uuid,
                                    <ref>BluetoothSocketSuccessCallback</ref> successCallback,
                                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Connects to a specified service identified by <em>uuid</em> on this remote device.
            </brief>
           <description>
            <p>
If opening a connection is successful, then a <em>BluetoothSocket</em> object with open state is sent using <em>successCallback</em>, through which data can be exchanged by both devices.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 NotFoundError - If there is no service with the specified <em>uuid</em>.              </li>
              <li>
 InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.spp
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var clientSocket = null;

 // Calls a method that is invoked when user wants to send a message to a remote device
 function sendMessage(msg) {
    // Validates socket state, if everything is ok.
    if (clientSocket != null &amp;&amp; clientSocket.state == &quot;OPEN&quot;) {
        // Sends the message
        clientSocket.writeData(msg);
    }
 }

 // Calls a method that is invoked when a socket is open
 function onSocketConnected(socket) {
    clientSocket = socket;
    console.log(&quot;Opening a socket successfully!!!&quot;);
    socket.onmessage = function () {
        var data = socket.readData();
        var recvmsg = &quot;&quot;;
        for (var i = 0; i &#60; data.length; i++)
        {
           recvmsg += String.fromCharCode(data[i]);
        }
        console.log(&quot;server msg >> &quot; + recvmsg);
    };

    socket.onclose = function() {
        console.log(&quot;socket disconnected.&quot;);
    };
 }

 function onDeviceReady(device) {
    // Validates device and service uuid
    if (device.uuids.indexOf(&quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;) != -1) {
       // Opens socket
       device.connectToServiceByUUID(&quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;, onSocketConnected, function(e) {
           console.log (&quot;Error connecting to service. Reason: &quot; + e.message);
        });
    }
    else {
        console.log (&quot;Chat service is not supported by this device&quot;);
    }
 }

 function onSetPowered() {
    // Gets the BluetoothDevice object
    adapter.getDevice(&quot;35:F4:59:D1:7A:03&quot;, onDeviceReady, function(e) { console.log(&quot;Error: &quot; + e.message); });
 }

 adapter.setPowered(true, onSetPowered, function(e) {console.log (&quot;Could not turn on Bluetooth adapter. reason: &quot; + e.message); });
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="uuid">
            <descriptive>
                <description><p>
 The 128 bit unique identifier, which represents the service record on the device.
                </p></description>
            </descriptive>
            <Type name="BluetoothUUID"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when an asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="BluetoothSocketSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when opening of a socket fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothSocket" id="::Bluetooth::BluetoothSocket">
      <webidl>    [NoInterfaceObject] interface BluetoothSocket {
        readonly attribute <ref>BluetoothUUID</ref> uuid;
        readonly attribute <ref>BluetoothSocketState</ref> state;
        readonly attribute <ref>BluetoothDevice</ref> peer;
        [TreatNonCallableAsNull] attribute <ref>SuccessCallback</ref>? onmessage raises(<ref>WebAPIException</ref>);
        [TreatNonCallableAsNull] attribute <ref>SuccessCallback</ref>? onclose raises(<ref>WebAPIException</ref>);
        unsigned long writeData(byte[] data) raises(<ref>WebAPIException</ref>);


        byte[] readData() raises(<ref>WebAPIException</ref>);


        void close() raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface represents the Bluetooth socket.
          </brief>
         <description>
          <p>
The socket object is created by <em>BluetoothDevice.connectToServiceByUUID()</em> or <em>BluetoothAdapter.registerRFCOMMServiceByUUID()</em>.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="uuid" id="::Bluetooth::BluetoothSocket::uuid">
        <webidl>        readonly attribute <ref>BluetoothUUID</ref> uuid;</webidl>
        <descriptive>
            <brief>
 An attribute to store the service UUID to which this socket is connected.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="BluetoothUUID"/>
      </Attribute>
      <Attribute readonly="readonly" name="state" id="::Bluetooth::BluetoothSocket::state">
        <webidl>        readonly attribute <ref>BluetoothSocketState</ref> state;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the socket state.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="BluetoothSocketState"/>
      </Attribute>
      <Attribute readonly="readonly" name="peer" id="::Bluetooth::BluetoothSocket::peer">
        <webidl>        readonly attribute <ref>BluetoothDevice</ref> peer;</webidl>
        <descriptive>
            <brief>
 The peer device to which this socket is connected.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="BluetoothDevice"/>
      </Attribute>
      <Attribute name="onmessage" id="::Bluetooth::BluetoothSocket::onmessage">
        <webidl>        [TreatNonCallableAsNull] attribute <ref>SuccessCallback</ref>? onmessage raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The success callback to be invoked when an incoming message is received from the peer.
By default, this attribute is set to null.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <ExtendedAttributeList>
          <ExtendedAttribute name="TreatNonCallableAsNull">
            <webidl>TreatNonCallableAsNull</webidl>
          </ExtendedAttribute>
        </ExtendedAttributeList>
        <Type name="SuccessCallback" nullable="nullable"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input attribute is not compatible with the expected type for this attribute.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute name="onclose" id="::Bluetooth::BluetoothSocket::onclose">
        <webidl>        [TreatNonCallableAsNull] attribute <ref>SuccessCallback</ref>? onclose raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The success callback to be invoked when the socket is closed.
By default, this attribute is set to null.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <ExtendedAttributeList>
          <ExtendedAttribute name="TreatNonCallableAsNull">
            <webidl>TreatNonCallableAsNull</webidl>
          </ExtendedAttribute>
        </ExtendedAttributeList>
        <Type name="SuccessCallback" nullable="nullable"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input attribute is not compatible with the expected type for this attribute.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Operation name="writeData" id="::Bluetooth::BluetoothSocket::writeData">
        <webidl>        unsigned long writeData(byte[] data) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Writes data as a sequence of bytes onto the socket and returns the number of bytes actually written.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.spp
            </privilege>
            <Code>
 var adapter = tizen.bluetooth.getDefaultAdapter();

 function onSocketConnected(socket) {
    console.log (&quot;Opened connection to remote device&quot;);
    socket.onmessage = function () {
      console.log (&quot;Message received: &quot; + socket.readData());
    };

    socket.onclose = function() {
       console.log(&quot;Socket closed with &quot; + socket.peer.name);
    };

    // Sends data to peer.
    var textmsg = &quot;Test&quot;;
    var sendtextmsg = new Array();
    for (var i = 0; i &#60; textmsg.length; i++)
    {
        sendtextmsg[i] = textmsg.charCodeAt(i);
    }
    socket.writeData (sendtextmsg);
 }

 function onSocketError(e) {
    console.log (&quot;Error connecting to service. Reason: &quot; + e.message);
 }

 function onDeviceReady(device) {
    // Validates device and service uuid
    if (device.uuids.indexOf(&quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;) != -1) {
       // Opens socket
       device.connectToServiceByUUID(&quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;, onSocketConnected, onSocketError );
    }
 }
 function onSetPowered() {
    // Gets the BluetoothDevice object
    adapter.getDevice(&quot;35:F4:59:D1:7A:03&quot;, onDeviceReady, function(e) { console.log(&quot;Error: &quot; + e.message); });
 }

 adapter.setPowered(true, onSetPowered, function(e) {console.log (&quot;Could not turn on Bluetooth adapter. reason: &quot; + e.message); });
 </Code>
        </descriptive>
        <Type type="unsigned long">
          <descriptive>
              <description><p>
 unsigned long The number of bytes actually sent.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="data">
            <descriptive>
                <description><p>
 The data to send.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameters not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="readData" id="::Bluetooth::BluetoothSocket::readData">
        <webidl>        byte[] readData() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Reads data from the socket.
            </brief>
           <description>
            <p>
This method should be called only in the <em>BluetoothSocket.onmessage</em> handler, that is, when data is ready on the socket.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.spp
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 function onError(e) {
    console.log (&quot;Error connecting to service. Reason: &quot; + e.message);
 }

 function onSocketConnected(socket) {
    console.log (&quot;Opening socket success!!!&quot;);

    socket.onmessage = function() {
      //  Has got a message from peer, reads it
      var data = socket.readData();

      //
      // Code to evaluate message goes here
      //
    };

    socket.onclose = function() {
       console.log(&quot;Socket closed with &quot; + socket.peer.name);
    };
 }

 function onDeviceReady(device) {
    // Validates device and service uuid
    if (device.uuids.indexOf(&quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;) != -1) {
       // Opens socket
       device.connectToServiceByUUID(&quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;, onSocketConnected, onError);
    }
 }
 function onSetPowered() {
    // Gets the BluetoothDevice object
    adapter.getDevice(&quot;35:F4:59:D1:7A:03&quot;, onDeviceReady, function(e) { console.log(&quot;Error: &quot; + e.message); });
 }

 adapter.setPowered(true, onSetPowered, function(e) {console.log (&quot;Could not turn on Bluetooth adapter. reason: &quot; + e.message); });
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 byte[] The sequence of bytes successfully read.
              </p></description>
          </descriptive>
          <Type type="byte"/>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="close" id="::Bluetooth::BluetoothSocket::close">
        <webidl>        void close() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Closes the socket.
            </brief>
           <description>
            <p>
<b>BluetoothSocket.state</b> changes to <var>CLOSED</var>, and <em>BluetoothSocket.onclose()</em> is invoked on success.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.spp
            </privilege>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothClass" id="::Bluetooth::BluetoothClass">
      <webidl>    [NoInterfaceObject] interface BluetoothClass {
        readonly attribute octet major;

        readonly attribute octet minor;

        readonly attribute unsigned short [] services ;

        boolean hasService(unsigned short service) raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface represents Bluetooth Class of Device/Service(CoD).
          </brief>
         <description>
          <p>
Bluetooth device class describes the characteristics and capabilities of a device.
          </p>
          <p>
Bluetooth CoD is a 24 bit integer created by the union of three components:
          </p>
          <ul>
            <li>
Exactly one <b>Major Device Class</b>(bits 8-12 of CoD) - This is the highest level of granularity for defining a Bluetooth Device.            </li>
            <li>
Exactly one <b>Minor Device Class</b>(bits 2-7 of CoD) - This is to be interpreted only in the context of the Major Device Class. Thus, the meaning of these bits may change, depending on the value of 'Major Device Class'.             </li>
            <li>
Zero or more <b>Major Service Classes</b>(bits 13-23) - Represents the services supported by the device.            </li>
          </ul>
          <p>
The Major and Minor classes are intended to define a general family of devices with which any particular implementation wishes to be associated.
No assumptions should be made about specific functionality or characteristics of any application, based solely on the assignment of a Major or minor device class.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="major" id="::Bluetooth::BluetoothClass::major">
        <webidl>        readonly attribute octet major;</webidl>
        <descriptive>
            <brief>
 The major device class and it refers to the <em>BluetoothClassDeviceMajor</em> interface for the list of possible
values.
            </brief>
            <version>
 1.0
            </version>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();

 function evaluateDevice(address) {
    adapter.getDevice(address, function(device) {
        if (device.deviceClass.major == tizen.bluetooth.deviceMajor.COMPUTER) {
            // Shows computer icon for this device
            console.log(&quot;Device is computer&quot;);
        } else if (device.deviceClass.major == tizen.bluetooth.deviceMajor.PHONE) {
            // Shows phone icon
            console.log(&quot;Device is a Phone&quot;);
        }
    }, function(e) {
        console.log(&quot;Couldn't get any device with the given address: &quot; + e.message);
    });
 }

 evaluateDevice(&quot;11:22:33:44:55:66&quot;);

 </Code>
        </descriptive>
        <Type type="octet"/>
      </Attribute>
      <Attribute readonly="readonly" name="minor" id="::Bluetooth::BluetoothClass::minor">
        <webidl>        readonly attribute octet minor;</webidl>
        <descriptive>
            <brief>
 The minor device class and it refer to the <em>BluetoothClassDeviceMinor</em> interface for the list of possible values.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="octet"/>
      </Attribute>
      <Attribute readonly="readonly" name="services" id="::Bluetooth::BluetoothClass::services">
        <webidl>        readonly attribute unsigned short [] services ;</webidl>
        <descriptive>
            <brief>
 The services provided by this device and it refers to the <em>BluetoothClassDeviceService</em> interface for the list of possible
values.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="unsigned short"/>
        </Type>
      </Attribute>
      <Operation name="hasService" id="::Bluetooth::BluetoothClass::hasService">
        <webidl>        boolean hasService(unsigned short service) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Checks whether the given service exists in the <em>services</em>.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.gap
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 adapter.getDevice(&quot;12:34:56:78:9A:BC&quot;, function(device) {
    if (device.deviceClass.hasService(tizen.bluetooth.deviceService.POSITIONING)) {
         console.log(&quot;Device supports Positioning service&quot;);
    }
 }, function(e) {
    console.log(&quot;Couldn't get device for given address: &quot; + e.message);
 });
 </Code>
        </descriptive>
        <Type type="boolean"/>
        <ArgumentList>
          <Argument name="service">
            <descriptive>
                <description><p>
 The service to check.
                </p></description>
            </descriptive>
            <Type type="unsigned short"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothClassDeviceMajor" id="::Bluetooth::BluetoothClassDeviceMajor">
      <webidl>    [NoInterfaceObject] interface BluetoothClassDeviceMajor {

        const octet MISC = 0x00;
        const octet COMPUTER = 0x01;
        const octet PHONE = 0x02;
        const octet NETWORK = 0x03;
        const octet AUDIO_VIDEO = 0x04;
        const octet PERIPHERAL = 0x05;
        const octet IMAGING = 0x06;
        const octet WEARABLE = 0x07;
        const octet TOY = 0x08;
        const octet HEALTH = 0x09;
        const octet UNCATEGORIZED = 0x1F;
    };</webidl>
      <descriptive>
          <brief>
 This interface holds the identifiers for major device classes of Bluetooth CoD.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Const name="MISC" value="0x00" id="::Bluetooth::BluetoothClassDeviceMajor::MISC">
        <webidl>        const octet MISC = 0x00;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="COMPUTER" value="0x01" id="::Bluetooth::BluetoothClassDeviceMajor::COMPUTER">
        <webidl>        const octet COMPUTER = 0x01;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PHONE" value="0x02" id="::Bluetooth::BluetoothClassDeviceMajor::PHONE">
        <webidl>        const octet PHONE = 0x02;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="NETWORK" value="0x03" id="::Bluetooth::BluetoothClassDeviceMajor::NETWORK">
        <webidl>        const octet NETWORK = 0x03;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AUDIO_VIDEO" value="0x04" id="::Bluetooth::BluetoothClassDeviceMajor::AUDIO_VIDEO">
        <webidl>        const octet AUDIO_VIDEO = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL" value="0x05" id="::Bluetooth::BluetoothClassDeviceMajor::PERIPHERAL">
        <webidl>        const octet PERIPHERAL = 0x05;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="IMAGING" value="0x06" id="::Bluetooth::BluetoothClassDeviceMajor::IMAGING">
        <webidl>        const octet IMAGING = 0x06;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="WEARABLE" value="0x07" id="::Bluetooth::BluetoothClassDeviceMajor::WEARABLE">
        <webidl>        const octet WEARABLE = 0x07;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="TOY" value="0x08" id="::Bluetooth::BluetoothClassDeviceMajor::TOY">
        <webidl>        const octet TOY = 0x08;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH" value="0x09" id="::Bluetooth::BluetoothClassDeviceMajor::HEALTH">
        <webidl>        const octet HEALTH = 0x09;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="UNCATEGORIZED" value="0x1F" id="::Bluetooth::BluetoothClassDeviceMajor::UNCATEGORIZED">
        <webidl>        const octet UNCATEGORIZED = 0x1F;</webidl>
        <Type type="octet"/>
      </Const>
    </Interface>
    <Interface name="BluetoothClassDeviceMinor" id="::Bluetooth::BluetoothClassDeviceMinor">
      <webidl>    [NoInterfaceObject] interface BluetoothClassDeviceMinor {
        const octet COMPUTER_UNCATEGORIZED = 0x00;
        const octet COMPUTER_DESKTOP = 0x01;
        const octet COMPUTER_SERVER = 0x02;
        const octet COMPUTER_LAPTOP = 0x03;
        const octet COMPUTER_HANDHELD_PC_OR_PDA = 0x04;
        const octet COMPUTER_PALM_PC_OR_PDA = 0x05;
        const octet COMPUTER_WEARABLE = 0x06;

        const octet PHONE_UNCATEGORIZED = 0x00;
        const octet PHONE_CELLULAR = 0x01;
        const octet PHONE_CORDLESS = 0x02;
        const octet PHONE_SMARTPHONE = 0x03;
        const octet PHONE_MODEM_OR_GATEWAY = 0x04;
        const octet PHONE_ISDN = 0x05;

        const octet AV_UNRECOGNIZED = 0x00;
        const octet AV_WEARABLE_HEADSET = 0x01;
        const octet AV_HANDSFREE = 0x02;
        const octet AV_MICROPHONE = 0x04;
        const octet AV_LOUDSPEAKER = 0x05;
        const octet AV_HEADPHONES = 0x06;
        const octet AV_PORTABLE_AUDIO = 0x07;
        const octet AV_CAR_AUDIO = 0x08;
        const octet AV_SETTOP_BOX = 0x09;
        const octet AV_HIFI = 0x0a;
        const octet AV_VCR = 0x0b;
        const octet AV_VIDEO_CAMERA = 0x0c;
        const octet AV_CAMCORDER = 0x0d;
        const octet AV_MONITOR = 0x0e;
        const octet AV_DISPLAY_AND_LOUDSPEAKER = 0x0f;
        const octet AV_VIDEO_CONFERENCING = 0x10;
        const octet AV_GAMING_TOY = 0x12;

        const octet PERIPHERAL_UNCATEGORIZED = 0;
        const octet PERIPHERAL_KEYBOARD = 0x10;
        const octet PERIPHERAL_POINTING_DEVICE = 0x20;
        const octet PERIPHERAL_KEYBOARD_AND_POINTING_DEVICE = 0x30;
        const octet PERIPHERAL_JOYSTICK = 0x01;
        const octet PERIPHERAL_GAMEPAD = 0x02;
        const octet PERIPHERAL_REMOTE_CONTROL = 0x03;
        const octet PERIPHERAL_SENSING_DEVICE = 0x04;
        const octet PERIPHERAL_DEGITIZER_TABLET = 0x05;
        const octet PERIPHERAL_CARD_READER = 0x06;
        const octet PERIPHERAL_DIGITAL_PEN = 0x07;
        const octet PERIPHERAL_HANDHELD_SCANNER = 0x08;
        const octet PERIPHERAL_HANDHELD_INPUT_DEVICE = 0x09;

        const octet IMAGING_UNCATEGORIZED = 0x00;
        const octet IMAGING_DISPLAY = 0x04;
        const octet IMAGING_CAMERA = 0x08;
        const octet IMAGING_SCANNER = 0x10;
        const octet IMAGING_PRINTER = 0x20;

        const octet WEARABLE_WRITST_WATCH = 0x01;
        const octet WEARABLE_PAGER = 0x02;
        const octet WEARABLE_JACKET = 0x03;
        const octet WEARABLE_HELMET = 0x04;
        const octet WEARABLE_GLASSES = 0x05;

        const octet TOY_ROBOT = 0x01;
        const octet TOY_VEHICLE = 0x02;
        const octet TOY_DOLL = 0x03;
        const octet TOY_CONTROLLER = 0x04;
        const octet TOY_GAME = 0x05;

        const octet HEALTH_UNDEFINED = 0x00;
        const octet HEALTH_BLOOD_PRESSURE_MONITOR = 0x01;
        const octet HEALTH_THERMOMETER = 0x02;
        const octet HEALTH_WEIGHING_SCALE = 0x03;
        const octet HEALTH_GLUCOSE_METER = 0x04;
        const octet HEALTH_PULSE_OXIMETER = 0x05;
        const octet HEALTH_PULSE_RATE_MONITOR = 0x06;
        const octet HEALTH_DATA_DISPLAY = 0x07;
        const octet HEALTH_STEP_COUNTER = 0x08;
        const octet HEALTH_BODY_COMPOSITION_ANALYZER = 0x09;
        const octet HEALTH_PEAK_FLOW_MONITOR = 0x0a;
        const octet HEALTH_MEDICATION_MONITOR = 0x0b;
        const octet HEALTH_KNEE_PROSTHESIS = 0x0c;
        const octet HEALTH_ANKLE_PROSTHESIS = 0x0d;
    };</webidl>
      <descriptive>
          <brief>
 This interface holds the identifiers for minor device classes of Bluetooth CoD.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Const name="COMPUTER_UNCATEGORIZED" value="0x00" id="::Bluetooth::BluetoothClassDeviceMinor::COMPUTER_UNCATEGORIZED">
        <webidl>        const octet COMPUTER_UNCATEGORIZED = 0x00;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="COMPUTER_DESKTOP" value="0x01" id="::Bluetooth::BluetoothClassDeviceMinor::COMPUTER_DESKTOP">
        <webidl>        const octet COMPUTER_DESKTOP = 0x01;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="COMPUTER_SERVER" value="0x02" id="::Bluetooth::BluetoothClassDeviceMinor::COMPUTER_SERVER">
        <webidl>        const octet COMPUTER_SERVER = 0x02;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="COMPUTER_LAPTOP" value="0x03" id="::Bluetooth::BluetoothClassDeviceMinor::COMPUTER_LAPTOP">
        <webidl>        const octet COMPUTER_LAPTOP = 0x03;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="COMPUTER_HANDHELD_PC_OR_PDA" value="0x04" id="::Bluetooth::BluetoothClassDeviceMinor::COMPUTER_HANDHELD_PC_OR_PDA">
        <webidl>        const octet COMPUTER_HANDHELD_PC_OR_PDA = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="COMPUTER_PALM_PC_OR_PDA" value="0x05" id="::Bluetooth::BluetoothClassDeviceMinor::COMPUTER_PALM_PC_OR_PDA">
        <webidl>        const octet COMPUTER_PALM_PC_OR_PDA = 0x05;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="COMPUTER_WEARABLE" value="0x06" id="::Bluetooth::BluetoothClassDeviceMinor::COMPUTER_WEARABLE">
        <webidl>        const octet COMPUTER_WEARABLE = 0x06;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PHONE_UNCATEGORIZED" value="0x00" id="::Bluetooth::BluetoothClassDeviceMinor::PHONE_UNCATEGORIZED">
        <webidl>        const octet PHONE_UNCATEGORIZED = 0x00;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PHONE_CELLULAR" value="0x01" id="::Bluetooth::BluetoothClassDeviceMinor::PHONE_CELLULAR">
        <webidl>        const octet PHONE_CELLULAR = 0x01;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PHONE_CORDLESS" value="0x02" id="::Bluetooth::BluetoothClassDeviceMinor::PHONE_CORDLESS">
        <webidl>        const octet PHONE_CORDLESS = 0x02;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PHONE_SMARTPHONE" value="0x03" id="::Bluetooth::BluetoothClassDeviceMinor::PHONE_SMARTPHONE">
        <webidl>        const octet PHONE_SMARTPHONE = 0x03;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PHONE_MODEM_OR_GATEWAY" value="0x04" id="::Bluetooth::BluetoothClassDeviceMinor::PHONE_MODEM_OR_GATEWAY">
        <webidl>        const octet PHONE_MODEM_OR_GATEWAY = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PHONE_ISDN" value="0x05" id="::Bluetooth::BluetoothClassDeviceMinor::PHONE_ISDN">
        <webidl>        const octet PHONE_ISDN = 0x05;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_UNRECOGNIZED" value="0x00" id="::Bluetooth::BluetoothClassDeviceMinor::AV_UNRECOGNIZED">
        <webidl>        const octet AV_UNRECOGNIZED = 0x00;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_WEARABLE_HEADSET" value="0x01" id="::Bluetooth::BluetoothClassDeviceMinor::AV_WEARABLE_HEADSET">
        <webidl>        const octet AV_WEARABLE_HEADSET = 0x01;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_HANDSFREE" value="0x02" id="::Bluetooth::BluetoothClassDeviceMinor::AV_HANDSFREE">
        <webidl>        const octet AV_HANDSFREE = 0x02;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_MICROPHONE" value="0x04" id="::Bluetooth::BluetoothClassDeviceMinor::AV_MICROPHONE">
        <webidl>        const octet AV_MICROPHONE = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_LOUDSPEAKER" value="0x05" id="::Bluetooth::BluetoothClassDeviceMinor::AV_LOUDSPEAKER">
        <webidl>        const octet AV_LOUDSPEAKER = 0x05;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_HEADPHONES" value="0x06" id="::Bluetooth::BluetoothClassDeviceMinor::AV_HEADPHONES">
        <webidl>        const octet AV_HEADPHONES = 0x06;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_PORTABLE_AUDIO" value="0x07" id="::Bluetooth::BluetoothClassDeviceMinor::AV_PORTABLE_AUDIO">
        <webidl>        const octet AV_PORTABLE_AUDIO = 0x07;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_CAR_AUDIO" value="0x08" id="::Bluetooth::BluetoothClassDeviceMinor::AV_CAR_AUDIO">
        <webidl>        const octet AV_CAR_AUDIO = 0x08;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_SETTOP_BOX" value="0x09" id="::Bluetooth::BluetoothClassDeviceMinor::AV_SETTOP_BOX">
        <webidl>        const octet AV_SETTOP_BOX = 0x09;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_HIFI" value="0x0a" id="::Bluetooth::BluetoothClassDeviceMinor::AV_HIFI">
        <webidl>        const octet AV_HIFI = 0x0a;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_VCR" value="0x0b" id="::Bluetooth::BluetoothClassDeviceMinor::AV_VCR">
        <webidl>        const octet AV_VCR = 0x0b;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_VIDEO_CAMERA" value="0x0c" id="::Bluetooth::BluetoothClassDeviceMinor::AV_VIDEO_CAMERA">
        <webidl>        const octet AV_VIDEO_CAMERA = 0x0c;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_CAMCORDER" value="0x0d" id="::Bluetooth::BluetoothClassDeviceMinor::AV_CAMCORDER">
        <webidl>        const octet AV_CAMCORDER = 0x0d;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_MONITOR" value="0x0e" id="::Bluetooth::BluetoothClassDeviceMinor::AV_MONITOR">
        <webidl>        const octet AV_MONITOR = 0x0e;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_DISPLAY_AND_LOUDSPEAKER" value="0x0f" id="::Bluetooth::BluetoothClassDeviceMinor::AV_DISPLAY_AND_LOUDSPEAKER">
        <webidl>        const octet AV_DISPLAY_AND_LOUDSPEAKER = 0x0f;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_VIDEO_CONFERENCING" value="0x10" id="::Bluetooth::BluetoothClassDeviceMinor::AV_VIDEO_CONFERENCING">
        <webidl>        const octet AV_VIDEO_CONFERENCING = 0x10;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="AV_GAMING_TOY" value="0x12" id="::Bluetooth::BluetoothClassDeviceMinor::AV_GAMING_TOY">
        <webidl>        const octet AV_GAMING_TOY = 0x12;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_UNCATEGORIZED" value="0" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_UNCATEGORIZED">
        <webidl>        const octet PERIPHERAL_UNCATEGORIZED = 0;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_KEYBOARD" value="0x10" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_KEYBOARD">
        <webidl>        const octet PERIPHERAL_KEYBOARD = 0x10;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_POINTING_DEVICE" value="0x20" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_POINTING_DEVICE">
        <webidl>        const octet PERIPHERAL_POINTING_DEVICE = 0x20;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_KEYBOARD_AND_POINTING_DEVICE" value="0x30" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_KEYBOARD_AND_POINTING_DEVICE">
        <webidl>        const octet PERIPHERAL_KEYBOARD_AND_POINTING_DEVICE = 0x30;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_JOYSTICK" value="0x01" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_JOYSTICK">
        <webidl>        const octet PERIPHERAL_JOYSTICK = 0x01;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_GAMEPAD" value="0x02" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_GAMEPAD">
        <webidl>        const octet PERIPHERAL_GAMEPAD = 0x02;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_REMOTE_CONTROL" value="0x03" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_REMOTE_CONTROL">
        <webidl>        const octet PERIPHERAL_REMOTE_CONTROL = 0x03;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_SENSING_DEVICE" value="0x04" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_SENSING_DEVICE">
        <webidl>        const octet PERIPHERAL_SENSING_DEVICE = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_DEGITIZER_TABLET" value="0x05" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_DEGITIZER_TABLET">
        <webidl>        const octet PERIPHERAL_DEGITIZER_TABLET = 0x05;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_CARD_READER" value="0x06" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_CARD_READER">
        <webidl>        const octet PERIPHERAL_CARD_READER = 0x06;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_DIGITAL_PEN" value="0x07" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_DIGITAL_PEN">
        <webidl>        const octet PERIPHERAL_DIGITAL_PEN = 0x07;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_HANDHELD_SCANNER" value="0x08" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_HANDHELD_SCANNER">
        <webidl>        const octet PERIPHERAL_HANDHELD_SCANNER = 0x08;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="PERIPHERAL_HANDHELD_INPUT_DEVICE" value="0x09" id="::Bluetooth::BluetoothClassDeviceMinor::PERIPHERAL_HANDHELD_INPUT_DEVICE">
        <webidl>        const octet PERIPHERAL_HANDHELD_INPUT_DEVICE = 0x09;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="IMAGING_UNCATEGORIZED" value="0x00" id="::Bluetooth::BluetoothClassDeviceMinor::IMAGING_UNCATEGORIZED">
        <webidl>        const octet IMAGING_UNCATEGORIZED = 0x00;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="IMAGING_DISPLAY" value="0x04" id="::Bluetooth::BluetoothClassDeviceMinor::IMAGING_DISPLAY">
        <webidl>        const octet IMAGING_DISPLAY = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="IMAGING_CAMERA" value="0x08" id="::Bluetooth::BluetoothClassDeviceMinor::IMAGING_CAMERA">
        <webidl>        const octet IMAGING_CAMERA = 0x08;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="IMAGING_SCANNER" value="0x10" id="::Bluetooth::BluetoothClassDeviceMinor::IMAGING_SCANNER">
        <webidl>        const octet IMAGING_SCANNER = 0x10;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="IMAGING_PRINTER" value="0x20" id="::Bluetooth::BluetoothClassDeviceMinor::IMAGING_PRINTER">
        <webidl>        const octet IMAGING_PRINTER = 0x20;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="WEARABLE_WRITST_WATCH" value="0x01" id="::Bluetooth::BluetoothClassDeviceMinor::WEARABLE_WRITST_WATCH">
        <webidl>        const octet WEARABLE_WRITST_WATCH = 0x01;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="WEARABLE_PAGER" value="0x02" id="::Bluetooth::BluetoothClassDeviceMinor::WEARABLE_PAGER">
        <webidl>        const octet WEARABLE_PAGER = 0x02;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="WEARABLE_JACKET" value="0x03" id="::Bluetooth::BluetoothClassDeviceMinor::WEARABLE_JACKET">
        <webidl>        const octet WEARABLE_JACKET = 0x03;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="WEARABLE_HELMET" value="0x04" id="::Bluetooth::BluetoothClassDeviceMinor::WEARABLE_HELMET">
        <webidl>        const octet WEARABLE_HELMET = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="WEARABLE_GLASSES" value="0x05" id="::Bluetooth::BluetoothClassDeviceMinor::WEARABLE_GLASSES">
        <webidl>        const octet WEARABLE_GLASSES = 0x05;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="TOY_ROBOT" value="0x01" id="::Bluetooth::BluetoothClassDeviceMinor::TOY_ROBOT">
        <webidl>        const octet TOY_ROBOT = 0x01;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="TOY_VEHICLE" value="0x02" id="::Bluetooth::BluetoothClassDeviceMinor::TOY_VEHICLE">
        <webidl>        const octet TOY_VEHICLE = 0x02;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="TOY_DOLL" value="0x03" id="::Bluetooth::BluetoothClassDeviceMinor::TOY_DOLL">
        <webidl>        const octet TOY_DOLL = 0x03;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="TOY_CONTROLLER" value="0x04" id="::Bluetooth::BluetoothClassDeviceMinor::TOY_CONTROLLER">
        <webidl>        const octet TOY_CONTROLLER = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="TOY_GAME" value="0x05" id="::Bluetooth::BluetoothClassDeviceMinor::TOY_GAME">
        <webidl>        const octet TOY_GAME = 0x05;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_UNDEFINED" value="0x00" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_UNDEFINED">
        <webidl>        const octet HEALTH_UNDEFINED = 0x00;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_BLOOD_PRESSURE_MONITOR" value="0x01" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_BLOOD_PRESSURE_MONITOR">
        <webidl>        const octet HEALTH_BLOOD_PRESSURE_MONITOR = 0x01;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_THERMOMETER" value="0x02" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_THERMOMETER">
        <webidl>        const octet HEALTH_THERMOMETER = 0x02;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_WEIGHING_SCALE" value="0x03" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_WEIGHING_SCALE">
        <webidl>        const octet HEALTH_WEIGHING_SCALE = 0x03;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_GLUCOSE_METER" value="0x04" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_GLUCOSE_METER">
        <webidl>        const octet HEALTH_GLUCOSE_METER = 0x04;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_PULSE_OXIMETER" value="0x05" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_PULSE_OXIMETER">
        <webidl>        const octet HEALTH_PULSE_OXIMETER = 0x05;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_PULSE_RATE_MONITOR" value="0x06" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_PULSE_RATE_MONITOR">
        <webidl>        const octet HEALTH_PULSE_RATE_MONITOR = 0x06;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_DATA_DISPLAY" value="0x07" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_DATA_DISPLAY">
        <webidl>        const octet HEALTH_DATA_DISPLAY = 0x07;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_STEP_COUNTER" value="0x08" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_STEP_COUNTER">
        <webidl>        const octet HEALTH_STEP_COUNTER = 0x08;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_BODY_COMPOSITION_ANALYZER" value="0x09" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_BODY_COMPOSITION_ANALYZER">
        <webidl>        const octet HEALTH_BODY_COMPOSITION_ANALYZER = 0x09;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_PEAK_FLOW_MONITOR" value="0x0a" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_PEAK_FLOW_MONITOR">
        <webidl>        const octet HEALTH_PEAK_FLOW_MONITOR = 0x0a;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_MEDICATION_MONITOR" value="0x0b" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_MEDICATION_MONITOR">
        <webidl>        const octet HEALTH_MEDICATION_MONITOR = 0x0b;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_KNEE_PROSTHESIS" value="0x0c" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_KNEE_PROSTHESIS">
        <webidl>        const octet HEALTH_KNEE_PROSTHESIS = 0x0c;</webidl>
        <Type type="octet"/>
      </Const>
      <Const name="HEALTH_ANKLE_PROSTHESIS" value="0x0d" id="::Bluetooth::BluetoothClassDeviceMinor::HEALTH_ANKLE_PROSTHESIS">
        <webidl>        const octet HEALTH_ANKLE_PROSTHESIS = 0x0d;</webidl>
        <Type type="octet"/>
      </Const>
    </Interface>
    <Interface name="BluetoothClassDeviceService" id="::Bluetooth::BluetoothClassDeviceService">
      <webidl>    [NoInterfaceObject] interface BluetoothClassDeviceService {
        const unsigned short LIMITED_DISCOVERABILITY = 0x0001;
        const unsigned short POSITIONING = 0x0008;
        const unsigned short NETWORKING = 0x0010;
        const unsigned short RENDERING = 0x0020;
        const unsigned short CAPTURING = 0x0040;
        const unsigned short OBJECT_TRANSFER = 0x0080;
        const unsigned short AUDIO = 0x0100;
        const unsigned short TELEPHONY = 0x0200;
        const unsigned short INFORMATION = 0x0400;
    };</webidl>
      <descriptive>
          <brief>
 This interface holds identifiers for the major service classes of Bluetooth CoD.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Const name="LIMITED_DISCOVERABILITY" value="0x0001" id="::Bluetooth::BluetoothClassDeviceService::LIMITED_DISCOVERABILITY">
        <webidl>        const unsigned short LIMITED_DISCOVERABILITY = 0x0001;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="POSITIONING" value="0x0008" id="::Bluetooth::BluetoothClassDeviceService::POSITIONING">
        <webidl>        const unsigned short POSITIONING = 0x0008;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NETWORKING" value="0x0010" id="::Bluetooth::BluetoothClassDeviceService::NETWORKING">
        <webidl>        const unsigned short NETWORKING = 0x0010;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="RENDERING" value="0x0020" id="::Bluetooth::BluetoothClassDeviceService::RENDERING">
        <webidl>        const unsigned short RENDERING = 0x0020;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="CAPTURING" value="0x0040" id="::Bluetooth::BluetoothClassDeviceService::CAPTURING">
        <webidl>        const unsigned short CAPTURING = 0x0040;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="OBJECT_TRANSFER" value="0x0080" id="::Bluetooth::BluetoothClassDeviceService::OBJECT_TRANSFER">
        <webidl>        const unsigned short OBJECT_TRANSFER = 0x0080;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="AUDIO" value="0x0100" id="::Bluetooth::BluetoothClassDeviceService::AUDIO">
        <webidl>        const unsigned short AUDIO = 0x0100;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="TELEPHONY" value="0x0200" id="::Bluetooth::BluetoothClassDeviceService::TELEPHONY">
        <webidl>        const unsigned short TELEPHONY = 0x0200;</webidl>
        <Type type="unsigned short"/>
      </Const>
      <Const name="INFORMATION" value="0x0400" id="::Bluetooth::BluetoothClassDeviceService::INFORMATION">
        <webidl>        const unsigned short INFORMATION = 0x0400;</webidl>
        <Type type="unsigned short"/>
      </Const>
    </Interface>
    <Interface name="BluetoothServiceHandler" id="::Bluetooth::BluetoothServiceHandler">
      <webidl>    [NoInterfaceObject] interface BluetoothServiceHandler {
        readonly attribute <ref>BluetoothUUID</ref> uuid;
        readonly attribute DOMString name;
        readonly attribute boolean isConnected;
        [TreatNonCallableAsNull] attribute <ref>BluetoothSocketSuccessCallback</ref>? onconnect raises(<ref>WebAPIException</ref>);

        void unregister(optional <ref>SuccessCallback</ref>? successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface provides methods to handle Bluetooth service.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="uuid" id="::Bluetooth::BluetoothServiceHandler::uuid">
        <webidl>        readonly attribute <ref>BluetoothUUID</ref> uuid;</webidl>
        <descriptive>
            <brief>
 The UUID of the service.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="BluetoothUUID"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Bluetooth::BluetoothServiceHandler::name">
        <webidl>        readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 The name of the service.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="isConnected" id="::Bluetooth::BluetoothServiceHandler::isConnected">
        <webidl>        readonly attribute boolean isConnected;</webidl>
        <descriptive>
            <brief>
 An attribute to check whether any remote devices is using this service or not.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="onconnect" id="::Bluetooth::BluetoothServiceHandler::onconnect">
        <webidl>        [TreatNonCallableAsNull] attribute <ref>BluetoothSocketSuccessCallback</ref>? onconnect raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The success callback to be invoked when a remote device is connected to this service.
By default, this attribute is set to null.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <ExtendedAttributeList>
          <ExtendedAttribute name="TreatNonCallableAsNull">
            <webidl>TreatNonCallableAsNull</webidl>
          </ExtendedAttribute>
        </ExtendedAttributeList>
        <Type name="BluetoothSocketSuccessCallback" nullable="nullable"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input attribute is not compatible with the expected type for this attribute.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Operation name="unregister" id="::Bluetooth::BluetoothServiceHandler::unregister">
        <webidl>        void unregister(optional <ref>SuccessCallback</ref>? successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unregisters a service record from the Bluetooth services record database and stops listening for new connections to this service.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.spp
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var chatServiceHandler = null;

 function chatServiceSuccessCb(handler) {
    console.log(&quot;Chat service registration was successful!&quot;);

    chatServiceHandler = handler;
    handler.onconnect = function(socket) {
       console.log(&quot;Client is connected: &quot; + socket.peer.name + &quot;,&quot; + socket.peer.address);
       socket.onmessage = function() {
           var data = socket.readData();
           // Handle message code goes here
           //....
       };

       // Expected close
       socket.onclose = function() {
           console.log('The socket is closed.');
       };
    };
 }

 function publishChatService()
 {
    var CHAT_SERVICE_UUID = &quot;5BCE9431-6C75-32AB-AFE0-2EC108A30860&quot;;
    adapter.registerRFCOMMServiceByUUID(CHAT_SERVICE_UUID, &quot;Chat service&quot;, chatServiceSuccessCb,
      // Error handler
      function(e) {
           console.log( &quot;Could not register service record, Error: &quot; + e.message);
      });
 }

 function unRegisterChatService()
 {
      if (chatServiceHandler != null) {
           chatServiceHandler.unregister(function() {
               chatServiceHandler = null;
               console.log(&quot;Chat service is unregistered.&quot;);
           },
           function(e) {
               console.log (&quot;Error: &quot; + e.message);
           });
      }
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the record is removed successfully from the service records database.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be invoked in case of failure (to unregister).
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothProfileHandler" id="::Bluetooth::BluetoothProfileHandler">
      <webidl>    [NoInterfaceObject] interface BluetoothProfileHandler {

        readonly attribute <ref>BluetoothProfileType</ref> profileType;

    };</webidl>
      <descriptive>
          <brief>
 This interface represents the Bluetooth profile handler.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="profileType" id="::Bluetooth::BluetoothProfileHandler::profileType">
        <webidl>        readonly attribute <ref>BluetoothProfileType</ref> profileType;</webidl>
        <descriptive>
            <brief>
 The type of Bluetooth profile.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type name="BluetoothProfileType"/>
      </Attribute>
    </Interface>
    <Interface name="BluetoothHealthProfileHandler" id="::Bluetooth::BluetoothHealthProfileHandler">
      <webidl>    [NoInterfaceObject] interface BluetoothHealthProfileHandler : <ref>BluetoothProfileHandler</ref> {

        void registerSinkApplication(unsigned short dataType, DOMString name, <ref>BluetoothHealthApplicationSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void connectToSource(<ref>BluetoothDevice</ref> peer, <ref>BluetoothHealthApplication</ref> application, <ref>BluetoothHealthChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        };</webidl>
      <descriptive>
          <brief>
 This interface represents the handler of Bluetooth health device profile.
The BluetoothHealthProfileHandler object is created by <em>BluetoothAdapter.getBluetoothProfileHandler()</em>.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="BluetoothProfileHandler"/>
      </InterfaceInheritance>
      <Operation name="registerSinkApplication" id="::Bluetooth::BluetoothHealthProfileHandler::registerSinkApplication">
        <webidl>        void registerSinkApplication(unsigned short dataType, DOMString name, <ref>BluetoothHealthApplicationSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Registers an application for the Sink role.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.health
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var healthProfileHandler = adapter.getBluetoothProfileHandler(&quot;HEALTH&quot;);

 function healthRegisterSuccess(app) {
     console.log(&quot;Registered application: &quot; + app.name);
 }

 function healthRegisterError(e) {
     console.log(&quot;Failed to register application: &quot; + e.message);
 };

 healthProfileHandler.registerSinkApplication(4100, &quot;testSinkApp&quot;, healthRegisterSuccess, healthRegisterError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="dataType">
            <descriptive>
                <description><p>
 The MDEP data type used for communication, which is referenced in the ISO/IEEE 11073-20601 spec. For example, pulse oximeter is 4100 and blood pressure monitor is 4103.
                </p></description>
            </descriptive>
            <Type type="unsigned short"/>
          </Argument>
          <Argument name="name">
            <descriptive>
                <description><p>
 The friendly name associated with sink application.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when a sink application is registered successfully.
                </p></description>
            </descriptive>
            <Type name="BluetoothHealthApplicationSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="connectToSource" id="::Bluetooth::BluetoothHealthProfileHandler::connectToSource">
        <webidl>        void connectToSource(<ref>BluetoothDevice</ref> peer, <ref>BluetoothHealthApplication</ref> application, <ref>BluetoothHealthChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Connect to the health device which acts as the Source role.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.health
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var healthProfileHandler = adapter.getBluetoothProfileHandler(&quot;HEALTH&quot;);
 var registerHealthApp = null;

 function healthConnectSuccess(channel) {
     console.log(&quot;Health device is connected&quot;);
 }

 function healthConnectError(e) {
     console.log(&quot;Failed to connect to source: &quot; + e.message);
 };

 function gotDeviceInfo(device) {
     healthProfileHandler.connectToSource(device, registerHealthApp, healthConnectSuccess, healthConnectError);
 }

 function healthRegisterSuccess(app) {
     console.log(&quot;Registered application: &quot; + app.name);
     registerHealthApp = app;
     var peer = adapter.getDevice(&quot;35:F4:59:D1:7A:03&quot;, gotDeviceInfo);
 }

 function healthRegisterError(e) {
     console.log(&quot;Failed to register application: &quot; + e.message);
 };

 healthProfileHandler.registerSinkApplication(4100, &quot;testSinkApp&quot;, healthRegisterSuccess, healthRegisterError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="peer">
            <descriptive>
                <description><p>
 The remote device which acts as the Source role.
                </p></description>
            </descriptive>
            <Type name="BluetoothDevice"/>
          </Argument>
          <Argument name="application">
            <descriptive>
                <description><p>
 The registered application for the Sink role.
                </p></description>
            </descriptive>
            <Type name="BluetoothHealthApplication"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when a connection is established successfully.
                </p></description>
            </descriptive>
            <Type name="BluetoothHealthChannelSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothHealthApplication" id="::Bluetooth::BluetoothHealthApplication">
      <webidl>    [NoInterfaceObject] interface BluetoothHealthApplication {

        readonly attribute unsigned short dataType;

        readonly attribute DOMString name;

        [TreatNonCallableAsNull] attribute <ref>BluetoothHealthChannelSuccessCallback</ref>? onconnect raises(<ref>WebAPIException</ref>);

        void unregister(optional <ref>SuccessCallback</ref>? successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    };</webidl>
      <descriptive>
          <brief>
 This interface represents the Bluetooth health application.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="dataType" id="::Bluetooth::BluetoothHealthApplication::dataType">
        <webidl>        readonly attribute unsigned short dataType;</webidl>
        <descriptive>
            <brief>
 The MDEP data type used for communication, which is referenced in the ISO/IEEE 11073-20601 spec. For example, pulse oximeter is 4100 and blood pressure monitor is 4103.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Bluetooth::BluetoothHealthApplication::name">
        <webidl>        readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 The friendly name associated with sink application.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="onconnect" id="::Bluetooth::BluetoothHealthApplication::onconnect">
        <webidl>        [TreatNonCallableAsNull] attribute <ref>BluetoothHealthChannelSuccessCallback</ref>? onconnect raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The callback invoked when a health device is connected through this application.
By default, this attribute is set to null.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <ExtendedAttributeList>
          <ExtendedAttribute name="TreatNonCallableAsNull">
            <webidl>TreatNonCallableAsNull</webidl>
          </ExtendedAttribute>
        </ExtendedAttributeList>
        <Type name="BluetoothHealthChannelSuccessCallback" nullable="nullable"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if an input attribute is not compatible with the expected type for this attribute.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Operation name="unregister" id="::Bluetooth::BluetoothHealthApplication::unregister">
        <webidl>        void unregister(optional <ref>SuccessCallback</ref>? successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unregisters this application.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If a Bluetooth device is turned off.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.health
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var healthProfileHandler = adapter.getBluetoothProfileHandler(&quot;HEALTH&quot;);
 var healthApp = null;

 function healthRegisterSuccess(app) {
     console.log(&quot;Registered application: &quot; + app.name);
     healthApp = app;
     healthApp.onconnect = function(channel) {
         console.log(&quot;Connected!!&quot;);
     };
 }

 function healthRegisterError(e) {
     console.log(&quot;Failed to register application: &quot; + e.message);
 };

 function startSink() {
     try {
         healthProfileHandler.registerSinkApplication(4100, &quot;testSinkApp&quot;, healthRegisterSuccess, healthRegisterError);
     } catch(e) {
         console.log(&quot;Error: &quot; + e.message);
     }
 }

 function stopSink() {
     try {
         if(healthApp != null) {
             healthApp.unregister(function() {
                 healthApp = null;
                 console.log(&quot;Health application is unregistered.&quot;);
             },
             function(e) {
                 console.log (&quot;Error: &quot; + e.message);
             });
         }
     } catch(err) {
         console.log(&quot;Error: &quot; + err.message);
     }
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when a sink application is registered successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothHealthChannel" id="::Bluetooth::BluetoothHealthChannel">
      <webidl>    [NoInterfaceObject] interface BluetoothHealthChannel {

        readonly attribute <ref>BluetoothDevice</ref> peer;

        readonly attribute <ref>BluetoothHealthChannelType</ref> channelType;

        readonly attribute <ref>BluetoothHealthApplication</ref> application;

        readonly attribute boolean isConnected;

        void close() raises(<ref>WebAPIException</ref>);

        unsigned long sendData(byte[] data) raises(<ref>WebAPIException</ref>);

        void setListener(<ref>BluetoothHealthChannelChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);

        void unsetListener() raises(<ref>WebAPIException</ref>);

    };</webidl>
      <descriptive>
          <brief>
 This interface represents the Bluetooth health channel.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="peer" id="::Bluetooth::BluetoothHealthChannel::peer">
        <webidl>        readonly attribute <ref>BluetoothDevice</ref> peer;</webidl>
        <descriptive>
            <brief>
 The remote device to which this channel is connected.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type name="BluetoothDevice"/>
      </Attribute>
      <Attribute readonly="readonly" name="channelType" id="::Bluetooth::BluetoothHealthChannel::channelType">
        <webidl>        readonly attribute <ref>BluetoothHealthChannelType</ref> channelType;</webidl>
        <descriptive>
            <brief>
 The type of of this channel.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type name="BluetoothHealthChannelType"/>
      </Attribute>
      <Attribute readonly="readonly" name="application" id="::Bluetooth::BluetoothHealthChannel::application">
        <webidl>        readonly attribute <ref>BluetoothHealthApplication</ref> application;</webidl>
        <descriptive>
            <brief>
 The health application which is used to communicate with the remote device.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type name="BluetoothHealthApplication"/>
      </Attribute>
      <Attribute readonly="readonly" name="isConnected" id="::Bluetooth::BluetoothHealthChannel::isConnected">
        <webidl>        readonly attribute boolean isConnected;</webidl>
        <descriptive>
            <brief>
 An attrbitue to check whether any remote device is connected or not.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="close" id="::Bluetooth::BluetoothHealthChannel::close">
        <webidl>        void close() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Close the connected channel.
<em>BluetoothHealthChannel.isConnected</em> is changed to <var>false</var> and <em>BluetoothHealthChannelChangeCallback.onclose</em> is invoked when this channel is closed successfully.
            </brief>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.health
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var healthProfileHandler = adapter.getBluetoothProfileHandler(&quot;HEALTH&quot;);

 function healthRegisterSuccess(app) {
     console.log(&quot;Registered application: &quot; + app.name);
     app.onconnect = function(channel) {;
         console.log(&quot;Health device is connected&quot;);
         channel.close();
     }
 }

 function healthRegisterError(e) {
     console.log(&quot;Failed to register application: &quot; + e.message);
 };

 healthProfileHandler.registerSinkApplication(4100, &quot;testSinkApp&quot;, healthRegisterSuccess, healthRegisterError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type ServiceNotAvailableError - If a Bluetooth device is turned off.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="sendData" id="::Bluetooth::BluetoothHealthChannel::sendData">
        <webidl>        unsigned long sendData(byte[] data) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Send data and returns the number of bytes actually written.
            </brief>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.health
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var healthProfileHandler = adapter.getBluetoothProfileHandler(&quot;HEALTH&quot;);

 function healthRegisterSuccess(app) {
     console.log(&quot;Registered application: &quot; + app.name);
     app.onconnect = function(channel) {
         console.log(&quot;Health device is connected&quot;);
         channel.sendData(dataToSend);
     }
 }

 function healthRegisterError(e) {
     console.log(&quot;Failed to register application: &quot; + e.message);
 };

 healthProfileHandler.registerSinkApplication(4100, &quot;testSinkApp&quot;, healthRegisterSuccess, healthRegisterError);
 </Code>
        </descriptive>
        <Type type="unsigned long">
          <descriptive>
              <description><p>
 unsigned long The number of bytes actually sent.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="data">
            <descriptive>
                <description><p>
 The data to send.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type ServiceNotAvailableError - If a Bluetooth device is turned off.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setListener" id="::Bluetooth::BluetoothHealthChannel::setListener">
        <webidl>        void setListener(<ref>BluetoothHealthChannelChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the listener to receive notifications.
            </brief>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.health
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var healthProfileHandler = adapter.getBluetoothProfileHandler(&quot;HEALTH&quot;);

 var channelCallback = {
     onmessage: function(data) {
         console.log(&quot;data is received&quot;)
     },
     onclose: function() {
         console.log(&quot;channel is closed&quot;);
     }
 };

 function healthRegisterSuccess(app) {
     console.log(&quot;Registered application: &quot; + app.name);
     app.onconnect = function(channel) {;
         console.log(&quot;Health device is connected&quot;);
         channel.setListener(channelCallback);
     }
 }

 function healthRegisterError(e) {
     console.log(&quot;Failed to register application: &quot; + e.message);
 };

 healthProfileHandler.registerSinkApplication(4100, &quot;testSinkApp&quot;, healthRegisterSuccess, healthRegisterError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="listener">
            <descriptive>
                <description><p>
 The event listener of Bluetooth health channel.
                </p></description>
            </descriptive>
            <Type name="BluetoothHealthChannelChangeCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unsetListener" id="::Bluetooth::BluetoothHealthChannel::unsetListener">
        <webidl>        void unsetListener() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsets the listener, so stop receiving notifications.
            </brief>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/bluetooth.health
            </privilege>
            <Code> var adapter = tizen.bluetooth.getDefaultAdapter();
 var healthProfileHandler = adapter.getBluetoothProfileHandler(&quot;HEALTH&quot;);
 var connectedChannel = null;

 var channelCallback = {
     onmessage: function(data) {
         console.log(&quot;data is received&quot;)
     },
     onclose: function() {
         console.log(&quot;channel is closed&quot;);
         connectedChannel.unsetListener();
     }
 };

 function healthRegisterSuccess(app) {
     console.log(&quot;Registered application: &quot; + app.name);
     app.onconnect = function(channel) {;
         console.log(&quot;Health device is connected&quot;);
         connectedChannel = channel;
         connectedChannel.setListener(channelCallback);
     }
 }

 function healthRegisterError(e) {
     console.log(&quot;Failed to register application: &quot; + e.message);
 };

 healthProfileHandler.registerSinkApplication(4100, &quot;testSinkApp&quot;, healthRegisterSuccess, healthRegisterError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BluetoothAdapterChangeCallback" id="::Bluetooth::BluetoothAdapterChangeCallback">
      <webidl>    [Callback, NoInterfaceObject] interface BluetoothAdapterChangeCallback {
        void onstatechanged(boolean powered);
        void onnamechanged(DOMString name);
        void onvisibilitychanged(boolean visible);
    };</webidl>
      <descriptive>
          <brief>
 This interface specifies a set of methods to be invoked when the changes of Bluetooth adapter occur.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onstatechanged" id="::Bluetooth::BluetoothAdapterChangeCallback::onstatechanged">
        <webidl>        void onstatechanged(boolean powered);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when the power state is changed.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="powered">
            <descriptive>
                <description><p>
 The power state of local Bluetooth: <var>true</var> means power-on, <var>false</var> means power-off.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onnamechanged" id="::Bluetooth::BluetoothAdapterChangeCallback::onnamechanged">
        <webidl>        void onnamechanged(DOMString name);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when the name is changed.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="name">
            <descriptive>
                <description><p>
 The name of local Bluetooth.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onvisibilitychanged" id="::Bluetooth::BluetoothAdapterChangeCallback::onvisibilitychanged">
        <webidl>        void onvisibilitychanged(boolean visible);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when the visibility is changed.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="visible">
            <descriptive>
                <description><p>
 The visibility of local Bluetooth: <var>true</var> means that local Bluetooth is discoverable, <var>false</var> means that local Bluetooth is hidden from other devices.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="BluetoothDeviceSuccessCallback" id="::Bluetooth::BluetoothDeviceSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothDeviceSuccessCallback {
        void onsuccess(<ref>BluetoothDevice</ref> device);
    };</webidl>
      <descriptive>
          <brief>
 This interface implements the success callback <em>BluetoothAdapter.getDevice() </em>and <em>BluetoothAdapter.createBonding()</em>.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Bluetooth::BluetoothDeviceSuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>BluetoothDevice</ref> device);</webidl>
        <descriptive>
            <brief>
 The method to be invoked on success.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="device">
            <descriptive>
                <description><p>
 The BluetoothDevice object.
                </p></description>
            </descriptive>
            <Type name="BluetoothDevice"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="BluetoothDeviceArraySuccessCallback" id="::Bluetooth::BluetoothDeviceArraySuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothDeviceArraySuccessCallback {
        void onsuccess(<ref>BluetoothDevice</ref>[] devices);
    };</webidl>
      <descriptive>
          <brief>
 The success callback for <em>BluetoothAdapter.getKnownDevices()</em>.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Bluetooth::BluetoothDeviceArraySuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>BluetoothDevice</ref>[] devices);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when device information is ready.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="devices">
            <descriptive>
                <description><p>
 List of devices known to local Bluetooth adapter. Each element is a BluetoothDevice.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="BluetoothDevice"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="BluetoothDiscoverDevicesSuccessCallback" id="::Bluetooth::BluetoothDiscoverDevicesSuccessCallback">
      <webidl>    [Callback, NoInterfaceObject] interface BluetoothDiscoverDevicesSuccessCallback {
        void onstarted();
        void ondevicefound(<ref>BluetoothDevice</ref> device);
        void ondevicedisappeared(<ref>BluetoothAddress</ref> address);
        void onfinished(<ref>BluetoothDevice</ref>[] foundDevices);
    };</webidl>
      <descriptive>
          <brief>
 The success callback for <em>BluetoothAdapter.discoverDevices()</em>.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onstarted" id="::Bluetooth::BluetoothDiscoverDevicesSuccessCallback::onstarted">
        <webidl>        void onstarted();</webidl>
        <descriptive>
            <brief>
 The method to be invoked at the beginning of a device discovery process for finding the nearby Bluetooth device.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
      <Operation name="ondevicefound" id="::Bluetooth::BluetoothDiscoverDevicesSuccessCallback::ondevicefound">
        <webidl>        void ondevicefound(<ref>BluetoothDevice</ref> device);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when a new device is discovered in the process of inquiry/discovery.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="device">
            <descriptive>
                <description><p>
 The found device.
                </p></description>
            </descriptive>
            <Type name="BluetoothDevice"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="ondevicedisappeared" id="::Bluetooth::BluetoothDiscoverDevicesSuccessCallback::ondevicedisappeared">
        <webidl>        void ondevicedisappeared(<ref>BluetoothAddress</ref> address);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when a device is lost from proximity.
After that, this device is no longer visible.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="address">
            <descriptive>
                <description><p>
 The address of the device that is no longer in range or visible.
                </p></description>
            </descriptive>
            <Type name="BluetoothAddress"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onfinished" id="::Bluetooth::BluetoothDiscoverDevicesSuccessCallback::onfinished">
        <webidl>        void onfinished(<ref>BluetoothDevice</ref>[] foundDevices);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when the device discovery process has finished.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="foundDevices">
            <descriptive>
                <description><p>
 The array of devices found in this discovery session.                         </p></description>
            </descriptive>
            <Type type="array">
              <Type name="BluetoothDevice"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="BluetoothSocketSuccessCallback" id="::Bluetooth::BluetoothSocketSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothSocketSuccessCallback {
        void onsuccess(<ref>BluetoothSocket</ref> socket);
    };</webidl>
      <descriptive>
          <brief>
 The success method for <em>BluetoothDevice.connectToServiceByUUID()</em>.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Bluetooth::BluetoothSocketSuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>BluetoothSocket</ref> socket);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when the connection to a service is ready.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="socket">
            <descriptive>
                <description><p>
 The socket to connect to the specified service on a remote device.
                </p></description>
            </descriptive>
            <Type name="BluetoothSocket"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="BluetoothServiceSuccessCallback" id="::Bluetooth::BluetoothServiceSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothServiceSuccessCallback {
        void onsuccess(<ref>BluetoothServiceHandler</ref> handler);
    };</webidl>
      <descriptive>
          <brief>
 This interface implements the success callback for <em>BluetoothAdapter.registerRFCOMMServiceByUUID()</em>.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Bluetooth::BluetoothServiceSuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>BluetoothServiceHandler</ref> handler);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when registering a service with the local device is successful.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="handler">
            <descriptive>
                <description><p>
 Bluetooth service handler.
                </p></description>
            </descriptive>
            <Type name="BluetoothServiceHandler"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="BluetoothHealthApplicationSuccessCallback" id="::Bluetooth::BluetoothHealthApplicationSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothHealthApplicationSuccessCallback {
        void onsuccess(<ref>BluetoothHealthApplication</ref> application);
    };</webidl>
      <descriptive>
          <brief>
 The success method for <em>BluetoothHealthProfileHandler.registerSinkApplication()</em>.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Bluetooth::BluetoothHealthApplicationSuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>BluetoothHealthApplication</ref> application);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when the application is registered successfully.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="application">
            <descriptive>
                <description><p>
 The registered health application.
                </p></description>
            </descriptive>
            <Type name="BluetoothHealthApplication"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="BluetoothHealthChannelSuccessCallback" id="::Bluetooth::BluetoothHealthChannelSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface BluetoothHealthChannelSuccessCallback {
        void onsuccess(<ref>BluetoothHealthChannel</ref> channel);
    };</webidl>
      <descriptive>
          <brief>
 The success method for <em>BluetoothHealthProfileHandler.connectToSource()</em> and the event callback for <em>BluetoothHealthApplication.onconnect</em>.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Bluetooth::BluetoothHealthChannelSuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>BluetoothHealthChannel</ref> channel);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when a connection is established.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="channel">
            <descriptive>
                <description><p>
 The connected health channel.
                </p></description>
            </descriptive>
            <Type name="BluetoothHealthChannel"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="BluetoothHealthChannelChangeCallback" id="::Bluetooth::BluetoothHealthChannelChangeCallback">
      <webidl>    [Callback, NoInterfaceObject] interface BluetoothHealthChannelChangeCallback {
        void onmessage(byte[] data);

        void onclose();
    };</webidl>
      <descriptive>
          <brief>
 This interface specifies a set of methods to be invoked when the changes of heath channel occur.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onmessage" id="::Bluetooth::BluetoothHealthChannelChangeCallback::onmessage">
        <webidl>        void onmessage(byte[] data);</webidl>
        <descriptive>
            <brief>
 The method to be invoked when the message is received.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="data">
            <descriptive>
                <description><p>
 The received data.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onclose" id="::Bluetooth::BluetoothHealthChannelChangeCallback::onclose">
        <webidl>        void onclose();</webidl>
        <descriptive>
            <brief>
 The method to be invoked when the health channel is closed.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
    </Interface>
  </Module>
  <Module name="Bookmark" id="::Bookmark">
    <webidl>module Bookmark {&#13;
&#13;
  typedef (<ref>BookmarkItem</ref> or <ref>BookmarkFolder</ref>) Bookmark;&#13;
&#13;
&#13;
  [NoInterfaceObject] interface BookmarkManagerObject {&#13;
    readonly attribute <ref>BookmarkManager</ref> bookmark;&#13;
  };&#13;
  <ref>Tizen</ref> implements <ref>BookmarkManagerObject</ref>;&#13;
&#13;
&#13;
  [NoInterfaceObject] interface BookmarkManager {&#13;
&#13;
    <ref>Bookmark</ref>[] get(optional <ref>BookmarkFolder</ref>? parentFolder, optional boolean? recursive) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void add(<ref>Bookmark</ref> bookmark, optional <ref>BookmarkFolder</ref>? parentFolder) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void remove(optional <ref>Bookmark</ref>? bookmark) raises(<ref>WebAPIException</ref>);&#13;
&#13;
  };&#13;
&#13;
&#13;
  [Constructor(DOMString title, DOMString url)]&#13;
&#13;
  interface BookmarkItem {&#13;
&#13;
    readonly attribute <ref>BookmarkFolder</ref>? parent;&#13;
&#13;
    readonly attribute DOMString title;&#13;
&#13;
    readonly attribute DOMString url;&#13;
&#13;
  };&#13;
&#13;
  [Constructor(DOMString title)]&#13;
&#13;
  interface BookmarkFolder {&#13;
&#13;
    readonly attribute <ref>BookmarkFolder</ref>? parent;&#13;
&#13;
    readonly attribute DOMString title;&#13;
&#13;
  };&#13;
};</webidl>
    <descriptive>
        <brief>
 This API provides interfaces and methods for accessing Bookmark.
This API provides functionality to get, add, and remove bookmarks.
        </brief>
       <description>
        <p>
For more information on the Bookmark features, see <a href="../../org.tizen.web.appprogramming/html/guide/social_guide/bookmark.htm">Bookmark Guide</a>.
        </p>
       </description>
        <version>
 2.1
        </version>
    </descriptive>
    <Typedef name="Bookmark" id="::Bookmark::Bookmark">
      <webidl>  typedef (<ref>BookmarkItem</ref> or <ref>BookmarkFolder</ref>) Bookmark;</webidl>
      <descriptive>
          <brief>
 A bookmark, which could be either a <em>BookmarkItem </em>or a <em>BookmarkFolder</em>.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <Type type="union">
        <Type name="BookmarkItem"/>
        <Type name="BookmarkFolder"/>
      </Type>
    </Typedef>
    <Interface name="BookmarkManagerObject" id="::Bookmark::BookmarkManagerObject">
      <webidl>  [NoInterfaceObject] interface BookmarkManagerObject {&#13;
    readonly attribute <ref>BookmarkManager</ref> bookmark;&#13;
  };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated by the Tizen object from the Tizen Platform.
          </brief>
         <description>
          <p>
There will be a <em>tizen.bookmark </em>object that allows to access the functionality of the Bookmark API.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="bookmark" id="::Bookmark::BookmarkManagerObject::bookmark">
        <webidl>    readonly attribute <ref>BookmarkManager</ref> bookmark;</webidl>
        <Type name="BookmarkManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="BookmarkManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>BookmarkManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="BookmarkManager" id="::Bookmark::BookmarkManager">
      <webidl>  [NoInterfaceObject] interface BookmarkManager {&#13;
&#13;
    <ref>Bookmark</ref>[] get(optional <ref>BookmarkFolder</ref>? parentFolder, optional boolean? recursive) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void add(<ref>Bookmark</ref> bookmark, optional <ref>BookmarkFolder</ref>? parentFolder) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void remove(optional <ref>Bookmark</ref>? bookmark) raises(<ref>WebAPIException</ref>);&#13;
&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface provides access to the bookmark folder and bookmark item.
          </brief>
         <description>
          <p>
It provides access to the API functionalities through the <em>tizen.bookmark </em>interface.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="get" id="::Bookmark::BookmarkManager::get">
        <webidl>    <ref>Bookmark</ref>[] get(optional <ref>BookmarkFolder</ref>? parentFolder, optional boolean? recursive) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets all bookmark items and bookmark folders.
            </brief>
           <description>
            <p>
If no parentFolder is passed, or the parentFolder contains <var>null</var>, it is considered as the default bookmark folder(The root bookmark folder).
In this case, the return will contain bookmarks under the root bookmark folder.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/bookmark.read
            </privilege>
            <privilegelevel>
 platform
            </privilegelevel>
            <Code> try {
  // retrieve bookmarks from the root bookmark folder recursively
  var allBookmarks = tizen.bookmark.get(null, true);
 } catch (err) {
  console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 Bookmark[] Array of Bookmarks.
              </p></description>
          </descriptive>
          <Type name="Bookmark"/>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="parentFolder">
            <descriptive>
                <description><p>
 The parent bookmark folder to retrieve the result bookmarks.
                </p></description>
            </descriptive>
            <Type name="BookmarkFolder" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="recursive">
            <descriptive>
                <description><p>
 The flag indicating whether sub-bookmarks are also retrieved recursively or not<br/> (The default value is <em>false</em>).
                </p></description>
            </descriptive>
            <Type type="boolean" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the parentFolder parameter isn't found in bookmark database.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if an input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="add" id="::Bookmark::BookmarkManager::add">
        <webidl>    void add(<ref>Bookmark</ref> bookmark, optional <ref>BookmarkFolder</ref>? parentFolder) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a bookmark item or a bookmark folder.
            </brief>
           <description>
            <p>
If no parentFolder is passed, or the parentFolder contains <var>null</var>, it is considered as the default bookmark folder(The root bookmark folder).
In this case, the bookmark is added under the root bookmark folder.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/bookmark.write
            </privilege>
            <privilegelevel>
 platform
            </privilegelevel>
            <Code> try {
 // add a bookmark item to root bookmark folder.
  tizen.bookmark.add(new tizen.BookmarkItem(&quot;tizen&quot;, &quot;https://www.tizen.org&quot;));
 } catch (err) {
  console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="bookmark">
            <descriptive>
                <description><p>
 The bookmark to be added.
                </p></description>
            </descriptive>
            <Type name="Bookmark"/>
          </Argument>
          <Argument optional="optional" name="parentFolder">
            <descriptive>
                <description><p>
 The parent folder of a bookmark to be added.
                </p></description>
            </descriptive>
            <Type name="BookmarkFolder" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if a parentFolder parameter isn't found in bookmark database.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value, or a bookmark parameter is either a bookmark item whose url has already existed in bookmark database or a bookmark folder whose title has already existed under the same parent folder.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if an input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::Bookmark::BookmarkManager::remove">
        <webidl>    void remove(optional <ref>Bookmark</ref>? bookmark) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a bookmark item or a bookmark folder.
            </brief>
           <description>
            <p>
If the bookmark is a BookmarkFolder type, all the bookmark items and bookmark folders under the specified bookmark folder are going to be removed.<br/>If no bookmark is passed, or the bookmark contains <var>null</var>, it is considered as the default bookmark folder(The root bookmark folder).
In this case, all the bookmarks will be removed.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/bookmark.write
            </privilege>
            <privilegelevel>
 platform
            </privilegelevel>
            <Code> try {
 // remove all the bookmark folders and items
  tizen.bookmark.remove();
 } catch (err) {
  console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="bookmark">
            <descriptive>
                <description><p>
 The bookmark to be removed.
                </p></description>
            </descriptive>
            <Type name="Bookmark" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="BookmarkItem" id="::Bookmark::BookmarkItem">
      <webidl>  [Constructor(DOMString title, DOMString url)]&#13;
&#13;
  interface BookmarkItem {&#13;
&#13;
    readonly attribute <ref>BookmarkFolder</ref>? parent;&#13;
&#13;
    readonly attribute DOMString title;&#13;
&#13;
    readonly attribute DOMString url;&#13;
&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface implements the <em>BookmarkItem </em>object.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString title, DOMString url)</webidl>
          <descriptive>
              <Code> try {
 // create a bookmark item
  var tizen = new tizen.BookmarkItem(&quot;tizen&quot;, &quot;https://www.tizen.org&quot;);
 } catch (err) {
  console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
          </descriptive>
          <ArgumentList>
            <Argument name="title">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="url">
              <Type type="DOMString"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="parent" id="::Bookmark::BookmarkItem::parent">
        <webidl>    readonly attribute <ref>BookmarkFolder</ref>? parent;</webidl>
        <descriptive>
            <brief>
 The parent bookmark folder.
            </brief>
           <description>
            <p>
This attribute is meaningful when this object is successfully added or retrieved.
If this BookmarkItem is not added yet, its value is set to undefined.
            </p>
            <p>
If the parent bookmark folder indicates the root bookmark folder, the value will be <var>null</var>.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="BookmarkFolder" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="title" id="::Bookmark::BookmarkItem::title">
        <webidl>    readonly attribute DOMString title;</webidl>
        <descriptive>
            <brief>
 The title of the bookmark.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="url" id="::Bookmark::BookmarkItem::url">
        <webidl>    readonly attribute DOMString url;</webidl>
        <descriptive>
            <brief>
 The uri of the bookmark.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="BookmarkFolder" id="::Bookmark::BookmarkFolder">
      <webidl>  [Constructor(DOMString title)]&#13;
&#13;
  interface BookmarkFolder {&#13;
&#13;
    readonly attribute <ref>BookmarkFolder</ref>? parent;&#13;
&#13;
    readonly attribute DOMString title;&#13;
&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface implements the <em>BookmarkFolder </em>object.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString title)</webidl>
          <descriptive>
              <Code> try {
 // create a bookmark folder
  var folder = new tizen.BookmarkFolder(&quot;folder&quot;);
 } catch (err) {
  console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
          </descriptive>
          <ArgumentList>
            <Argument name="title">
              <Type type="DOMString"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="parent" id="::Bookmark::BookmarkFolder::parent">
        <webidl>    readonly attribute <ref>BookmarkFolder</ref>? parent;</webidl>
        <descriptive>
            <brief>
 The parent bookmark folder.
            </brief>
           <description>
            <p>
This attribute is meaningful when this object is successfully added or retrieved.
If this BookmarkFolder is not added yet, its value is set to undefined.
            </p>
            <p>
If the parent bookmark folder indicates the root bookmark folder, the value will be <var>null</var>.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="BookmarkFolder" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="title" id="::Bookmark::BookmarkFolder::title">
        <webidl>    readonly attribute DOMString title;</webidl>
        <descriptive>
            <brief>
 The title of the bookmark folder.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
  </Module>
  <Module name="Calendar" id="::Calendar">
    <webidl>module Calendar {
  typedef DOMString CalendarId;

  typedef DOMString CalendarTaskId;

  typedef (<ref>CalendarEventId</ref> or <ref>CalendarTaskId</ref>) CalendarItemId;

  enum CalendarType { &quot;EVENT&quot;, &quot;TASK&quot; };

  enum CalendarTextFormat { &quot;ICALENDAR_20&quot;, &quot;VCALENDAR_10&quot; };

  enum AlarmMethod { &quot;SOUND&quot;, &quot;DISPLAY&quot; };


  enum RecurrenceRuleFrequency { &quot;DAILY&quot;, &quot;WEEKLY&quot;, &quot;MONTHLY&quot;, &quot;YEARLY&quot; };

  enum ByDayValue { &quot;MO&quot;, &quot;TU&quot;, &quot;WE&quot;, &quot;TH&quot;, &quot;FR&quot;, &quot;SA&quot;, &quot;SU&quot; };

  enum EventAvailability { &quot;BUSY&quot;, &quot;FREE&quot; };

  enum AttendeeType { &quot;INDIVIDUAL&quot;, &quot;GROUP&quot;, &quot;RESOURCE&quot;, &quot;ROOM&quot;, &quot;UNKNOWN&quot; };

  enum AttendeeStatus { &quot;PENDING&quot;, &quot;ACCEPTED&quot;, &quot;DECLINED&quot;, &quot;TENTATIVE&quot;, &quot;DELEGATED&quot;, &quot;COMPLETED&quot;, &quot;IN_PROCESS&quot; };

  enum AttendeeRole { &quot;REQ_PARTICIPANT&quot;, &quot;OPT_PARTICIPANT&quot;, &quot;NON_PARTICIPANT&quot;, &quot;CHAIR&quot; };

  enum CalendarItemPriority { &quot;HIGH&quot;, &quot;MEDIUM&quot;, &quot;LOW&quot; };

   enum CalendarItemVisibility { &quot;PUBLIC&quot;, &quot;PRIVATE&quot;, &quot;CONFIDENTIAL&quot; };

   enum CalendarItemStatus { &quot;TENTATIVE&quot;, &quot;CONFIRMED&quot;, &quot;CANCELLED&quot;, &quot;NEEDS_ACTION&quot;, &quot;IN_PROCESS&quot;, &quot;COMPLETED&quot; };

  [NoInterfaceObject] interface CalendarManagerObject{
    readonly attribute <ref>CalendarManager</ref> calendar;
  };
  <ref>Tizen</ref> implements <ref>CalendarManagerObject</ref>;

  [NoInterfaceObject] interface CalendarManager {
    void getCalendars(<ref>CalendarType</ref> type,
                      <ref>CalendarArraySuccessCallback</ref> successCallback,
                      optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    <ref>Calendar</ref> getUnifiedCalendar(<ref>CalendarType</ref> type) raises(<ref>WebAPIException</ref>);

    <ref>Calendar</ref> getDefaultCalendar(<ref>CalendarType</ref> type) raises(<ref>WebAPIException</ref>);

    <ref>Calendar</ref> getCalendar(<ref>CalendarType</ref> type, <ref>CalendarId</ref> id) raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface Calendar {

    readonly attribute <ref>CalendarId</ref> id;

    readonly attribute DOMString name;

    <ref>CalendarItem</ref> get(<ref>CalendarItemId</ref> id) raises(<ref>WebAPIException</ref>);

    void add(<ref>CalendarItem</ref> item) raises(<ref>WebAPIException</ref>);

    void addBatch(<ref>CalendarItem</ref>[] items,
                  optional <ref>CalendarItemArraySuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void update(<ref>CalendarItem</ref> item,
                optional boolean? updateAllInstances) raises(<ref>WebAPIException</ref>);

     void updateBatch(<ref>CalendarItem</ref>[] items,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback,
                     optional boolean? updateAllInstances) raises(<ref>WebAPIException</ref>);

    void remove(<ref>CalendarItemId</ref> id) raises(<ref>WebAPIException</ref>);

    void removeBatch(<ref>CalendarItemId</ref>[] ids,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void find(<ref>CalendarItemArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);

    long addChangeListener(<ref>CalendarChangeCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);

    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);
  };

  dictionary CalendarItemInit {
    DOMString description;
    DOMString summary;
    boolean isAllDay;
    <ref>TZDate</ref> startDate;
    <ref>TimeDuration</ref> duration;
    DOMString location;
    <ref>SimpleCoordinates</ref> geolocation;
    DOMString organizer;
    <ref>CalendarItemVisibility</ref> visibility;
    <ref>CalendarItemStatus</ref> status;
    <ref>CalendarItemPriority</ref> priority;
    <ref>CalendarAlarm</ref>[] alarms;
    DOMString[] categories;
    <ref>CalendarAttendee</ref>[] attendees;
  };

  dictionary CalendarTaskInit: <ref>CalendarItemInit</ref> {
    <ref>TZDate</ref> dueDate;
    <ref>TZDate</ref> completedDate;
    short progress;
  };

  dictionary CalendarEventInit: <ref>CalendarItemInit</ref> {
    <ref>TZDate</ref> endDate;
    <ref>EventAvailability</ref> availability;
    <ref>CalendarRecurrenceRule</ref> recurrenceRule;
  };

  [NoInterfaceObject] interface CalendarItem {
    readonly attribute <ref>CalendarItemId</ref>? id;

    readonly attribute <ref>CalendarId</ref>? calendarId;

    readonly attribute <ref>TZDate</ref>? lastModificationDate;

    attribute DOMString? description setraises(<ref>WebAPIException</ref>);

    attribute DOMString? summary setraises(<ref>WebAPIException</ref>);

    attribute boolean isAllDay setraises(<ref>WebAPIException</ref>);

    attribute <ref>TZDate</ref>? startDate setraises(<ref>WebAPIException</ref>);

    attribute <ref>TimeDuration</ref>? duration setraises(<ref>WebAPIException</ref>);

    attribute DOMString? location setraises(<ref>WebAPIException</ref>);

    attribute <ref>SimpleCoordinates</ref>? geolocation setraises(<ref>WebAPIException</ref>);

    attribute DOMString? organizer setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarItemVisibility</ref> visibility setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarItemStatus</ref> status setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarItemPriority</ref> priority setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarAlarm</ref>[] alarms setraises(<ref>WebAPIException</ref>);

    attribute DOMString[] categories setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarAttendee</ref>[] attendees setraises(<ref>WebAPIException</ref>);

    DOMString convertToString(<ref>CalendarTextFormat</ref> format) raises(<ref>WebAPIException</ref>);

    <ref>CalendarItem</ref> clone() raises(<ref>WebAPIException</ref>);
  };

  [Constructor(optional <ref>CalendarTaskInit</ref>? taskInitDict),
   Constructor(DOMString stringRepresentation, <ref>CalendarTextFormat</ref> format)]
  interface CalendarTask : <ref>CalendarItem</ref> {
    attribute <ref>TZDate</ref>? dueDate setraises(<ref>WebAPIException</ref>);

    attribute <ref>TZDate</ref>? completedDate setraises(<ref>WebAPIException</ref>);

    attribute unsigned short progress setraises(<ref>WebAPIException</ref>);
  };

  [Constructor(optional <ref>CalendarEventInit</ref>? eventInitDict),
   Constructor(DOMString stringRepresentation, <ref>CalendarTextFormat</ref> format)]
  interface CalendarEvent : <ref>CalendarItem</ref> {
    readonly attribute boolean isDetached;

    attribute <ref>TZDate</ref>? endDate setraises(<ref>WebAPIException</ref>);

    attribute <ref>EventAvailability</ref> availability setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarRecurrenceRule</ref>? recurrenceRule setraises(<ref>WebAPIException</ref>);

    void expandRecurrence(<ref>TZDate</ref> startDate,
                          <ref>TZDate</ref> endDate,
                          <ref>CalendarEventArraySuccessCallback</ref> successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
  };

  dictionary CalendarAttendeeInit {
    DOMString name;
    <ref>AttendeeRole</ref> role;
    <ref>AttendeeStatus</ref> status;
    boolean RSVP;
    <ref>AttendeeType</ref> type;
    DOMString? group;
    DOMString delegatorURI;
    DOMString delegateURI;
    <ref>ContactRef</ref> contactRef;
  };

  [Constructor(DOMString uri, optional <ref>CalendarAttendeeInit</ref>? attendeeInitDict)]
  interface CalendarAttendee
  {
    attribute DOMString uri;

    attribute DOMString? name;

    attribute <ref>AttendeeRole</ref> role;

    attribute <ref>AttendeeStatus</ref> status;

    attribute boolean RSVP;

    attribute <ref>AttendeeType</ref> type;

    attribute DOMString? group;

    attribute DOMString? delegatorURI;

    attribute DOMString? delegateURI;

    attribute <ref>ContactRef</ref>? contactRef;
  };

  dictionary CalendarRecurrenceRuleInit {
    short interval;
    <ref>TZDate</ref> untilDate;
    long occurrenceCount;
    <ref>ByDayValue</ref>[] daysOfTheWeek;
    short[] setPositions;
    <ref>TZDate</ref>[] exceptions;
  };

  [Constructor(<ref>RecurrenceRuleFrequency</ref> frequency, optional <ref>CalendarRecurrenceRuleInit</ref>? ruleInitDict)]
  interface CalendarRecurrenceRule
  {
    attribute <ref>RecurrenceRuleFrequency</ref> frequency;

    attribute unsigned short interval;

    attribute <ref>TZDate</ref>? untilDate;

    attribute long occurrenceCount;

    attribute <ref>ByDayValue</ref>[] daysOfTheWeek;

    attribute short[] setPositions;

    attribute <ref>TZDate</ref>[] exceptions;
  };

  [Constructor(DOMString uid, optional DOMString? rid)]
  interface CalendarEventId {
    attribute DOMString uid;

    attribute DOMString? rid;
  };

  [Constructor(<ref>TZDate</ref> absoluteDate, <ref>AlarmMethod</ref> method, optional DOMString? description),
   Constructor(<ref>TimeDuration</ref> before, <ref>AlarmMethod</ref> method, optional DOMString? description)]
  interface CalendarAlarm {
    attribute <ref>TZDate</ref>? absoluteDate setraises(<ref>WebAPIException</ref>);

    attribute <ref>TimeDuration</ref>? before setraises(<ref>WebAPIException</ref>);

    attribute <ref>AlarmMethod</ref> method setraises(<ref>WebAPIException</ref>);

    attribute DOMString? description;
  };

  [Callback=FunctionOnly, NoInterfaceObject]
  interface CalendarEventArraySuccessCallback {
    void onsuccess(<ref>CalendarEvent</ref>[] events);
  };

  [Callback=FunctionOnly, NoInterfaceObject]
  interface CalendarItemArraySuccessCallback {
    void onsuccess(<ref>CalendarItem</ref>[] items);
  };

  [Callback=FunctionOnly, NoInterfaceObject]
  interface CalendarArraySuccessCallback {
    void onsuccess(<ref>Calendar</ref>[] calendars);
  };

  [Callback, NoInterfaceObject] interface CalendarChangeCallback {
    void onitemsadded(<ref>CalendarItem</ref>[] items);

    void onitemsupdated(<ref>CalendarItem</ref>[] items);

    void onitemsremoved(<ref>CalendarItemId</ref>[] ids);
  };
};</webidl>
    <descriptive>
        <brief>
 This API provides interfaces and methods for users to manage their schedule.
Separate calendars can be implemented for group related events or tasks. For example, a user may have a work, personal, and family calendar. A calendar entry is called an event and is composed of a series of attributes, such as purpose, starting time, and duration. A calendar is a collection of events.
        </brief>
       <description>
        <p>
Internet Calendaring and Scheduling Core Object Specification (iCalendar), defines a format for exchanging event items. Mapping to specified event/task attributes in this API is as per this specification. To know more about this specification, see <a href="http://tools.ietf.org/html/rfc5545">RFC 5545</a>.
        </p>
        <p>
This API provides functionality to read, create, delete, and update items in specific calendars. Calendars can be obtained using the <em>getCalendars() </em>method, which returns an array of Calendar objects.
        </p>
        <p>
For more information on the Calendar features, see <a href="../../org.tizen.web.appprogramming/html/guide/social_guide/calendar.htm">Calendar Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
    </descriptive>
    <Typedef name="CalendarId" id="::Calendar::CalendarId">
      <webidl>  typedef DOMString CalendarId;</webidl>
      <descriptive>
          <brief>
 An attribute to identify the calendar.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="CalendarTaskId" id="::Calendar::CalendarTaskId">
      <webidl>  typedef DOMString CalendarTaskId;</webidl>
      <descriptive>
          <brief>
 An attribute to identify a calendar task.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="CalendarItemId" id="::Calendar::CalendarItemId">
      <webidl>  typedef (<ref>CalendarEventId</ref> or <ref>CalendarTaskId</ref>) CalendarItemId;</webidl>
      <descriptive>
          <brief>
 A calendar item identifier, which can either be a <em>CalendarEventId </em>or a <em>CalendarTaskId</em>.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="union">
        <Type name="CalendarEventId"/>
        <Type name="CalendarTaskId"/>
      </Type>
    </Typedef>
    <Enum name="CalendarType" id="::Calendar::CalendarType">
      <webidl>  enum CalendarType { &quot;EVENT&quot;, &quot;TASK&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the type of a calendar.
          </brief>
         <description>
          <p>
The following types are supported:
          </p>
          <ul>
            <li>
EVENT - if a calendar contains events (VEVENT objects)            </li>
            <li>
TASK - if a calendar contains tasks (VTODO objects)            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="EVENT">
        <webidl> &quot;EVENT</webidl>
      </EnumValue>
      <EnumValue stringvalue="TASK">
        <webidl> &quot;TASK</webidl>
      </EnumValue>
    </Enum>
    <Enum name="CalendarTextFormat" id="::Calendar::CalendarTextFormat">
      <webidl>  enum CalendarTextFormat { &quot;ICALENDAR_20&quot;, &quot;VCALENDAR_10&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the type of textual format of a Calendar.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
ICALENDAR_20 -  if the textual format is iCalendar v2.0            </li>
            <li>
VCALENDAR_10 -  if the textual format is vCalendar v1.0            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="ICALENDAR_20">
        <webidl> &quot;ICALENDAR_20</webidl>
      </EnumValue>
      <EnumValue stringvalue="VCALENDAR_10">
        <webidl> &quot;VCALENDAR_10</webidl>
      </EnumValue>
    </Enum>
    <Enum name="AlarmMethod" id="::Calendar::AlarmMethod">
      <webidl>  enum AlarmMethod { &quot;SOUND&quot;, &quot;DISPLAY&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the type of an alarm.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
SOUND - if sound is played to alert the user            </li>
            <li>
DISPLAY - if display on screen without any sound is used to alert the user            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="SOUND">
        <webidl> &quot;SOUND</webidl>
      </EnumValue>
      <EnumValue stringvalue="DISPLAY">
        <webidl> &quot;DISPLAY</webidl>
      </EnumValue>
    </Enum>
    <Enum name="RecurrenceRuleFrequency" id="::Calendar::RecurrenceRuleFrequency">
      <webidl>  enum RecurrenceRuleFrequency { &quot;DAILY&quot;, &quot;WEEKLY&quot;, &quot;MONTHLY&quot;, &quot;YEARLY&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the type of frequency for the recurrence of an event.
          </brief>
         <description>
          <p>
Only the following values are valid for this attribute:
          </p>
          <ul>
            <li>
DAILY - if the event occurs daily            </li>
            <li>
WEEKLY - if the event occurs weekly            </li>
            <li>
MONTHLY -  if the event occurs monthly            </li>
            <li>
YEARLY - if the event occurs yearly            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="DAILY">
        <webidl> &quot;DAILY</webidl>
      </EnumValue>
      <EnumValue stringvalue="WEEKLY">
        <webidl> &quot;WEEKLY</webidl>
      </EnumValue>
      <EnumValue stringvalue="MONTHLY">
        <webidl> &quot;MONTHLY</webidl>
      </EnumValue>
      <EnumValue stringvalue="YEARLY">
        <webidl> &quot;YEARLY</webidl>
      </EnumValue>
    </Enum>
    <Enum name="ByDayValue" id="::Calendar::ByDayValue">
      <webidl>  enum ByDayValue { &quot;MO&quot;, &quot;TU&quot;, &quot;WE&quot;, &quot;TH&quot;, &quot;FR&quot;, &quot;SA&quot;, &quot;SU&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the values for <em>CalendarRecurrenceRule.daysOfWeek</em>.
          </brief>
         <description>
          <p>
&quot;MO&quot; to &quot;SU&quot; correspond to &quot;Monday&quot; to &quot;Sunday&quot;.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="MO">
        <webidl> &quot;MO</webidl>
      </EnumValue>
      <EnumValue stringvalue="TU">
        <webidl> &quot;TU</webidl>
      </EnumValue>
      <EnumValue stringvalue="WE">
        <webidl> &quot;WE</webidl>
      </EnumValue>
      <EnumValue stringvalue="TH">
        <webidl> &quot;TH</webidl>
      </EnumValue>
      <EnumValue stringvalue="FR">
        <webidl> &quot;FR</webidl>
      </EnumValue>
      <EnumValue stringvalue="SA">
        <webidl> &quot;SA</webidl>
      </EnumValue>
      <EnumValue stringvalue="SU">
        <webidl> &quot;SU</webidl>
      </EnumValue>
    </Enum>
    <Enum name="EventAvailability" id="::Calendar::EventAvailability">
      <webidl>  enum EventAvailability { &quot;BUSY&quot;, &quot;FREE&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the availability of time for an event.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
FREE - if the specified time slot is vacant            </li>
            <li>
BUSY - if the specified time slot is not vacant            </li>
            <li>
BUSY-UNAVAILABLE - if the specified time slot is not vacant and can not be scheduled            </li>
            <li>
BUSY-TENTATIVE - if the specified time slot is not vacant because one or more events have been tentatively scheduled for that interval            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="BUSY">
        <webidl> &quot;BUSY</webidl>
      </EnumValue>
      <EnumValue stringvalue="FREE">
        <webidl> &quot;FREE</webidl>
      </EnumValue>
    </Enum>
    <Enum name="AttendeeType" id="::Calendar::AttendeeType">
      <webidl>  enum AttendeeType { &quot;INDIVIDUAL&quot;, &quot;GROUP&quot;, &quot;RESOURCE&quot;, &quot;ROOM&quot;, &quot;UNKNOWN&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the type of attendee.
          </brief>
         <description>
          <p>
At least the following values must be supported:
          </p>
          <ul>
            <li>
INDIVIDUAL - Individual            </li>
            <li>
GROUP - Group of individuals            </li>
            <li>
RESOURCE - Physical resource            </li>
            <li>
ROOM - Room resource            </li>
            <li>
UNKNOWN - Unknown            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="INDIVIDUAL">
        <webidl> &quot;INDIVIDUAL</webidl>
      </EnumValue>
      <EnumValue stringvalue="GROUP">
        <webidl> &quot;GROUP</webidl>
      </EnumValue>
      <EnumValue stringvalue="RESOURCE">
        <webidl> &quot;RESOURCE</webidl>
      </EnumValue>
      <EnumValue stringvalue="ROOM">
        <webidl> &quot;ROOM</webidl>
      </EnumValue>
      <EnumValue stringvalue="UNKNOWN">
        <webidl> &quot;UNKNOWN</webidl>
      </EnumValue>
    </Enum>
    <Enum name="AttendeeStatus" id="::Calendar::AttendeeStatus">
      <webidl>  enum AttendeeStatus { &quot;PENDING&quot;, &quot;ACCEPTED&quot;, &quot;DECLINED&quot;, &quot;TENTATIVE&quot;, &quot;DELEGATED&quot;, &quot;COMPLETED&quot;, &quot;IN_PROCESS&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the attendance status of a participant.
          </brief>
         <description>
          <p>
At least the following values must be supported:
          </p>
          <ul>
            <li>
PENDING - if the participant has not yet responded to the event            </li>
            <li>
ACCEPTED - if the participant has accepted the event            </li>
            <li>
DECLINED - if the participant has declined the event            </li>
            <li>
TENTATIVE - if the participant has tentatively accepted the event            </li>
            <li>
DELEGATED - if the participant has delegated attendance to another participant            </li>
            <li>
COMPLETED - if the participant's event has been completed            </li>
            <li>
IN_PROCESS - if the participant's event is currently in process            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="PENDING">
        <webidl> &quot;PENDING</webidl>
      </EnumValue>
      <EnumValue stringvalue="ACCEPTED">
        <webidl> &quot;ACCEPTED</webidl>
      </EnumValue>
      <EnumValue stringvalue="DECLINED">
        <webidl> &quot;DECLINED</webidl>
      </EnumValue>
      <EnumValue stringvalue="TENTATIVE">
        <webidl> &quot;TENTATIVE</webidl>
      </EnumValue>
      <EnumValue stringvalue="DELEGATED">
        <webidl> &quot;DELEGATED</webidl>
      </EnumValue>
      <EnumValue stringvalue="COMPLETED">
        <webidl> &quot;COMPLETED</webidl>
      </EnumValue>
      <EnumValue stringvalue="IN_PROCESS">
        <webidl> &quot;IN_PROCESS</webidl>
      </EnumValue>
    </Enum>
    <Enum name="AttendeeRole" id="::Calendar::AttendeeRole">
      <webidl>  enum AttendeeRole { &quot;REQ_PARTICIPANT&quot;, &quot;OPT_PARTICIPANT&quot;, &quot;NON_PARTICIPANT&quot;, &quot;CHAIR&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the role of an attendee.
          </brief>
         <description>
          <p>
At least the following values must be supported:
          </p>
          <ul>
            <li>
REQ_PARTICIPANT - if the participation of an attendee is mandatory            </li>
            <li>
OPT_PARTICIPANT - if the participation of an attendee is optional            </li>
            <li>
NON_PARTICIPANT - if the attendee is not a participant but is copied for information purposes            </li>
            <li>
CHAIR - if the attendee is the chairperson of the event.            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="REQ_PARTICIPANT">
        <webidl> &quot;REQ_PARTICIPANT</webidl>
      </EnumValue>
      <EnumValue stringvalue="OPT_PARTICIPANT">
        <webidl> &quot;OPT_PARTICIPANT</webidl>
      </EnumValue>
      <EnumValue stringvalue="NON_PARTICIPANT">
        <webidl> &quot;NON_PARTICIPANT</webidl>
      </EnumValue>
      <EnumValue stringvalue="CHAIR">
        <webidl> &quot;CHAIR</webidl>
      </EnumValue>
    </Enum>
    <Enum name="CalendarItemPriority" id="::Calendar::CalendarItemPriority">
      <webidl>  enum CalendarItemPriority { &quot;HIGH&quot;, &quot;MEDIUM&quot;, &quot;LOW&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the priority of a calendar item.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
HIGH - if item priority is high            </li>
            <li>
MEDIUM - if item priority is medium            </li>
            <li>
LOW - if item priority is low            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="HIGH">
        <webidl> &quot;HIGH</webidl>
      </EnumValue>
      <EnumValue stringvalue="MEDIUM">
        <webidl> &quot;MEDIUM</webidl>
      </EnumValue>
      <EnumValue stringvalue="LOW">
        <webidl> &quot;LOW</webidl>
      </EnumValue>
    </Enum>
    <Enum name="CalendarItemVisibility" id="::Calendar::CalendarItemVisibility">
      <webidl>   enum CalendarItemVisibility { &quot;PUBLIC&quot;, &quot;PRIVATE&quot;, &quot;CONFIDENTIAL&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the visibility type of a calendar item.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
PUBLIC - if item visibility is public            </li>
            <li>
PRIVATE - if item visibility is private            </li>
            <li>
CONFIDENTIAL - if item visibility is confidential            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="PUBLIC">
        <webidl> &quot;PUBLIC</webidl>
      </EnumValue>
      <EnumValue stringvalue="PRIVATE">
        <webidl> &quot;PRIVATE</webidl>
      </EnumValue>
      <EnumValue stringvalue="CONFIDENTIAL">
        <webidl> &quot;CONFIDENTIAL</webidl>
      </EnumValue>
    </Enum>
    <Enum name="CalendarItemStatus" id="::Calendar::CalendarItemStatus">
      <webidl>   enum CalendarItemStatus { &quot;TENTATIVE&quot;, &quot;CONFIRMED&quot;, &quot;CANCELLED&quot;, &quot;NEEDS_ACTION&quot;, &quot;IN_PROCESS&quot;, &quot;COMPLETED&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the status of a calendar item.
          </brief>
         <description>
          <p>
For an event, the possible values are:
          </p>
          <ul>
            <li>
TENTATIVE - if the event is tentative            </li>
            <li>
CONFIRMED - if the event is confirmed            </li>
            <li>
CANCELLED -  if the event is cancelled            </li>
          </ul>
          <p>
For a task, the possible values are:
          </p>
          <ul>
            <li>
NEEDS_ACTION - if the task needs action            </li>
            <li>
IN_PROCESS -  if the task is in process or being worked on            </li>
            <li>
COMPLETED - if the task has been completed            </li>
            <li>
CANCELLED -  if the task has been cancelled            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="TENTATIVE">
        <webidl> &quot;TENTATIVE</webidl>
      </EnumValue>
      <EnumValue stringvalue="CONFIRMED">
        <webidl> &quot;CONFIRMED</webidl>
      </EnumValue>
      <EnumValue stringvalue="CANCELLED">
        <webidl> &quot;CANCELLED</webidl>
      </EnumValue>
      <EnumValue stringvalue="NEEDS_ACTION">
        <webidl> &quot;NEEDS_ACTION</webidl>
      </EnumValue>
      <EnumValue stringvalue="IN_PROCESS">
        <webidl> &quot;IN_PROCESS</webidl>
      </EnumValue>
      <EnumValue stringvalue="COMPLETED">
        <webidl> &quot;COMPLETED</webidl>
      </EnumValue>
    </Enum>
    <Interface name="CalendarManagerObject" id="::Calendar::CalendarManagerObject">
      <webidl>  [NoInterfaceObject] interface CalendarManagerObject{
    readonly attribute <ref>CalendarManager</ref> calendar;
  };</webidl>
      <descriptive>
          <brief>
 This interface gives access to the Calendar API from the <em>tizen.calendar </em>object.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="calendar" id="::Calendar::CalendarManagerObject::calendar">
        <webidl>    readonly attribute <ref>CalendarManager</ref> calendar;</webidl>
        <Type name="CalendarManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="CalendarManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>CalendarManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="CalendarManager" id="::Calendar::CalendarManager">
      <webidl>  [NoInterfaceObject] interface CalendarManager {
    void getCalendars(<ref>CalendarType</ref> type,
                      <ref>CalendarArraySuccessCallback</ref> successCallback,
                      optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    <ref>Calendar</ref> getUnifiedCalendar(<ref>CalendarType</ref> type) raises(<ref>WebAPIException</ref>);

    <ref>Calendar</ref> getDefaultCalendar(<ref>CalendarType</ref> type) raises(<ref>WebAPIException</ref>);

    <ref>Calendar</ref> getCalendar(<ref>CalendarType</ref> type, <ref>CalendarId</ref> id) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface provides methods to access calendars and attributes for calendars.
Once a calendar object is obtained, it is possible to add, remove, or update the information it contains through the Calendar interface methods.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getCalendars" id="::Calendar::CalendarManager::getCalendars">
        <webidl>    void getCalendars(<ref>CalendarType</ref> type,
                      <ref>CalendarArraySuccessCallback</ref> successCallback,
                      optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets an array of Calendar objects.
            </brief>
           <description>
            <p>
If the operation completes successfully, the <em>successCallback() </em>must be invoked with all the calendars found and available. The first calendar in the list is always the default calendar.
            </p>
            <p>
If no Calendar object is available, the <em>successCallback()</em> is invoked with an empty array.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - if any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - if any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  var calendar;

  function eventFoundCallback(events) {
    // The event has been successfully found
    // Changes the summary
    events[0].summary = 'HTML6 Webinar';
    calendar.update(events[0]);
    console.log('First event was updated!');
  }

  // Defines the error callback for all the asynchronous calls
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  // Defines the success callback for retrieving the list of calendars
  function calendarListCallback(calendars) {
    if(calendars.length > 0) {
      calendar = calendars[0];
      console.log('The calendar id is ' + calendar.id + ' and name ' + calendar.name);

      var ev = new tizen.CalendarEvent({description:'HTML5 Introduction',
                                         summary:'HTML5 Webinar',
                                         startDate: new tizen.TZDate(2011, 3, 30, 10, 0),
                                         duration: new tizen.TimeDuration(1, &quot;HOURS&quot;),
                                         location:'Huesca'});
      calendar.add(ev);

      // The event has been successfully added
      // Checks if the added event can be retrieved from the calendar
      // If the calendar was empty, only the item added through add() should be returned
      var filter = new tizen.AttributeFilter('summary', 'CONTAINS', 'HTML5');
      calendar.find(eventFoundCallback, errorCallback, filter);
    }
  }

  // Gets a list of available calendars
  tizen.calendar.getCalendars(&quot;EVENT&quot;, calendarListCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="type">
            <descriptive>
                <description><p>
 The type of calendar.
                </p></description>
            </descriptive>
            <Type name="CalendarType"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="CalendarArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getUnifiedCalendar" id="::Calendar::CalendarManager::getUnifiedCalendar">
        <webidl>    <ref>Calendar</ref> getUnifiedCalendar(<ref>CalendarType</ref> type) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The unified calendar is the aggregation of all calendars that are obtained from <em>getCalendars</em> and contains all events or tasks. It does not have the calendar id nor name which are set to <var>null</var>.
            </brief>
           <description>
            <p>
If an item is added to the unified calendar, it will be saved in the default calendar.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  var unifiedCalendar;

  // Defines the error callback for all the asynchronous calls
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  function eventFoundCallback(events) {
    // The event has been successfully found
    // Changes the summary
    events[0].summary = 'HTML6 Webinar';
    unifiedCalendar.update(events[0]);
    console.log('First event was updated!');
  }

  // Gets the unified calendar
  unifiedCalendar = tizen.calendar.getUnifiedCalendar(&quot;EVENT&quot;);

  var ev = new tizen.CalendarEvent({description:'HTML5 Introduction',
                                    summary:'HTML5 Webinar ',
                                    startDate: new tizen.TZDate(2011, 3, 30, 10, 0),
                                    duration: new tizen.TimeDuration(1, &quot;HOURS&quot;),
                                    location:'Huesca'});

  unifiedCalendar.add(ev);

  // The event has been added
  // Checks if the added event can be retrieved from the calendar
  // If the calendar was empty, only the item added through add() should be returned
  var filter = new tizen.AttributeFilter('summary', 'CONTAINS', 'HTML5');
  unifiedCalendar.find(eventFoundCallback, errorCallback, filter);

</Code>
        </descriptive>
        <Type name="Calendar">
          <descriptive>
              <description><p>
 Calendar The unified Calendar object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="type">
            <descriptive>
                <description><p>
 The type of a calendar.
                </p></description>
            </descriptive>
            <Type name="CalendarType"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getDefaultCalendar" id="::Calendar::CalendarManager::getDefaultCalendar">
        <webidl>    <ref>Calendar</ref> getDefaultCalendar(<ref>CalendarType</ref> type) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the default calendar, which is used for new items.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  var myCalendar;

  // Defines the error callback for all the asynchronous calls
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  function eventFoundCallback(events) {
    // The event has been successfully found
    // Changes the summary
    events[0].summary = 'HTML6 Webinar';
    myCalendar.update(events[0]);
    console.log('First event was updated!');
  }

  // Gets the default calendar
  myCalendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  var ev = new tizen.CalendarEvent({description:'HTML5 Introduction',
                                    summary:'HTML5 Webinar ',
                                    startDate: new tizen.TZDate(2011, 3, 30, 10, 0),
                                    duration: new tizen.TimeDuration(1, &quot;HOURS&quot;),
                                    location:'Huesca'});

  myCalendar.add(ev);

  // The event has been added
  // Checks if the added event can be retrieved from the calendar
  // If the calendar was empty, only the item added through add() should be returned
  var filter = new tizen.AttributeFilter('summary', 'CONTAINS', 'HTML5');
  myCalendar.find(eventFoundCallback, errorCallback, filter);

</Code>
        </descriptive>
        <Type name="Calendar">
          <descriptive>
              <description><p>
 Calendar The default Calendar object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="type">
            <descriptive>
                <description><p>
 The type of a calendar.
                </p></description>
            </descriptive>
            <Type name="CalendarType"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getCalendar" id="::Calendar::CalendarManager::getCalendar">
        <webidl>    <ref>Calendar</ref> getCalendar(<ref>CalendarType</ref> type, <ref>CalendarId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the calendar with the specified identifier and type.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  var calendarId; // calendarId supposed to be initialized
  try {
    var calendar = tizen.calendar.getCalendar(&quot;EVENT&quot;, calendarId);
    console.log(&quot;Successfully retrieved event calendar with id: &quot; + calendarId);
  } catch(err) {
    console.log(&quot;Error: &quot; + err.name);
  }
 </Code>
        </descriptive>
        <Type name="Calendar">
          <descriptive>
              <description><p>
 Calendar The matching Calendar object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="type">
            <descriptive>
                <description><p>
 The type of a calendar.
                </p></description>
            </descriptive>
            <Type name="CalendarType"/>
          </Argument>
          <Argument name="id">
            <descriptive>
                <description><p>
 The calendar identifier.
                </p></description>
            </descriptive>
            <Type name="CalendarId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if there is no calendar with the given identifier.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Calendar" id="::Calendar::Calendar">
      <webidl>  [NoInterfaceObject] interface Calendar {

    readonly attribute <ref>CalendarId</ref> id;

    readonly attribute DOMString name;

    <ref>CalendarItem</ref> get(<ref>CalendarItemId</ref> id) raises(<ref>WebAPIException</ref>);

    void add(<ref>CalendarItem</ref> item) raises(<ref>WebAPIException</ref>);

    void addBatch(<ref>CalendarItem</ref>[] items,
                  optional <ref>CalendarItemArraySuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void update(<ref>CalendarItem</ref> item,
                optional boolean? updateAllInstances) raises(<ref>WebAPIException</ref>);

     void updateBatch(<ref>CalendarItem</ref>[] items,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback,
                     optional boolean? updateAllInstances) raises(<ref>WebAPIException</ref>);

    void remove(<ref>CalendarItemId</ref> id) raises(<ref>WebAPIException</ref>);

    void removeBatch(<ref>CalendarItemId</ref>[] ids,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void find(<ref>CalendarItemArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);

    long addChangeListener(<ref>CalendarChangeCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);

    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface that has methods to manage events or tasks in a calendar. A Calendar object contains a set of events or tasks, depending on the calendar type.
          </brief>
         <description>
          <p>
This interface offers the following methods to manage events in a calendar:
          </p>
          <ul>
            <li>
 Finding items using a key-value filter.            </li>
            <li>
 Adding items to a specific calendar using <em>add() </em>/ <em>addBatch() </em>methods.            </li>
            <li>
 Updating existing items using <em>update() </em>/ <em>updateBatch()</em> methods.            </li>
            <li>
 Deleting existing items using <em>remove()</em> / <em>removeBatch() </em>methods.            </li>
            <li>
 Tracking calendar changes using <em>addChangeListener()</em> / <em>removeChangeListener() </em>methods.            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Calendar::Calendar::id">
        <webidl>    readonly attribute <ref>CalendarId</ref> id;</webidl>
        <descriptive>
            <brief>
 An attribute to uniquely identify a calendar.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="CalendarId"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Calendar::Calendar::name">
        <webidl>    readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 An attribute to assign a readable (descriptive) name for a calendar, such as work, personal, etc.
            </brief>
            <version>
 1.0
            </version>
            <Code>  // Gets the default calendar and show its name
  var calendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);
  console.log('The calendar name is ' + calendar.name);
 </Code>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Operation name="get" id="::Calendar::Calendar::get">
        <webidl>    <ref>CalendarItem</ref> get(<ref>CalendarItemId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the calendar item with the specified identifier.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  var myCalendar; // Calendar supposed to be initialized
  var itemId; // Calendar item identifier
  try {
    var item = myCalendar.get(itemId);
    console.log(&quot;Successfully retrieved item with id: &quot; + itemId);
  } catch(err) {
    console.log(&quot;Error: &quot; + err.name);
  }
 </Code>
        </descriptive>
        <Type name="CalendarItem">
          <descriptive>
              <description><p>
 CalendarItem The matching <em>CalendarItem </em>object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The Calendar item identifier.
                </p></description>
            </descriptive>
            <Type name="CalendarItemId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if there is no calendar item with the given identifier.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="add" id="::Calendar::Calendar::add">
        <webidl>    void add(<ref>CalendarItem</ref> item) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds an item to the calendar synchronously.
            </brief>
           <description>
            <p>
If the item is successfully inserted in the calendar, the <em>CalendarItem </em>will have its identifier (id attribute) set when the method returns.
            </p>
            <p>
To update an existing item, call the <em>update() </em>method instead. If you wish to add a copy of an existing <em>CalendarItem </em>object, call <em>CalendarItem.clone()</em> method first and pass the clone to the <em>add()</em> method.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.write
            </privilege>
            <Code>  // Gets the default calendar
  var calendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  var ev = new tizen.CalendarEvent({description:'HTML5 Introduction',
                                   summary:'HTML5 Webinar ',
                                   startDate: new tizen.TZDate(2011, 3, 30, 10, 0),
                                   duration: new tizen.TimeDuration(1, &quot;HOURS&quot;),
                                   location:'Huesca'});

  calendar.add(ev);
  console.log('Event added with uid ' + ev.id.uid);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="item">
            <descriptive>
                <description><p>
 The calendar item to be added.
                </p></description>
            </descriptive>
            <Type name="CalendarItem"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addBatch" id="::Calendar::Calendar::addBatch">
        <webidl>    void addBatch(<ref>CalendarItem</ref>[] items,
                  optional <ref>CalendarItemArraySuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds an array of items to the calendar asynchronously.
            </brief>
           <description>
            <p>
If all the items are successfully added to the calendar, the success callback will be invoked, passing the list of <em>CalendarItem </em>objects that were added, with their identifier set (id attribute).
            </p>
            <p>
The <em>errorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - if any of the input parameters contain an invalid value, the item has any invalid value or the calendar has some restrictions that cause the attempted insertion of the calendar items to fail (for example, limitations in the size of text attributes)              </li>
              <li>
UnknownError - if any other error occurs.               </li>
            </ul>
            <p>
If you wish to update an existing item, call the <em>update() </em>method instead. If you wish to add a copy of an existing <em>CalendarItem </em>object, call CalendarItem.clone() method first and pass the clone to the add() method.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.write
            </privilege>
            <Code>  // Defines the error callback.
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  function addEventsSuccess(events) {
    console.log(&quot;Successfully added &quot; + events.length + &quot; events!&quot;);
  }

  // Gets the default calendar
  var calendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  var ev = new tizen.CalendarEvent({description:'HTML5 Introduction',
                                   summary:'HTML5 Webinar ',
                                   startDate: new tizen.TZDate(2011, 3, 30, 10, 0),
                                   duration: new tizen.TimeDuration(1, &quot;HOURS&quot;),
                                   location:'Huesca'});

  calendar.addBatch([ev], addEventsSuccess, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="items">
            <descriptive>
                <description><p>
 The list of calendar items to add.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CalendarItem"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="CalendarItemArraySuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when the request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="update" id="::Calendar::Calendar::update">
        <webidl>    void update(<ref>CalendarItem</ref> item,
                optional boolean? updateAllInstances) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates an existing item in the calendar synchronously with the one specified in the argument.
            </brief>
           <description>
            <p>
In case of recurring events, the default behavior is to update all their instances (including their detached ones), as well. If you don't want that, the <em>updateAllInstances</em> flag should be set to <var>false</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.write
            </privilege>
            <Code>  var myCalendar;

  // Defines the error callback.
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  // Defines the event success callback.
  function eventSearchSuccessCallback(events) {
    events[0].description = 'New Description';
    // Updates the first existing event.
    myCalendar.update(events[0]);
    console.log(&quot;The first item description was updated!&quot;);
  }

  // Gets the default calendar
  myCalendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  // Finds all events in a Calendar
  myCalendar.find(eventSearchSuccessCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="item">
            <descriptive>
                <description><p>
 The Item object to update.
                </p></description>
            </descriptive>
            <Type name="CalendarItem"/>
          </Argument>
          <Argument optional="optional" name="updateAllInstances">
            <descriptive>
                <description><p>
 The flag indicating whether all the event instances should be updated as well or not (default value is <var>true</var>). This parameter only applies to calendar events, and doesn't apply to tasks.
                </p></description>
            </descriptive>
            <Type type="boolean" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="updateBatch" id="::Calendar::Calendar::updateBatch">
        <webidl>     void updateBatch(<ref>CalendarItem</ref>[] items,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback,
                     optional boolean? updateAllInstances) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates an array of existing items in the calendar asynchronously with the specified values in the argument.
            </brief>
           <description>
            <p>
In case of recurring events, the default behavior is to update all their instances (including their detached ones) as well. The <em>updateAllInstances</em> flag should be set to <var>false</var> to change the default behavior.
            </p>
            <p>
The <em>errorCallback() </em>is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - if parameters such as the calendar item has any invalid value or the calendar has some restrictions that cause the attempted insertion of the calendar items to fail (for example, limitations in the size of text attributes).              </li>
              <li>
UnknownError - if any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.write
            </privilege>
            <Code>  var myCalendar;

  // Defines the error callback.
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  // Defines the success callback
  function updateEventsSuccess() {
    console.log(&quot;Successfully updated !&quot; );
  }

  // Defines the event success callback.
  function eventSearchSuccessCallback(events) {
    events[0].description = 'New Description 1';
    events[1].description = 'New Description 2';
    // Update the first two existing events.
    myCalendar.updateBatch(events.slice(0,2), updateEventsSuccess, errorCallback);
  }

  // Gets the default calendar
  myCalendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  // Finds all events in Calendar
  myCalendar.find(eventSearchSuccessCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="items">
            <descriptive>
                <description><p>
 The list of calendar item objects to update.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CalendarItem"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the <em>updateEvents() </em>request succeeds.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when the <em>updateEvents() </em>request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="updateAllInstances">
            <descriptive>
                <description><p>
 The flag indicating whether all the event instances should be updated or not. Default value for this flag is <var>true</var>). This parameter applies only to calendar events, doesn't apply to tasks.
                </p></description>
            </descriptive>
            <Type type="boolean" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::Calendar::Calendar::remove">
        <webidl>    void remove(<ref>CalendarItemId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes an item from the calendar that corresponds to the specified identifier. This method will throw an exception if it fails to remove the specified calendar item.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.write
            </privilege>
            <remark>
 <b>For (recurring) events:</b> In the case of calendar events, if the recurrence id (<em>rid</em> attribute) is set to <var>null</var>, this method will remove the event identified by <em>uid</em>, and all of its possible detached instances.
            </remark>
            <Code>  var myCalendar;

  // Defines the error callback.
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  // Defines the event success callback.
  function eventSearchSuccessCallback(events) {
    // Deletes the first existing event.
    myCalendar.remove(events[0].id);
    console.log('The first event was removed');
  }

  // Gets default calendar
  myCalendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  // Finds all events in Calendar
  myCalendar.find(eventSearchSuccessCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The identifier (ID attribute) of the item object to delete.
                </p></description>
            </descriptive>
            <Type name="CalendarItemId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any item in the calendar.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if the item could not be removed because of an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeBatch" id="::Calendar::Calendar::removeBatch">
        <webidl>    void removeBatch(<ref>CalendarItemId</ref>[] ids,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes several items from the calendar asynchronously depending on the specified identifiers.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - if an identifier in the <em>ids </em>parameter does not correspond to the ID attribute of an item in the calendar.              </li>
              <li>
InvalidValuesError - if any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - if any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.write
            </privilege>
            <remark>
 <b>For (recurring) events:</b> In the case of calendar events, if the recurrence id, <em>rid</em>, is set to <var>null</var>, this method will remove the event identified by <em>uid</em>, as well as all its possible detached instances.
            </remark>
            <Code>  var myCalendar;

  // Defines the error callback.
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  // Defines the removeBatch callback
  function removeBatchCallback() {
    console.log(&quot;Requested events were successfully removed.&quot;);
  }

  // Defines the event search success callback.
  function eventSearchSuccessCallback(events) {
    // Deletes the first two existing events.
    myCalendar.removeBatch([events[0].id, events[1].id],
                           removeBatchCallback,
                           errorCallback);
  }

  // Gets default calendar
  myCalendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  // Retrieves all events in Calendar
  myCalendar.find(eventSearchSuccessCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="ids">
            <descriptive>
                <description><p>
 The identifiers (<em>id </em>attribute) of the items to delete.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CalendarItemId"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the <em>removeBatch()</em> request succeeds.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when the <em>removeBatch()</em> request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="find" id="::Calendar::Calendar::find">
        <webidl>    void find(<ref>CalendarItemArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Finds and fetches an array of <em>CalendarItem </em>objects for items stored in the calendar according to the supplied filter if it is valid else it will return all the items stored.
            </brief>
           <description>
            <p>
If the filter is passed and contains valid values, only those values in the calendar that match the filter criteria as specified in the <em>AbstractFilter </em>interface will be returned in the <em>successCallback()</em>.
If no filter is passed, or the filter contains any invalid value which is <var>null </var>or undefined, then the implementation must return the full list of items in the <em>successCallback()</em>.
If no items are available in the calendar (it is empty) or no item matches the filter criteria, the <em>successCallback() </em>will be invoked with an empty array.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - if any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - if any other error occurs.              </li>
            </ul>
            <p>
<b>Filter specific remarks:</b>            </p>
            <ul>
              <li>
For event filtering based on start/end dates, items that recur during the given time interval will be found, even if the parent item itself is outside the interval.              </li>
              <li>
For event filtering based on the identifier, the identifier type should be CalendarEventID (<em>uid</em> and <em>rid</em>).
If no recurrence ID is given, the filter will match both the parent event and all its detached instances.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  // Defines the error callback.
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  // Defines the event search success callback.
  function eventSearchSuccessCallback(events) {
    console.log(events.length + ' results found.');
  }

  // Gets default calendar
  var calendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  // Finds all events the calendar that contain in the summary the string Tizen.
  var filter = new tizen.AttributeFilter('summary', 'CONTAINS', 'Tizen');

  // The events returned by the find() query will be sorted by ascending summary
  var sortingMode = new tizen.SortMode('summary', 'ASC');

  calendar.find(eventSearchSuccessCallback, errorCallback, filter, sortingMode);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="CalendarItemArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 The supplied data used to filter the results of the <em>find() </em>method.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="sortMode">
            <descriptive>
                <description><p>
 The sort order in which the items return.
                </p></description>
            </descriptive>
            <Type name="SortMode" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addChangeListener" id="::Calendar::Calendar::addChangeListener">
        <webidl>    long addChangeListener(<ref>CalendarChangeCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a listener to receive notifications about calendar changes.
            </brief>
           <description>
            <p>
When executed, the implementation must immediately return a subscription identifier that identifies the watch operation. After returning the identifier, the watcher methods are invoked asynchronously.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  var watcherId = 0; // watcher identifier
  var calendar; // This example assumes calendar is initialized

  var watcher = {
    onitemsadded: function(items) {
      console.log(items.length + ' items were added');
    },
    onitemsupdated: function(items) {
      console.log(items.length + ' items were updated');
    },
    onitemsremoved: function(ids) {
      console.log(ids.length + ' items were removed');
    }
  };

  // Registers to be notified when the calendar changes
  watcherId = calendar.addChangeListener(watcher);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The identifier used to clear the watch subscription.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The methods to invoke on receiving calendar change notifications.
                </p></description>
            </descriptive>
            <Type name="CalendarChangeCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeChangeListener" id="::Calendar::Calendar::removeChangeListener">
        <webidl>    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsubscribes from receiving notification for a calendar item changes.
            </brief>
           <description>
            <p>
If the <em>watchId </em>argument is valid and corresponds to a subscription already in place, the watch process must immediately stop and no further callbacks must be invoked. If the <em>watchId </em>argument is not valid or does not correspond to a valid subscription, the method should return without any further action.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  var watcherId = 0; // watcher identifier
  var calendar; // This example assumes calendar is initialized

  // Receives calendar changes
  var watcher = {
    onitemsadded: function(items) {
      console.log(items.length + ' items were added');
    },
    onitemsupdated: function(items) {
      console.log(evitemsents.length + ' items were updated');
    },
    onitemsremoved: function(ids) {
      console.log(ids.length + ' items were removed');
    }
  };

  // Registers to be notified when the calendar changes
  watcherId = calendar.addChangeListener(watcher);

  // Cancels the watch operation
  calendar.removeChangeListener(watcherId);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="watchId">
            <descriptive>
                <description><p>
 Subscription Identifier.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Dictionary name="CalendarItemInit" id="::Calendar::CalendarItemInit">
      <webidl>  dictionary CalendarItemInit {
    DOMString description;
    DOMString summary;
    boolean isAllDay;
    <ref>TZDate</ref> startDate;
    <ref>TimeDuration</ref> duration;
    DOMString location;
    <ref>SimpleCoordinates</ref> geolocation;
    DOMString organizer;
    <ref>CalendarItemVisibility</ref> visibility;
    <ref>CalendarItemStatus</ref> status;
    <ref>CalendarItemPriority</ref> priority;
    <ref>CalendarAlarm</ref>[] alarms;
    DOMString[] categories;
    <ref>CalendarAttendee</ref>[] attendees;
  };</webidl>
      <descriptive>
          <brief>
 A dictionary that is used for creating calendar items.
          </brief>
         <description>
          <p>
These attributes are shared by both calendar events and tasks.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="description" id="::Calendar::CalendarItemInit::description">
        <webidl>    DOMString description;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="summary" id="::Calendar::CalendarItemInit::summary">
        <webidl>    DOMString summary;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="isAllDay" id="::Calendar::CalendarItemInit::isAllDay">
        <webidl>    boolean isAllDay;</webidl>
        <Type type="boolean"/>
      </DictionaryMember>
      <DictionaryMember name="startDate" id="::Calendar::CalendarItemInit::startDate">
        <webidl>    <ref>TZDate</ref> startDate;</webidl>
        <Type name="TZDate"/>
      </DictionaryMember>
      <DictionaryMember name="duration" id="::Calendar::CalendarItemInit::duration">
        <webidl>    <ref>TimeDuration</ref> duration;</webidl>
        <Type name="TimeDuration"/>
      </DictionaryMember>
      <DictionaryMember name="location" id="::Calendar::CalendarItemInit::location">
        <webidl>    DOMString location;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="geolocation" id="::Calendar::CalendarItemInit::geolocation">
        <webidl>    <ref>SimpleCoordinates</ref> geolocation;</webidl>
        <Type name="SimpleCoordinates"/>
      </DictionaryMember>
      <DictionaryMember name="organizer" id="::Calendar::CalendarItemInit::organizer">
        <webidl>    DOMString organizer;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="visibility" id="::Calendar::CalendarItemInit::visibility">
        <webidl>    <ref>CalendarItemVisibility</ref> visibility;</webidl>
        <Type name="CalendarItemVisibility"/>
      </DictionaryMember>
      <DictionaryMember name="status" id="::Calendar::CalendarItemInit::status">
        <webidl>    <ref>CalendarItemStatus</ref> status;</webidl>
        <Type name="CalendarItemStatus"/>
      </DictionaryMember>
      <DictionaryMember name="priority" id="::Calendar::CalendarItemInit::priority">
        <webidl>    <ref>CalendarItemPriority</ref> priority;</webidl>
        <Type name="CalendarItemPriority"/>
      </DictionaryMember>
      <DictionaryMember name="alarms" id="::Calendar::CalendarItemInit::alarms">
        <webidl>    <ref>CalendarAlarm</ref>[] alarms;</webidl>
        <Type type="array">
          <Type name="CalendarAlarm"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="categories" id="::Calendar::CalendarItemInit::categories">
        <webidl>    DOMString[] categories;</webidl>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="attendees" id="::Calendar::CalendarItemInit::attendees">
        <webidl>    <ref>CalendarAttendee</ref>[] attendees;</webidl>
        <Type type="array">
          <Type name="CalendarAttendee"/>
        </Type>
      </DictionaryMember>
    </Dictionary>
    <Dictionary name="CalendarTaskInit" id="::Calendar::CalendarTaskInit">
      <webidl>  dictionary CalendarTaskInit: <ref>CalendarItemInit</ref> {
    <ref>TZDate</ref> dueDate;
    <ref>TZDate</ref> completedDate;
    short progress;
  };</webidl>
      <descriptive>
          <brief>
 A dictionary that is used for creating calendar tasks.
          </brief>
         <description>
          <p>
It also provides an interface for specifying task attributes upon task creation (in the <em>CalendarTask </em>constructor).
          </p>
          <p>
All the attributes are optional and are undefined by default.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryInheritance>
        <Name name="CalendarItemInit"/>
      </DictionaryInheritance>
      <DictionaryMember name="dueDate" id="::Calendar::CalendarTaskInit::dueDate">
        <webidl>    <ref>TZDate</ref> dueDate;</webidl>
        <Type name="TZDate"/>
      </DictionaryMember>
      <DictionaryMember name="completedDate" id="::Calendar::CalendarTaskInit::completedDate">
        <webidl>    <ref>TZDate</ref> completedDate;</webidl>
        <Type name="TZDate"/>
      </DictionaryMember>
      <DictionaryMember name="progress" id="::Calendar::CalendarTaskInit::progress">
        <webidl>    short progress;</webidl>
        <Type type="short"/>
      </DictionaryMember>
    </Dictionary>
    <Dictionary name="CalendarEventInit" id="::Calendar::CalendarEventInit">
      <webidl>  dictionary CalendarEventInit: <ref>CalendarItemInit</ref> {
    <ref>TZDate</ref> endDate;
    <ref>EventAvailability</ref> availability;
    <ref>CalendarRecurrenceRule</ref> recurrenceRule;
  };</webidl>
      <descriptive>
          <brief>
 A dictionary that is used for creating calendar events.
          </brief>
         <description>
          <p>
Provides an interface for specifying event attributes upon event creation (in the <em>CalendarEvent </em>constructor).
          </p>
          <p>
All the attributes are optional and are undefined by default.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryInheritance>
        <Name name="CalendarItemInit"/>
      </DictionaryInheritance>
      <DictionaryMember name="endDate" id="::Calendar::CalendarEventInit::endDate">
        <webidl>    <ref>TZDate</ref> endDate;</webidl>
        <Type name="TZDate"/>
      </DictionaryMember>
      <DictionaryMember name="availability" id="::Calendar::CalendarEventInit::availability">
        <webidl>    <ref>EventAvailability</ref> availability;</webidl>
        <Type name="EventAvailability"/>
      </DictionaryMember>
      <DictionaryMember name="recurrenceRule" id="::Calendar::CalendarEventInit::recurrenceRule">
        <webidl>    <ref>CalendarRecurrenceRule</ref> recurrenceRule;</webidl>
        <Type name="CalendarRecurrenceRule"/>
      </DictionaryMember>
    </Dictionary>
    <Interface name="CalendarItem" id="::Calendar::CalendarItem">
      <webidl>  [NoInterfaceObject] interface CalendarItem {
    readonly attribute <ref>CalendarItemId</ref>? id;

    readonly attribute <ref>CalendarId</ref>? calendarId;

    readonly attribute <ref>TZDate</ref>? lastModificationDate;

    attribute DOMString? description setraises(<ref>WebAPIException</ref>);

    attribute DOMString? summary setraises(<ref>WebAPIException</ref>);

    attribute boolean isAllDay setraises(<ref>WebAPIException</ref>);

    attribute <ref>TZDate</ref>? startDate setraises(<ref>WebAPIException</ref>);

    attribute <ref>TimeDuration</ref>? duration setraises(<ref>WebAPIException</ref>);

    attribute DOMString? location setraises(<ref>WebAPIException</ref>);

    attribute <ref>SimpleCoordinates</ref>? geolocation setraises(<ref>WebAPIException</ref>);

    attribute DOMString? organizer setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarItemVisibility</ref> visibility setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarItemStatus</ref> status setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarItemPriority</ref> priority setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarAlarm</ref>[] alarms setraises(<ref>WebAPIException</ref>);

    attribute DOMString[] categories setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarAttendee</ref>[] attendees setraises(<ref>WebAPIException</ref>);

    DOMString convertToString(<ref>CalendarTextFormat</ref> format) raises(<ref>WebAPIException</ref>);

    <ref>CalendarItem</ref> clone() raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This is a parent interface that is used to create Calendar events and tasks.
These attributes are shared by both events and tasks.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Calendar::CalendarItem::id">
        <webidl>    readonly attribute <ref>CalendarItemId</ref>? id;</webidl>
        <descriptive>
            <brief>
 An attribute to persistently and uniquely identify an item in implementation.
            </brief>
           <description>
            <p>
Includes a UID and a possible recurrence ID that is needed to identify a particular instance of a recurring event.
            </p>
            <p>
By default, this attribute is set to null.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="CalendarItemId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="calendarId" id="::Calendar::CalendarItem::calendarId">
        <webidl>    readonly attribute <ref>CalendarId</ref>? calendarId;</webidl>
        <descriptive>
            <brief>
 An attribute to identify the calendar in which this item is saved.
            </brief>
           <description>
            <p>
By default, this attribute is set to null.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="CalendarId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="lastModificationDate" id="::Calendar::CalendarItem::lastModificationDate">
        <webidl>    readonly attribute <ref>TZDate</ref>? lastModificationDate;</webidl>
        <descriptive>
            <brief>
 An attribute to identify the last modified date and time of an item.
            </brief>
           <description>
            <p>
This attribute is automatically populated and cannot be edited by the client.
(See RFC 5545 - Section 3.8.7.3).
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TZDate" nullable="nullable"/>
      </Attribute>
      <Attribute name="description" id="::Calendar::CalendarItem::description">
        <webidl>    attribute DOMString? description setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the textual descriptions of an item.
            </brief>
           <description>
            <p>
It is usually used to provide a more complete description of the item and any supporting information than what is provided in the summary attribute.
(See RFC 5545 - Section 3.8.1.5).
            </p>
            <p>
The default value is an empty string.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  event.description = 'Tizen Codefest';
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="summary" id="::Calendar::CalendarItem::summary">
        <webidl>    attribute DOMString? summary setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store a short summary or subject for an item.
(See RFC 5545 - Section 3.8.1.12)
            </brief>
           <description>
            <p>
The default value is an empty string.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  event.summary = 'Launching the Tizen reference implementation';
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="isAllDay" id="::Calendar::CalendarItem::isAllDay">
        <webidl>    attribute boolean isAllDay setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute that behaves like a flag to indicate whether an event is an all-day event or not.
            </brief>
           <description>
            <p>
If set to <var>true</var>, then the time and time zone of the <em>startDate </em>are to be ignored and are not guaranteed to be stored in the database. An all-day event always covers the whole day, regardless of which time zone it was defined in and what the current time zone is. The duration must be <var>n*60*24 </var>minutes for an event lasting <var>n</var> days.
            </p>
            <p>
The default value for this attribute is <var>false</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  event.isAllDay = true; // All-Day event
 </Code>
        </descriptive>
        <Type type="boolean"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="startDate" id="::Calendar::CalendarItem::startDate">
        <webidl>    attribute <ref>TZDate</ref>? startDate setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the start date/time for an item.
(see RFC 5545 - Section 3.8.2.4).
            </brief>
           <description>
            <p>
The default value for this attribute is <var>null</var>.
            </p>
            <p>
<em>startDate</em> must be specified in the same time zone as <em>endDate / dueDate</em> if provided.
            </p>
           </description>
            <version>
 1.0
            </version>
           <description>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
           </description>
            <Code>  // 2010-04-30 09:00
  event.startDate = new tizen.TZDate(2010, 3, 30, 9, 0);
 </Code>
        </descriptive>
        <Type name="TZDate" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="duration" id="::Calendar::CalendarItem::duration">
        <webidl>    attribute <ref>TimeDuration</ref>? duration setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to denote the duration of the calendar component.
(See RFC 5545 - Section 3.8.2.5).
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
            <p>
<em>duration</em> and <em>endDate / dueDate</em> are mutually exclusive, hence, only one of them can be non-null.
            </p>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
           </description>
            <remark>
 Note that the implementation may not save the duration itself, rather convert it to the corresponding endDate/dueDate attribute and save it. For example, if you set the startDate and the duration attributes and save the item, you may see that the duration is <var>null</var> while endDate/dueDate is non-null after retrieving it because the implementation has calculated the endDate/dueDate based on the duration and the startDate then saved it, not the duration.
            </remark>
            <version>
 1.0
            </version>
            <Code>  // 1 hour meeting
  event.duration = new tizen.TimeDuration(1, &quot;HOURS&quot;);
 </Code>
        </descriptive>
        <Type name="TimeDuration" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="location" id="::Calendar::CalendarItem::location">
        <webidl>    attribute DOMString? location setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the location or the intended venue for the activity defined by the calendar item.
(See RFC 5545 - Section 3.8.1.7)
            </brief>
           <description>
            <p>
The default value for this attribute is an empty string.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  event.location = 'Huesca';
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="geolocation" id="::Calendar::CalendarItem::geolocation">
        <webidl>    attribute <ref>SimpleCoordinates</ref>? geolocation setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the global position latitude and longitude of the location where the event is planned to take place.
(See RFC 5545 - Section 3.8.1.6).
            </brief>
            <version>
 1.0
            </version>
            <Code>  event.geolocation = new tizen.SimpleCoordinates(60.175, 24.934);
 </Code>
        </descriptive>
        <Type name="SimpleCoordinates" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="organizer" id="::Calendar::CalendarItem::organizer">
        <webidl>    attribute DOMString? organizer setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the name of the person who organized this event.
(See RFC 5545 - Section 3.8.4.3).
            </brief>
           <description>
            <p>
By default, this attribute is initialized to an empty string.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  event.organizer = 'Mr. Jones';
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="visibility" id="::Calendar::CalendarItem::visibility">
        <webidl>    attribute <ref>CalendarItemVisibility</ref> visibility setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to mark the visibility (secrecy) level of the item.
(See RFC 5545 - Section 3.8.1.3).
            </brief>
           <description>
            <p>
The default value is <var>PUBLIC</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="CalendarItemVisibility"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="status" id="::Calendar::CalendarItem::status">
        <webidl>    attribute <ref>CalendarItemStatus</ref> status setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the overall confirmation status for a calendar component.
(See RFC 5545 - Section 3.8.1.11).
            </brief>
           <description>
            <p>
For an event, the default value is <var>CONFIRMED</var>. For a task, the default value is <var>NEEDS_ACTION</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  event.status = &quot;TENTATIVE&quot;;
 </Code>
        </descriptive>
        <Type name="CalendarItemStatus"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="priority" id="::Calendar::CalendarItem::priority">
        <webidl>    attribute <ref>CalendarItemPriority</ref> priority setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the priority level of an item and may be used to relatively prioritize multiple items during a given period of time.
(See RFC 5545 - Section 3.8.1.9).
            </brief>
           <description>
            <p>
The default value for this attribute is <var>LOW </var>priority.
            </p>
            <p>
If the native item database supports another priority schema (such as a range from 1 to 9), the implementation must convert those values to the supported values. For instance, RFC 5545 suggests the following mapping for a range from 1 to 9:
            </p>
            <ul>
              <li>
1-4 to HIGH,              </li>
              <li>
5 to MEDIUM,              </li>
              <li>
6-9 to LOW.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <Code>  task.priority = &quot;HIGH&quot;;
 </Code>
        </descriptive>
        <Type name="CalendarItemPriority"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="alarms" id="::Calendar::CalendarItem::alarms">
        <webidl>    attribute <ref>CalendarAlarm</ref>[] alarms setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute array to lists the alarms (or reminders) associated to an item.
            </brief>
            <version>
 1.0
            </version>
            <Code>  ev.startDate = new tizen.TZDate(2011, 2, 11, 8, 0, 0);
  // Gives a sound notification 30 minutes before the item's start time
  var alarm = new tizen.CalendarAlarm(new tizen.TimeDuration(30, &quot;MINS&quot;),
                                       &quot;SOUND&quot;);
  ev.alarms = [alarm];
 </Code>
        </descriptive>
        <Type type="array">
          <Type name="CalendarAlarm"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="categories" id="::Calendar::CalendarItem::categories">
        <webidl>    attribute DOMString[] categories setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the item categories or subtypes of a calendar component. The categories are useful in searching for a calendar component of a particular type and category.
(See RFC 5545 - Section 3.8.1.2).
            </brief>
           <description>
            <p>
Examples of categories are personal, work, vacation, travel, etc.
            </p>
            <p>
By default, this attribute is set to an empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  event.categories = ['Personal'];
 </Code>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="attendees" id="::Calendar::CalendarItem::attendees">
        <webidl>    attribute <ref>CalendarAttendee</ref>[] attendees setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute array that lists the people attending an event.
(See RFC 5545 - Section 3.8.4.3).
            </brief>
           <description>
            <p>
By default, this attribute is set to an empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  var attendee = new tizen.CalendarAttendee('mailto:bob@domain.com',
                                           {role: &quot;CHAIR&quot;, RSVP: true});
  event.attendees = [attendee];
 </Code>
        </descriptive>
        <Type type="array">
          <Type name="CalendarAttendee"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Operation name="convertToString" id="::Calendar::CalendarItem::convertToString">
        <webidl>    DOMString convertToString(<ref>CalendarTextFormat</ref> format) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Converts the calendar item to a string format that will be generated and returned synchronously.
The export format is set using the format parameter.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  // Defines the event search success callback.
  function eventSearchSuccessCallback(events) {
    // Converts the first event to iCalendar 2.0 format (default)
    var vevent = events[0].convertToString(&quot;ICALENDAR_20&quot;);
    console.log('iCalendar 2.0 representation of the event is: ' + vevent);
  }

  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  // Gets the default calendar
  var myCalendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  // Finds all events in the first calendar that contain in the summary the string Tizen.
  var filter = new tizen.AttributeFilter('summary', 'CONTAINS', 'Tizen');
  myCalendar.find(eventSearchSuccessCallback, errorCallback, filter);
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The representation of the Calendar item.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="format">
            <descriptive>
                <description><p>
 The format to use for exporting.
                </p></description>
            </descriptive>
            <Type name="CalendarTextFormat"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="clone" id="::Calendar::CalendarItem::clone">
        <webidl>    <ref>CalendarItem</ref> clone() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Clones the <em>CalendarItem </em>object, detached from any calendar.
            </brief>
           <description>
            <p>
The <em>CalendarItem </em>object returned by the <em>clone()</em> method will have its identifier set to <var>null </var>and will be detached from any calendar.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  // Gets default calendar.
  var calendar = tizen.calendar.getDefaultCalendar();

  var html5seminar = new tizen.CalendarEvent({startDate: new tizen.TZDate(2012, 3, 4),
                                              duration: new tizen.TimeDuration(3, &quot;DAYS&quot;),
                                              summary: &quot;HTML5 Seminar&quot;});

  calendar.add(html5seminar);
  var tizenseminar = html5seminar.clone();
  tizenseminar.summary = &quot;Tizen Seminar&quot;;
  calendar.add(tizenseminar);
 </Code>
        </descriptive>
        <Type name="CalendarItem">
          <descriptive>
              <description><p>
 CalendarItem The new clone of the <em>CalendarItem </em>object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="CalendarTask" id="::Calendar::CalendarTask">
      <webidl>  [Constructor(optional <ref>CalendarTaskInit</ref>? taskInitDict),
   Constructor(DOMString stringRepresentation, <ref>CalendarTextFormat</ref> format)]
  interface CalendarTask : <ref>CalendarItem</ref> {
    attribute <ref>TZDate</ref>? dueDate setraises(<ref>WebAPIException</ref>);

    attribute <ref>TZDate</ref>? completedDate setraises(<ref>WebAPIException</ref>);

    attribute unsigned short progress setraises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 An interface that implements the <em>CalendarTask </em>object.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(optional <ref>CalendarTaskInit</ref>? taskInitDict)</webidl>
          <ArgumentList>
            <Argument optional="optional" name="taskInitDict">
              <Type name="CalendarTaskInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>   Constructor(DOMString stringRepresentation, <ref>CalendarTextFormat</ref> format)</webidl>
          <ArgumentList>
            <Argument name="stringRepresentation">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="format">
              <Type name="CalendarTextFormat"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="CalendarItem"/>
      </InterfaceInheritance>
      <Attribute name="dueDate" id="::Calendar::CalendarTask::dueDate">
        <webidl>    attribute <ref>TZDate</ref>? dueDate setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the due date and time for completing a task. (See RFC 5545 - Section 3.8.2.3).
            </brief>
           <description>
            <p>
This <em>dueDate</em> must be in the same time zone as the <em>startDate</em>. The <em>duration</em> and <em>dueDate</em> are mutually exclusive, so only one of them can be non-null.
            </p>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
            <p>
The default value is <var>null</var>. If no value is provided, the task doesn't have a due date.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  task.dueDate = new tizen.TZDate(2011, 2, 11);
 </Code>
        </descriptive>
        <Type name="TZDate" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="completedDate" id="::Calendar::CalendarTask::completedDate">
        <webidl>    attribute <ref>TZDate</ref>? completedDate setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to record the date and time when an task is completed.
(See RFC 5545 - Section 3.8.2.1).
            </brief>
           <description>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
            <p>
The default value is <var>null</var>. If no value is provided, the task is not completed yet.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  task.completedDate = new tizen.TZDate(2011, 2, 11);
 </Code>
        </descriptive>
        <Type name="TZDate" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="progress" id="::Calendar::CalendarTask::progress">
        <webidl>    attribute unsigned short progress setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to denote the percent of completion of a task.
            </brief>
           <description>
            <p>
The value is a positive integer between <var>0 </var>and <var>100</var>. A value of <var>0 </var>indicates the task has not been started yet. A value of <var>100 </var>indicates that the task has been completed.
            </p>
            <p>
Integer values in between indicate the percent partially complete.
(See RFC 5545 - Section 3.8.1.8).
            </p>
            <p>
The default value is <var>0</var>, implies that the task has not been started.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  task.progress = 50; // 50% done
 </Code>
        </descriptive>
        <Type type="unsigned short"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
    </Interface>
    <Interface name="CalendarEvent" id="::Calendar::CalendarEvent">
      <webidl>  [Constructor(optional <ref>CalendarEventInit</ref>? eventInitDict),
   Constructor(DOMString stringRepresentation, <ref>CalendarTextFormat</ref> format)]
  interface CalendarEvent : <ref>CalendarItem</ref> {
    readonly attribute boolean isDetached;

    attribute <ref>TZDate</ref>? endDate setraises(<ref>WebAPIException</ref>);

    attribute <ref>EventAvailability</ref> availability setraises(<ref>WebAPIException</ref>);

    attribute <ref>CalendarRecurrenceRule</ref>? recurrenceRule setraises(<ref>WebAPIException</ref>);

    void expandRecurrence(<ref>TZDate</ref> startDate,
                          <ref>TZDate</ref> endDate,
                          <ref>CalendarEventArraySuccessCallback</ref> successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 An interface that implements the <em>calendarEvent </em>object.
          </brief>
          <version>
 1.0
          </version>
          <Code>  // Gets the default calendar
  var calendar = tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;);

  try {
    var ev = new tizen.CalendarEvent(&quot;BEGIN:VCALENDAR\r\n&quot; +
                  &quot;BEGIN:VEVENT\r\n&quot; +
                  &quot;DTSTAMP:19970901T1300Z\r\n&quot; +
                  &quot;DTSTART:19970903T163000Z\r\n&quot; +
                  &quot;DTEND:19970903T190000Z\r\n&quot; +
                  &quot;SUMMARY:Annual Employee Review\r\n&quot; +
                  &quot;CATEGORIES:BUSINESS,HUMAN RESOURCES\r\n&quot; +
                  &quot;END:VEVENT\r\n&quot; +
                  &quot;END:VCALENDAR&quot;, &quot;ICALENDAR_20&quot;);

    calendar.add(ev);
    console.log('Event added with UID ' + ev.id.uid);
  } catch (err) {
    console.log(&quot;Failed to add VEVENT to the calendar, error: &quot; + err.name);
  }
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(optional <ref>CalendarEventInit</ref>? eventInitDict)</webidl>
          <ArgumentList>
            <Argument optional="optional" name="eventInitDict">
              <Type name="CalendarEventInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>   Constructor(DOMString stringRepresentation, <ref>CalendarTextFormat</ref> format)</webidl>
          <ArgumentList>
            <Argument name="stringRepresentation">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="format">
              <Type name="CalendarTextFormat"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="CalendarItem"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="isDetached" id="::Calendar::CalendarEvent::isDetached">
        <webidl>    readonly attribute boolean isDetached;</webidl>
        <descriptive>
            <brief>
 An attribute that behaves like a flag to indicates if an instance of a recurring event is detached and if it has been modified and saved to the calendar.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="endDate" id="::Calendar::CalendarEvent::endDate">
        <webidl>    attribute <ref>TZDate</ref>? endDate setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the end date/time of an event.
            </brief>
           <description>
            <p>
(see RFC 5545 - Section 3.8.2.2).
            </p>
            <p>
This <em>endDate</em> must be in the same time zone as the <em>startDate</em>.
Note that <em>duration</em> and <em>endDate</em> are mutually exclusive, only one of them can be non-null.
            </p>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
            <p>
The default value for this attribute is <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  // 2010-04-30 09:00
  event.endDate = new tizen.TZDate(2010, 3, 30, 9, 0);
 </Code>
        </descriptive>
        <Type name="TZDate" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="availability" id="::Calendar::CalendarEvent::availability">
        <webidl>    attribute <ref>EventAvailability</ref> availability setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the availability of a person for an event.
(See RFC 5545 - Section 3.2.9).
            </brief>
           <description>
            <p>
The default value is <var>BUSY</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="EventAvailability"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="recurrenceRule" id="::Calendar::CalendarEvent::recurrenceRule">
        <webidl>    attribute <ref>CalendarRecurrenceRule</ref>? recurrenceRule setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to denote the recurrence rule for the event.
            </brief>
           <description>
            <p>
The generated instances of a recurring event will have the same recurrence rule as their parent. This is useful when editing a particular event instance and choosing to update <b>all</b> instances from it.
            </p>
            <p>
The detached instances (specific instances that have been modified as saved to the calendar) of a recurring event will not have any recurrence rule. No recurrence rule can be set on detached instances either. If one tries to set a recurrence rule on a detached event, a NotSupportedError should be thrown. Detached instances can be distinguished by checking their <em>isDetached</em> attribute.
(See RFC 5545, Section 3.3.10.)
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  // Repeats daily for 7 days
  var rule = new tizen.CalendarRecurrenceRule(&quot;DAILY&quot;, {occurrenceCount: 7});
  event.recurrenceRule = rule;
 </Code>
        </descriptive>
        <Type name="CalendarRecurrenceRule" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Operation name="expandRecurrence" id="::Calendar::CalendarEvent::expandRecurrence">
        <webidl>    void expandRecurrence(<ref>TZDate</ref> startDate,
                          <ref>TZDate</ref> endDate,
                          <ref>CalendarEventArraySuccessCallback</ref> successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Expands a recurring event and returns asynchronously the list of instances occurring in a given time interval (inclusive).
            </brief>
           <description>
            <p>
This method takes into consideration all the parameters of the event recurrence rule to generate the instances occurring in a given time interval.
            </p>
            <p>
The call involves retrieving from the database detached instances of an event to replace their corresponding virtual instances in the returned list. The client can then use <em>CalendarEvent.isDetached </em>attribute to identify detached instances. If the event is not saved to a calendar yet, only virtual instances will be returned.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - if the event in operation is not recurring.              </li>
              <li>
UnknownError - if any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/calendar.read
            </privilege>
            <Code>  // eventId should be set to ID of event obtained with the find function.
  var eventId;
  // Defines the error callback.
  function errorCallback(response) {
    console.log( 'The following error occurred: ' +  response.name);
  }

  // Defines the event expanding success callback.
  function eventExpandingSuccessCallback(events) {
    console.log(events.length + ' event instances were returned.');
  }

  var calendar = tizen.calendar.getDefaultCalendar();
  var event = calendar.get(eventId);

  if (event.recurrenceRule != null) {
    // This is a recurring event. Expand all the instances during August 2011.
    event.expandRecurrence(new tizen.TZDate(2011, 7, 1),
                          new tizen.TZDate(2011, 7, 31),
                          eventExpandingSuccessCallback,
                          errorCallback);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="startDate">
            <descriptive>
                <description><p>
 The start date/ time of an event(inclusive).
                </p></description>
            </descriptive>
            <Type name="TZDate"/>
          </Argument>
          <Argument name="endDate">
            <descriptive>
                <description><p>
 The end date/ time of an event (inclusive).
                </p></description>
            </descriptive>
            <Type name="TZDate"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="CalendarEventArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Dictionary name="CalendarAttendeeInit" id="::Calendar::CalendarAttendeeInit">
      <webidl>  dictionary CalendarAttendeeInit {
    DOMString name;
    <ref>AttendeeRole</ref> role;
    <ref>AttendeeStatus</ref> status;
    boolean RSVP;
    <ref>AttendeeType</ref> type;
    DOMString? group;
    DOMString delegatorURI;
    DOMString delegateURI;
    <ref>ContactRef</ref> contactRef;
  };</webidl>
      <descriptive>
          <brief>
 The properties of a <em>CalendarAttendee</em>, to pass to its constructor.
          </brief>
         <description>
          <p>
See <em>CalendarAttendee </em>interface for more information about the members.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="name" id="::Calendar::CalendarAttendeeInit::name">
        <webidl>    DOMString name;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="role" id="::Calendar::CalendarAttendeeInit::role">
        <webidl>    <ref>AttendeeRole</ref> role;</webidl>
        <Type name="AttendeeRole"/>
      </DictionaryMember>
      <DictionaryMember name="status" id="::Calendar::CalendarAttendeeInit::status">
        <webidl>    <ref>AttendeeStatus</ref> status;</webidl>
        <Type name="AttendeeStatus"/>
      </DictionaryMember>
      <DictionaryMember name="RSVP" id="::Calendar::CalendarAttendeeInit::RSVP">
        <webidl>    boolean RSVP;</webidl>
        <Type type="boolean"/>
      </DictionaryMember>
      <DictionaryMember name="type" id="::Calendar::CalendarAttendeeInit::type">
        <webidl>    <ref>AttendeeType</ref> type;</webidl>
        <Type name="AttendeeType"/>
      </DictionaryMember>
      <DictionaryMember name="group" id="::Calendar::CalendarAttendeeInit::group">
        <webidl>    DOMString? group;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="delegatorURI" id="::Calendar::CalendarAttendeeInit::delegatorURI">
        <webidl>    DOMString delegatorURI;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="delegateURI" id="::Calendar::CalendarAttendeeInit::delegateURI">
        <webidl>    DOMString delegateURI;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="contactRef" id="::Calendar::CalendarAttendeeInit::contactRef">
        <webidl>    <ref>ContactRef</ref> contactRef;</webidl>
        <Type name="ContactRef"/>
      </DictionaryMember>
    </Dictionary>
    <Interface name="CalendarAttendee" id="::Calendar::CalendarAttendee">
      <webidl>  [Constructor(DOMString uri, optional <ref>CalendarAttendeeInit</ref>? attendeeInitDict)]
  interface CalendarAttendee
  {
    attribute DOMString uri;

    attribute DOMString? name;

    attribute <ref>AttendeeRole</ref> role;

    attribute <ref>AttendeeStatus</ref> status;

    attribute boolean RSVP;

    attribute <ref>AttendeeType</ref> type;

    attribute DOMString? group;

    attribute DOMString? delegatorURI;

    attribute DOMString? delegateURI;

    attribute <ref>ContactRef</ref>? contactRef;
  };</webidl>
      <descriptive>
          <brief>
 This interface implements the <em>CalendarAttendee </em>object that contains information about an event attendee.
          </brief>
         <description>
          <p>
By default, each of the attributes of this interface are undefined.
          </p>
          <p>
(For more details, see RFC 5545, Section 3.8.4.1.)
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code>  var attendee = new tizen.CalendarAttendee('mailto:bob@domain.com',
                                           {role: &quot;CHAIR&quot;, RSVP: true});
  event.attendees = [attendee];
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString uri, optional <ref>CalendarAttendeeInit</ref>? attendeeInitDict)</webidl>
          <ArgumentList>
            <Argument name="uri">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="attendeeInitDict">
              <Type name="CalendarAttendeeInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="uri" id="::Calendar::CalendarAttendee::uri">
        <webidl>    attribute DOMString uri;</webidl>
        <descriptive>
            <brief>
 An attribute to store the URI for the attendee.
            </brief>
           <description>
            <p>
This is often an email in the form 'mailto:name@domain.com'.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="name" id="::Calendar::CalendarAttendee::name">
        <webidl>    attribute DOMString? name;</webidl>
        <descriptive>
            <brief>
 An attribute to store the name of an attendee.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="role" id="::Calendar::CalendarAttendee::role">
        <webidl>    attribute <ref>AttendeeRole</ref> role;</webidl>
        <descriptive>
            <brief>
 An attribute to denote the role of the attendee.
            </brief>
           <description>
            <p>
(See RFC 5545, Section 3.2.16.)
            </p>
            <p>
The default value is <var>REQ_PARTICIPANT</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="AttendeeRole"/>
      </Attribute>
      <Attribute name="status" id="::Calendar::CalendarAttendee::status">
        <webidl>    attribute <ref>AttendeeStatus</ref> status;</webidl>
        <descriptive>
            <brief>
 An attribute to store the participant's attendance status.
(See RFC 5545, Section 3.2.12.)
            </brief>
           <description>
            <p>
The default value is <var>PENDING</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="AttendeeStatus"/>
      </Attribute>
      <Attribute name="RSVP" id="::Calendar::CalendarAttendee::RSVP">
        <webidl>    attribute boolean RSVP;</webidl>
        <descriptive>
            <brief>
 An attribute to store the attendee's participation status reply (RSVP).
(See RFC 5545, Section 3.2.17.)
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>FALSE</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="type" id="::Calendar::CalendarAttendee::type">
        <webidl>    attribute <ref>AttendeeType</ref> type;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the type of a participant.
(See RFC 5545, Section 3.2.3.)
            </brief>
           <description>
            <p>
The default value is <var>INDIVIDUAL</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="AttendeeType"/>
      </Attribute>
      <Attribute name="group" id="::Calendar::CalendarAttendee::group">
        <webidl>    attribute DOMString? group;</webidl>
        <descriptive>
            <brief>
 An attribute to store the participant's group or list membership.
(See RFC 5545, Section 3.2.11.)
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="delegatorURI" id="::Calendar::CalendarAttendee::delegatorURI">
        <webidl>    attribute DOMString? delegatorURI;</webidl>
        <descriptive>
            <brief>
 An attribute to store the URI of the person who has delegated their participation to this attendee.
(See RFC 5545, Section 3.2.4.)
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="delegateURI" id="::Calendar::CalendarAttendee::delegateURI">
        <webidl>    attribute DOMString? delegateURI;</webidl>
        <descriptive>
            <brief>
 An attribute to stores the URI of the attendee to whom the person has delegated his participation.
(See RFC 5545, Section 3.2.5.)
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="contactRef" id="::Calendar::CalendarAttendee::contactRef">
        <webidl>    attribute <ref>ContactRef</ref>? contactRef;</webidl>
        <descriptive>
            <brief>
 An attribute to store the participant's reference in the Contact API.
            </brief>
           <description>
            <p>
If the contact is not resolved, this attribute will be set to<var> null</var>.
For more information, see the <a href="../../org.tizen.web.device.apireference/tizen/contact.html">Contact API</a>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="ContactRef" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Dictionary name="CalendarRecurrenceRuleInit" id="::Calendar::CalendarRecurrenceRuleInit">
      <webidl>  dictionary CalendarRecurrenceRuleInit {
    short interval;
    <ref>TZDate</ref> untilDate;
    long occurrenceCount;
    <ref>ByDayValue</ref>[] daysOfTheWeek;
    short[] setPositions;
    <ref>TZDate</ref>[] exceptions;
  };</webidl>
      <descriptive>
          <brief>
 The properties of a <em>CalendarRecurrenceRule</em> to pass to its constructor.
          </brief>
         <description>
          <p>
For more information about the members, see <em>CalendarRecurrenceRule </em>interface.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="interval" id="::Calendar::CalendarRecurrenceRuleInit::interval">
        <webidl>    short interval;</webidl>
        <Type type="short"/>
      </DictionaryMember>
      <DictionaryMember name="untilDate" id="::Calendar::CalendarRecurrenceRuleInit::untilDate">
        <webidl>    <ref>TZDate</ref> untilDate;</webidl>
        <Type name="TZDate"/>
      </DictionaryMember>
      <DictionaryMember name="occurrenceCount" id="::Calendar::CalendarRecurrenceRuleInit::occurrenceCount">
        <webidl>    long occurrenceCount;</webidl>
        <Type type="long"/>
      </DictionaryMember>
      <DictionaryMember name="daysOfTheWeek" id="::Calendar::CalendarRecurrenceRuleInit::daysOfTheWeek">
        <webidl>    <ref>ByDayValue</ref>[] daysOfTheWeek;</webidl>
        <Type type="array">
          <Type name="ByDayValue"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="setPositions" id="::Calendar::CalendarRecurrenceRuleInit::setPositions">
        <webidl>    short[] setPositions;</webidl>
        <Type type="array">
          <Type type="short"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="exceptions" id="::Calendar::CalendarRecurrenceRuleInit::exceptions">
        <webidl>    <ref>TZDate</ref>[] exceptions;</webidl>
        <Type type="array">
          <Type name="TZDate"/>
        </Type>
      </DictionaryMember>
    </Dictionary>
    <Interface name="CalendarRecurrenceRule" id="::Calendar::CalendarRecurrenceRule">
      <webidl>  [Constructor(<ref>RecurrenceRuleFrequency</ref> frequency, optional <ref>CalendarRecurrenceRuleInit</ref>? ruleInitDict)]
  interface CalendarRecurrenceRule
  {
    attribute <ref>RecurrenceRuleFrequency</ref> frequency;

    attribute unsigned short interval;

    attribute <ref>TZDate</ref>? untilDate;

    attribute long occurrenceCount;

    attribute <ref>ByDayValue</ref>[] daysOfTheWeek;

    attribute short[] setPositions;

    attribute <ref>TZDate</ref>[] exceptions;
  };</webidl>
      <descriptive>
          <brief>
 This interface implements the<em> CalendarRecurrenceRule </em>object, which contains information about the recurrence of an event.
(See RFC 5545, Section 3.3.10.)
          </brief>
          <version>
 1.0
          </version>
          <Code>  // Repeats daily for 7 days
  var rule = new tizen.CalendarRecurrenceRule(&quot;DAILY&quot;, {occurrenceCount:7});
  event.recurrenceRule = rule;
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(<ref>RecurrenceRuleFrequency</ref> frequency, optional <ref>CalendarRecurrenceRuleInit</ref>? ruleInitDict)</webidl>
          <ArgumentList>
            <Argument name="frequency">
              <Type name="RecurrenceRuleFrequency"/>
            </Argument>
            <Argument optional="optional" name="ruleInitDict">
              <Type name="CalendarRecurrenceRuleInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="frequency" id="::Calendar::CalendarRecurrenceRule::frequency">
        <webidl>    attribute <ref>RecurrenceRuleFrequency</ref> frequency;</webidl>
        <descriptive>
            <brief>
 An attribute to store the frequency of a recurrence rule.
            </brief>
           <description>
            <p>
This property corresponds to <em>FREQ</em> in RFC 5545.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="RecurrenceRuleFrequency"/>
      </Attribute>
      <Attribute name="interval" id="::Calendar::CalendarRecurrenceRule::interval">
        <webidl>    attribute unsigned short interval;</webidl>
        <descriptive>
            <brief>
 An attribute to specify how often the recurrence rule repeats over the unit of time indicated by its frequency.
            </brief>
           <description>
            <p>
This attribute is linked to the <em>frequency </em>attribute and for an interval of <var>n</var>, the event will recur every <var>n </var>of recurrence attribute.
            </p>
            <p>
For example, if the interval attribute is set to <var>2 </var>and <em>frequency </em>attribute is set to <var>WEEKLY</var>, then the event will recur every 2 weeks.
            </p>
            <p>
The default interval value is <var>1</var>, that is, every day if the <em>CalendarRecurrenceRule frequency</em> attribute is DAILY, every week if frequency is <var>WEEKLY</var>, every month if frequency is <var>MONTHLY </var>or every year if frequency is <var>YEARLY</var>.
            </p>
            <p>
This property corresponds to <em>INTERVAL</em> in RFC 5545.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute name="untilDate" id="::Calendar::CalendarRecurrenceRule::untilDate">
        <webidl>    attribute <ref>TZDate</ref>? untilDate;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the end date of a recurrence duration of an event using either an end date (<em>untilDate </em>attribute) or a number of occurrences (<em>occurrenceCount </em>attribute).
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>, meaning that the event recurs infinitely, unless <em>occurrenceCount </em>is set.
            </p>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
            <p>
This property corresponds to <em>UNTIL</em> in RFC 5545.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TZDate" nullable="nullable"/>
      </Attribute>
      <Attribute name="occurrenceCount" id="::Calendar::CalendarRecurrenceRule::occurrenceCount">
        <webidl>    attribute long occurrenceCount;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the number of occurrences of a recurring event.
            </brief>
           <description>
            <p>
The recurrence duration of an event can be defined using either an end date (<em>untilDate </em>attribute) or a number of occurrences (<em>occurrenceCount </em>attribute).
            </p>
            <p>
By default, this attribute is set to <var>-1</var>, meaning that the event recurs infinitely, unless <em>untilDate </em>is set.
            </p>
            <p>
This property corresponds to <em>COUNT</em> in RFC 5545.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Attribute name="daysOfTheWeek" id="::Calendar::CalendarRecurrenceRule::daysOfTheWeek">
        <webidl>    attribute <ref>ByDayValue</ref>[] daysOfTheWeek;</webidl>
        <descriptive>
            <brief>
 An attribute to store the days of the week associated with the recurrence rule.
            </brief>
           <description>
            <p>
This property value is valid only for recurrence rules with a frequency type of <em>WEEKLY</em>, <em>MONTHLY</em>, and <em>YEARLY</em>.
            </p>
            <p>
This property corresponds to <em>BYDAY</em> in RFC 5545.
            </p>
            <p>
By default, this attribute is set to an empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="ByDayValue"/>
        </Type>
      </Attribute>
      <Attribute name="setPositions" id="::Calendar::CalendarRecurrenceRule::setPositions">
        <webidl>    attribute short[] setPositions;</webidl>
        <descriptive>
            <brief>
 An attribute to store a list of ordinal numbers that filters which recurrences to include in the recurrence rule's frequency.
            </brief>
           <description>
            <p>
For example, a yearly recurrence rule that has a <em>daysOfTheWeek </em>value that specifies Monday through Friday, and a <em>setPositions </em>array containing <var>2 </var>and <var>-1</var>, occurs only on the second weekday and last weekday of every year.
            </p>
            <p>
Values can be from 1 to 366 or -366 to -1.
Negative values indicate counting backwards from the end of the recurrence rule's frequency (week, month, or year).
            </p>
            <p>
This attribute must only be used in conjunction with another BYxxx rule part (such as <em>daysOfTheWeek</em>).
            </p>
            <p>
This property corresponds to <em>BYSETPOS</em> in RFC 5545.
            </p>
            <p>
By default, this attribute is set to an empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="short"/>
        </Type>
      </Attribute>
      <Attribute name="exceptions" id="::Calendar::CalendarRecurrenceRule::exceptions">
        <webidl>    attribute <ref>TZDate</ref>[] exceptions;</webidl>
        <descriptive>
            <brief>
 An attribute to list date/time exceptions for the recurring event.
(See RFC 5545, Section 3.8.5.1.)
            </brief>
           <description>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
            <p>
This property corresponds to <em>EXDATE</em> in RFC 5545.
            </p>
            <p>
By default, this attribute is set to an empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="TZDate"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="CalendarEventId" id="::Calendar::CalendarEventId">
      <webidl>  [Constructor(DOMString uid, optional DOMString? rid)]
  interface CalendarEventId {
    attribute DOMString uid;

    attribute DOMString? rid;
  };</webidl>
      <descriptive>
          <brief>
 This interface contains a UID and an optional recurrence ID attribute to identify calendar events.
          </brief>
         <description>
          <p>
The recurrence identifier (<em>rid</em> attribute) is used to identify a particular instance of a recurring event. All instances of the same recurring event have the same UID but different recurrence IDs.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString uid, optional DOMString? rid)</webidl>
          <ArgumentList>
            <Argument name="uid">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="rid">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="uid" id="::Calendar::CalendarEventId::uid">
        <webidl>    attribute DOMString uid;</webidl>
        <descriptive>
            <brief>
 An attribute to persistently, and uniquely identify a calendar event.
            </brief>
           <description>
            <p>
This value is assigned by the platform when the event is added to the calendar, it is locally unique and persistent for the life time of the event and it cannot be modified by the developers.
            </p>
            <p>
See RFC 5545 (section 3.8.4.7) for more details about this parameter and algorithms to guarantee assignment of unique values.
This value is assigned by the platform when the <em>add()</em> method is successfully invoked.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="rid" id="::Calendar::CalendarEventId::rid">
        <webidl>    attribute DOMString? rid;</webidl>
        <descriptive>
            <brief>
 An attribute to store the recurrence ID of a <em>CalendarEvent </em>instance.
            </brief>
           <description>
            <p>
This attribute is used in conjunction with the <em>uid</em> property to identify a specific instance of a recurring event.
            </p>
            <p>
The parent of a recurrence instance has its <em>rid</em> set to <var>null</var>.
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
(See RFC 5545 (section 3.8.4.4) for more details about this parameter.)
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="CalendarAlarm" id="::Calendar::CalendarAlarm">
      <webidl>  [Constructor(<ref>TZDate</ref> absoluteDate, <ref>AlarmMethod</ref> method, optional DOMString? description),
   Constructor(<ref>TimeDuration</ref> before, <ref>AlarmMethod</ref> method, optional DOMString? description)]
  interface CalendarAlarm {
    attribute <ref>TZDate</ref>? absoluteDate setraises(<ref>WebAPIException</ref>);

    attribute <ref>TimeDuration</ref>? before setraises(<ref>WebAPIException</ref>);

    attribute <ref>AlarmMethod</ref> method setraises(<ref>WebAPIException</ref>);

    attribute DOMString? description;
  };</webidl>
      <descriptive>
          <brief>
 An interface that contains information related to an event alarm or reminder.
          </brief>
          <version>
 1.0
          </version>
          <Code>  // Creates a sound alarm 30 minutes before the event's start time
  var alarm = new tizen.CalendarAlarm(new tizen.TimeDuration(30, &quot;MINS&quot;), &quot;SOUND&quot;);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(<ref>TZDate</ref> absoluteDate, <ref>AlarmMethod</ref> method, optional DOMString? description)</webidl>
          <ArgumentList>
            <Argument name="absoluteDate">
              <Type name="TZDate"/>
            </Argument>
            <Argument name="method">
              <Type name="AlarmMethod"/>
            </Argument>
            <Argument optional="optional" name="description">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>   Constructor(<ref>TimeDuration</ref> before, <ref>AlarmMethod</ref> method, optional DOMString? description)</webidl>
          <ArgumentList>
            <Argument name="before">
              <Type name="TimeDuration"/>
            </Argument>
            <Argument name="method">
              <Type name="AlarmMethod"/>
            </Argument>
            <Argument optional="optional" name="description">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="absoluteDate" id="::Calendar::CalendarAlarm::absoluteDate">
        <webidl>    attribute <ref>TZDate</ref>? absoluteDate setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to record the absolute date and time when an alarm should be triggered.
            </brief>
           <description>
            <p>
<em>absoluteDate </em>and <em>before </em>are mutually exclusive.
            </p>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TZDate" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="before" id="::Calendar::CalendarAlarm::before">
        <webidl>    attribute <ref>TimeDuration</ref>? before setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the duration before an event starts on which the alarm should be triggered.
            </brief>
           <description>
            <p>
The duration should be positive.
            </p>
            <p>
<em>absoluteDate </em>and <em>before </em>are mutually exclusive.
            </p>
            <p>
This attribute is precise to the second. Milliseconds are ignored.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TimeDuration" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="method" id="::Calendar::CalendarAlarm::method">
        <webidl>    attribute <ref>AlarmMethod</ref> method setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to denote the notification method used by an alarm.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="AlarmMethod"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="description" id="::Calendar::CalendarAlarm::description">
        <webidl>    attribute DOMString? description;</webidl>
        <descriptive>
            <brief>
 An attribute to store the description of an alarm.
            </brief>
           <description>
            <p>
When the method is <var>DISPLAY</var>, the alarm must also include a description attribute, which contains the text to be displayed when the alarm is triggered.
            </p>
            <p>
The default value is an empty string.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="CalendarEventArraySuccessCallback" id="::Calendar::CalendarEventArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject]
  interface CalendarEventArraySuccessCallback {
    void onsuccess(<ref>CalendarEvent</ref>[] events);
  };</webidl>
      <descriptive>
          <brief>
 An interface that implements the success callback used in the asynchronous operation for retrieving a list of calendar events.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Calendar::CalendarEventArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>CalendarEvent</ref>[] events);</webidl>
        <descriptive>
            <brief>
 Called when the list of calendar events is retrieved successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="events">
            <descriptive>
                <description><p>
 The array of <em>CalendarEvent </em>objects.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CalendarEvent"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="CalendarItemArraySuccessCallback" id="::Calendar::CalendarItemArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject]
  interface CalendarItemArraySuccessCallback {
    void onsuccess(<ref>CalendarItem</ref>[] items);
  };</webidl>
      <descriptive>
          <brief>
 This interface implements the success callback used in the asynchronous operation for retrieving a list of calendar items.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Calendar::CalendarItemArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>CalendarItem</ref>[] items);</webidl>
        <descriptive>
            <brief>
 Called when the list of calendar items is retrieved successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="items">
            <descriptive>
                <description><p>
 The array of <em>CalendarItem </em>objects.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CalendarItem"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="CalendarArraySuccessCallback" id="::Calendar::CalendarArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject]
  interface CalendarArraySuccessCallback {
    void onsuccess(<ref>Calendar</ref>[] calendars);
  };</webidl>
      <descriptive>
          <brief>
 This interface implements the success callback used in the asynchronous operation to get a list of calendars using the <em>getCalendars()</em> method.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Calendar::CalendarArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>Calendar</ref>[] calendars);</webidl>
        <descriptive>
            <brief>
 Called when the array of <em>Calendar </em>objects is retrieved successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="calendars">
            <descriptive>
                <description><p>
 The array of <em>Calendar </em>objects.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Calendar"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="CalendarChangeCallback" id="::Calendar::CalendarChangeCallback">
      <webidl>  [Callback, NoInterfaceObject] interface CalendarChangeCallback {
    void onitemsadded(<ref>CalendarItem</ref>[] items);

    void onitemsupdated(<ref>CalendarItem</ref>[] items);

    void onitemsremoved(<ref>CalendarItemId</ref>[] ids);
  };</webidl>
      <descriptive>
          <brief>
 This interface specifies a set of methods that will be invoked every time a calendar change occurs (calendar item addition/update/removal).
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onitemsadded" id="::Calendar::CalendarChangeCallback::onitemsadded">
        <webidl>    void onitemsadded(<ref>CalendarItem</ref>[] items);</webidl>
        <descriptive>
            <brief>
 Called when items are added to the calendar.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="items">
            <descriptive>
                <description><p>
 The list of items that were added.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CalendarItem"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onitemsupdated" id="::Calendar::CalendarChangeCallback::onitemsupdated">
        <webidl>    void onitemsupdated(<ref>CalendarItem</ref>[] items);</webidl>
        <descriptive>
            <brief>
 Called when items are updated in the calendar.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="items">
            <descriptive>
                <description><p>
 The list of items that were updated.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CalendarItem"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onitemsremoved" id="::Calendar::CalendarChangeCallback::onitemsremoved">
        <webidl>    void onitemsremoved(<ref>CalendarItemId</ref>[] ids);</webidl>
        <descriptive>
            <brief>
 Called when item are removed from the calendar.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="ids">
            <descriptive>
                <description><p>
 The list of identifiers for the items that were removed.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CalendarItemId"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Callhistory" id="::Callhistory">
    <webidl>module Callhistory {
    [NoInterfaceObject] interface CallHistoryObject {
        readonly attribute <ref>CallHistory</ref> callhistory;
    };

    <ref>Tizen</ref> implements <ref>CallHistoryObject</ref>;

    [NoInterfaceObject] interface RemoteParty {
        readonly attribute DOMString? remoteParty;

        readonly attribute <ref>PersonId</ref>? personId;

    };

    [NoInterfaceObject] interface CallHistoryEntry {

        readonly attribute DOMString uid;

        readonly attribute DOMString type;

        readonly attribute DOMString[]? features;

        readonly attribute <ref>RemoteParty</ref>[] remoteParties;

        readonly attribute Date startTime;

        readonly attribute unsigned long duration;

        attribute DOMString direction;
    };

    [NoInterfaceObject] interface CallHistory {

        void find(<ref>CallHistoryEntryArraySuccessCallback</ref> successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback,
                  optional <ref>AbstractFilter</ref>? filter,
                  optional <ref>SortMode</ref>? sortMode,
                  optional unsigned long? limit,
                  optional unsigned long? offset) raises(<ref>WebAPIException</ref>);

        void remove(<ref>CallHistoryEntry</ref> entry) raises(<ref>WebAPIException</ref>);

        void removeBatch(<ref>CallHistoryEntry</ref>[] entries,
                         optional <ref>SuccessCallback</ref>? successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void removeAll(optional <ref>SuccessCallback</ref>? successCallback,
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        long addChangeListener(<ref>CallHistoryChangeCallback</ref> observer) raises(<ref>WebAPIException</ref>);

        void removeChangeListener(long handle) raises(<ref>WebAPIException</ref>);
    };

    [Callback=FunctionOnly, NoInterfaceObject] interface CallHistoryEntryArraySuccessCallback {
        void onsuccess(<ref>CallHistoryEntry</ref>[] entries);
    };

    [Callback, NoInterfaceObject]
    interface CallHistoryChangeCallback {
        void onadded(<ref>CallHistoryEntry</ref>[] newItems);

        void onchanged(<ref>CallHistoryEntry</ref>[] changedItems);

        void onremoved(DOMString[] removedItems);
    };
};</webidl>
    <descriptive>
        <brief>
 This API provides interfaces and methods for retrieving information from the call history.
        </brief>
       <description>
        <p>
For more information on the Callhistory features, see <a href="../../org.tizen.web.appprogramming/html/guide/social_guide/call.htm">Call History Guide</a>.
        </p>
       </description>
        <version>
 2.0
        </version>
        <def-api-feature identifier="http://tizen.org/feature/network.telephony">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with Telephony feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
    </descriptive>
    <Interface name="CallHistoryObject" id="::Callhistory::CallHistoryObject">
      <webidl>    [NoInterfaceObject] interface CallHistoryObject {
        readonly attribute <ref>CallHistory</ref> callhistory;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen </em>object from the Tizen Platform.
The <em>tizen.callhistory<em> object allows access to the CallHistory API.
</em></em>          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="callhistory" id="::Callhistory::CallHistoryObject::callhistory">
        <webidl>        readonly attribute <ref>CallHistory</ref> callhistory;</webidl>
        <Type name="CallHistory"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="CallHistoryObject">
      <webidl>    <ref>Tizen</ref> implements <ref>CallHistoryObject</ref>;</webidl>
      <descriptive>
          <brief>
 The CallHistory interface is available from the <em>Tizen </em>object through the <em>Window </em>object.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
    </Implements>
    <Interface name="RemoteParty" id="::Callhistory::RemoteParty">
      <webidl>    [NoInterfaceObject] interface RemoteParty {
        readonly attribute DOMString? remoteParty;

        readonly attribute <ref>PersonId</ref>? personId;

    };</webidl>
      <descriptive>
          <brief>
 This interface represents remote parties.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="remoteParty" id="::Callhistory::RemoteParty::remoteParty">
        <webidl>        readonly attribute DOMString? remoteParty;</webidl>
        <descriptive>
            <brief>
 An attribute to store the remote party identifier (RPID).
The RPID is a unique identifier used by a service with call capability. It also includes phone numbers.
Contacts are also defined per service, so an RPID can be resolved to a Contact.
A <var>null </var>value means that the remote is hidden (private number).
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="personId" id="::Callhistory::RemoteParty::personId">
        <webidl>        readonly attribute <ref>PersonId</ref>? personId;</webidl>
        <descriptive>
            <brief>
 An attribute to store the identifier of the person that the raw contact belongs to.
            </brief>
           <description>
            <p>
If the contact cannot be resolved, the value is <var>null</var>.
See <a href="../../org.tizen.web.device.apireference/tizen/contact.html">Contact API</a> for more information.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="PersonId" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="CallHistoryEntry" id="::Callhistory::CallHistoryEntry">
      <webidl>    [NoInterfaceObject] interface CallHistoryEntry {

        readonly attribute DOMString uid;

        readonly attribute DOMString type;

        readonly attribute DOMString[]? features;

        readonly attribute <ref>RemoteParty</ref>[] remoteParties;

        readonly attribute Date startTime;

        readonly attribute unsigned long duration;

        attribute DOMString direction;
    };</webidl>
      <descriptive>
          <brief>
 This interface represents the subset of properties of calls, which become a call record in the call history after the call ends.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="uid" id="::Callhistory::CallHistoryEntry::uid">
        <webidl>        readonly attribute DOMString uid;</webidl>
        <descriptive>
            <brief>
 An attribute to store the unique identifier of a call record.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::Callhistory::CallHistoryEntry::type">
        <webidl>        readonly attribute DOMString type;</webidl>
        <descriptive>
            <brief>
 An attribute to store the service type of the call saved to call history.
            </brief>
           <description>
            <p>
The following values are the supported:
            </p>
            <ul>
              <li>
TEL - for all protocols with phone number addressing (PSTN, GSM, CDMA, LTE, etc.)               </li>
              <li>
XMPP -  for generic XMPP calls              </li>
              <li>
SIP - for generic SIP calls              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="features" id="::Callhistory::CallHistoryEntry::features">
        <webidl>        readonly attribute DOMString[]? features;</webidl>
        <descriptive>
            <brief>
 An attributes to store the features associated with the call service saved to call history.
The following values are the supported:
            </brief>
           <description>
            <ul>
              <li>
CALL - for all call types              </li>
              <li>
VOICECALL - for voice-only calls               </li>
              <li>
VIDEOCALL - for audio and video channel support in the call              </li>
              <li>
EMERGENCYCALL - to denote an emergency call              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="remoteParties" id="::Callhistory::CallHistoryEntry::remoteParties">
        <webidl>        readonly attribute <ref>RemoteParty</ref>[] remoteParties;</webidl>
        <descriptive>
            <brief>
 An attributes to store the remote parties participating in the call.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="RemoteParty"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="startTime" id="::Callhistory::CallHistoryEntry::startTime">
        <webidl>        readonly attribute Date startTime;</webidl>
        <descriptive>
            <brief>
 An attribute to store the start time of the call.
This attribute is the moment when media channels come up. The exact meaning is defined by the back-end.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
      <Attribute readonly="readonly" name="duration" id="::Callhistory::CallHistoryEntry::duration">
        <webidl>        readonly attribute unsigned long duration;</webidl>
        <descriptive>
            <brief>
 An attribute to store the duration of the call in seconds.
This attribute is the duration from media channels coming up to the moment when media channels tear down on the same call service.
If the call is migrated to another service, another call history entry is used.
The exact meaning is defined by the back-end.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute name="direction" id="::Callhistory::CallHistoryEntry::direction">
        <webidl>        attribute DOMString direction;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate whether the call was dialed, received, missed, blocked or rejected.
The following values are the supported:
            </brief>
           <description>
            <ul>
              <li>
DIALED - for dialed calls              </li>
              <li>
RECEIVED - for received calls              </li>
              <li>
MISSEDNEW - for missed calls not seen yet              </li>
              <li>
MISSED - for missed calls              </li>
              <li>
BLOCKED - for blocked calls              </li>
              <li>
REJECTED - for rejected calls              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="CallHistory" id="::Callhistory::CallHistory">
      <webidl>    [NoInterfaceObject] interface CallHistory {

        void find(<ref>CallHistoryEntryArraySuccessCallback</ref> successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback,
                  optional <ref>AbstractFilter</ref>? filter,
                  optional <ref>SortMode</ref>? sortMode,
                  optional unsigned long? limit,
                  optional unsigned long? offset) raises(<ref>WebAPIException</ref>);

        void remove(<ref>CallHistoryEntry</ref> entry) raises(<ref>WebAPIException</ref>);

        void removeBatch(<ref>CallHistoryEntry</ref>[] entries,
                         optional <ref>SuccessCallback</ref>? successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void removeAll(optional <ref>SuccessCallback</ref>? successCallback,
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        long addChangeListener(<ref>CallHistoryChangeCallback</ref> observer) raises(<ref>WebAPIException</ref>);

        void removeChangeListener(long handle) raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface manages call history.
Apps can read or delete call history (depending on permission).
Modifying call history is allowed for certain attributes, like direction.
Adding call history is owned by the back-end. Filtering is supported for all fields of <em>CallHistoryEntry</em>.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="find" id="::Callhistory::CallHistory::find">
        <webidl>        void find(<ref>CallHistoryEntryArraySuccessCallback</ref> successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback,
                  optional <ref>AbstractFilter</ref>? filter,
                  optional <ref>SortMode</ref>? sortMode,
                  optional unsigned long? limit,
                  optional unsigned long? offset) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Finds and returns call history.
            </brief>
           <description>
            <p>
The <em>errorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/callhistory.read
            </privilege>
            <Code> // Defines success callback
 function onSuccess(results) {
     console.log(results.length + &quot; call history item(s) found!&quot;);
     for (var i=0; i&#60;results.length; i++) {
         console.log(i + &quot;. &quot; + results[i].toString()); // process the CallHistoryEntry
     }
 }

 // Defines error callback
 function onError(error) {
     console.log(&quot;Query failed&quot; + error.name);
 }

 // Defines filter: list CS calls, most recent first
 var filter = new tizen.AttributeFilter(&quot;type&quot;, &quot;EXACTLY&quot;, &quot;TEL&quot;);

 // Defines sort mode: descending on call start time.
 var sortMode = new tizen.SortMode(&quot;startTime&quot;, &quot;DESC&quot;);

 // Makes the query and wire up the callbacks
 tizen.callhistory.find(onSuccess,
                         onError,
                         filter,
                         sortMode);

 var numberfilter = new tizen.AttributeFilter(
                                 &quot;remoteParties.remoteParty&quot;,
                                 &quot;EXACTLY&quot;,
                                 &quot;123456789&quot;);

 // Creates a composite filter for time constraints
 var y2009Filter = new tizen.AttributeRangeFilter(
                                &quot;startTime&quot;,
                                new Date(2009, 0, 1),
                                new Date(2010, 0, 1));

 var y2011Filter = new tizen.AttributeRangeFilter(
                                &quot;startTime&quot;,
                                new Date(2011, 0, 1),
                                new Date(2012, 0, 1));

 var datefilter = new tizen.CompositeFilter(&quot;UNION&quot;, [y2009Filter, y2011Filter]);

 // Creates a filter to find all video calls (including cellular, skype, etc)
 // The filter matches exactly any features from the &quot;features&quot; array
 var tfilter = new tizen.AttributeFilter(&quot;features&quot;, &quot;EXACTLY&quot;, &quot;VIDEOCALL&quot;);

 // Creates composite filter
 var ifilter = new tizen.CompositeFilter(&quot;INTERSECTION&quot;,
                                         [numberFilter, dateFilter, tfilter]);

 // Makes the query and wire up the callbacks; reuse sortMode
 tizen.callhistory.find(onSuccess,
                         onError,
                         ifilter,
                         sortMode);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 A handler for query result set.
                </p></description>
            </descriptive>
            <Type name="CallHistoryEntryArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 A filter defined on <em>CallHistoryEntry </em>attributes. It can be a composite filter.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="sortMode">
            <descriptive>
                <description><p>
 The sort order in which call history are return.
                </p></description>
            </descriptive>
            <Type name="SortMode" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="limit">
            <descriptive>
                <description><p>
 The maximum limit of query result (It is the same meaning as SQL LIMIT).
If limit is 0, query result is no limit.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="offset">
            <descriptive>
                <description><p>
 The offset in the result set, from where the results are listed (It is the same semantics as SQL OFFSET).<br/>The number of results listed is maximum the specified <em>limit</em> parameter. Defaults to<var> 0</var>, meaning no offset.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::Callhistory::CallHistory::remove">
        <webidl>        void remove(<ref>CallHistoryEntry</ref> entry) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a call history synchronously.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/callhistory.write
            </privilege>
            <Code> // Defines success callback
 function onSuccess(results) {
     if (results.length > 0)
         tizen.callhistory.remove(results[0]);
 }

 // Defines error callback
 function onError(error) {
     console.log(&quot;Query failed&quot; + error.name);
 }

 // Makes the query and wires up the callbacks
 tizen.callhistory.find(onSuccess, onError);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="entry">
            <descriptive>
                <description><p>
 Call history entry to be deleted.
                </p></description>
            </descriptive>
            <Type name="CallHistoryEntry"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeBatch" id="::Callhistory::CallHistory::removeBatch">
        <webidl>        void removeBatch(<ref>CallHistoryEntry</ref>[] entries,
                         optional <ref>SuccessCallback</ref>? successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a list of call history asynchronously.
            </brief>
           <description>
            <p>
The <em>errorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/callhistory.write
            </privilege>
            <Code> // Defines success callback
 function onSuccess(results) {
     tizen.callhistory.removeBatch(results);
 }

 // Defines error callback
 function onError(error) {
     console.log(&quot;Query failed&quot; + error.name);
 }

 // Makes the query and wires up the callbacks
 tizen.callhistory.find(onSuccess, onError);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="entries">
            <descriptive>
                <description><p>
 A list of call history entries to delete.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CallHistoryEntry"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 A generic success handler.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 An error handler.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeAll" id="::Callhistory::CallHistory::removeAll">
        <webidl>        void removeAll(optional <ref>SuccessCallback</ref>? successCallback,
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes all call history asynchronously.
            </brief>
           <description>
            <p>
The <em>errorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/callhistory.write
            </privilege>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 A generic success handler.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 An error handler.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addChangeListener" id="::Callhistory::CallHistory::addChangeListener">
        <webidl>        long addChangeListener(<ref>CallHistoryChangeCallback</ref> observer) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a listener to register for callback to observe call history changes.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/callhistory.read
            </privilege>
            <Code> var onListenerCB = {
     onadded: function(newItems) {
         console.log(&quot;New Item added&quot;);
         for (var i in newItems) {
             console.log(&quot;Item &quot; + i + &quot; startTime: &quot; + newItems[i].startTime);
         }
     },
     onchanged: function(changedItems) {
         console.log(&quot;Items changed&quot;);
         for (var i in changedItems) {
             console.log(&quot;Item &quot; + i + &quot; direction: &quot; + changedItems[i].direction);
         }
     },
     onremoved: function(removedItems) {
         console.log(&quot;Items removed&quot;);
         for(var i in removedItems)  {
            console.log(&quot;Item &quot; + i + &quot; : &quot; + removedItems[i]);
         }
     }};

 try {
     // Registers a call history callback
     var handle = tizen.callhistory.addChangeListener(onListenerCB);

     // Unregisters a previously registered listener
     tizen.callhistory.removeChangeListener(handle);
 } catch (error) {
     console.log(&quot;Exception - code: &quot; + error.name + &quot; message: &quot; + error.message);
 }

 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long A handle which can be used for unregistering.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="observer">
            <descriptive>
                <description><p>
 A callback for handling the list of new or changed or <em>CallHistoryEntry </em>objects in the call history.
                </p></description>
            </descriptive>
            <Type name="CallHistoryChangeCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeChangeListener" id="::Callhistory::CallHistory::removeChangeListener">
        <webidl>        void removeChangeListener(long handle) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a listener to unregister a previously registered listener.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/callhistory.read
            </privilege>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="handle">
            <descriptive>
                <description><p>
 The previously obtained listener handle.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="CallHistoryEntryArraySuccessCallback" id="::Callhistory::CallHistoryEntryArraySuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface CallHistoryEntryArraySuccessCallback {
        void onsuccess(<ref>CallHistoryEntry</ref>[] entries);
    };</webidl>
      <descriptive>
          <brief>
 This is a callback interface of <em>CallHistory </em>operations.
For example code, see <em>CallHistory </em>interface.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Callhistory::CallHistoryEntryArraySuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>CallHistoryEntry</ref>[] entries);</webidl>
        <descriptive>
            <brief>
 Called when the queries on call history have been successfully completed.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="entries">
            <descriptive>
                <description><p>
 An array of <em>CallHistoryEntry </em>objects, representing the result set of the query over the call history.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CallHistoryEntry"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="CallHistoryChangeCallback" id="::Callhistory::CallHistoryChangeCallback">
      <webidl>    [Callback, NoInterfaceObject]
    interface CallHistoryChangeCallback {
        void onadded(<ref>CallHistoryEntry</ref>[] newItems);

        void onchanged(<ref>CallHistoryEntry</ref>[] changedItems);

        void onremoved(DOMString[] removedItems);
    };</webidl>
      <descriptive>
          <brief>
 This is a callback interface of a<em> CallHistory </em>operations.
For example code, see <em>CallHistory </em>interface.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onadded" id="::Callhistory::CallHistoryChangeCallback::onadded">
        <webidl>        void onadded(<ref>CallHistoryEntry</ref>[] newItems);</webidl>
        <descriptive>
            <brief>
 Called when a new call history item is added.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="newItems">
            <descriptive>
                <description><p>
 An array of <em>CallHistoryEntry </em>objects, representing the new items added to call history.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CallHistoryEntry"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onchanged" id="::Callhistory::CallHistoryChangeCallback::onchanged">
        <webidl>        void onchanged(<ref>CallHistoryEntry</ref>[] changedItems);</webidl>
        <descriptive>
            <brief>
 Called when the call history have been changed.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="changedItems">
            <descriptive>
                <description><p>
 An array of <em>CallHistoryEntry </em>objects, representing the changed items in call history.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="CallHistoryEntry"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onremoved" id="::Callhistory::CallHistoryChangeCallback::onremoved">
        <webidl>        void onremoved(DOMString[] removedItems);</webidl>
        <descriptive>
            <brief>
 Called when the call history have been removed.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="removedItems">
            <descriptive>
                <description><p>
 An array of an uid of <em>CallHistoryEntry </em>objects, representing the removed items in call history.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="DOMString"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Contact" id="::Contact">
    <webidl>module Contact {

  typedef DOMString AddressBookId;

  typedef DOMString ContactId;

  typedef DOMString PersonId;

  typedef DOMString ContactGroupId;

  enum ContactTextFormat {&quot;VCARD_30&quot;};

  [NoInterfaceObject] interface ContactManagerObject {
    readonly attribute <ref>ContactManager</ref> contact;
  };
  <ref>Tizen</ref> implements <ref>ContactManagerObject</ref>;

  [NoInterfaceObject] interface ContactManager {

    void getAddressBooks(<ref>AddressBookArraySuccessCallback</ref> successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    <ref>AddressBook</ref> getUnifiedAddressBook() raises(<ref>WebAPIException</ref>);

    <ref>AddressBook</ref> getDefaultAddressBook() raises(<ref>WebAPIException</ref>);

    <ref>AddressBook</ref> getAddressBook(<ref>AddressBookId</ref> addressBookId) raises(<ref>WebAPIException</ref>);

    <ref>Person</ref> get(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);

    void update(<ref>Person</ref> person) raises(<ref>WebAPIException</ref>);

    void updateBatch(<ref>Person</ref>[] persons,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void remove(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);

    void removeBatch(<ref>PersonId</ref>[] personIds,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void find(<ref>PersonArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);

    long addChangeListener(<ref>PersonsChangeCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);

    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface AddressBook {

    readonly attribute <ref>AddressBookId</ref>? id;

    readonly attribute DOMString name;

    readonly attribute boolean readOnly;

    <ref>Contact</ref> get(<ref>ContactId</ref> id) raises(<ref>WebAPIException</ref>);

    void add(<ref>Contact</ref> contact) raises(<ref>WebAPIException</ref>);

    void addBatch(<ref>Contact</ref>[] contacts,
                  optional <ref>ContactArraySuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void update(<ref>Contact</ref> contact) raises(<ref>WebAPIException</ref>);

    void updateBatch(<ref>Contact</ref>[] contacts,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void remove(<ref>ContactId</ref> id) raises(<ref>WebAPIException</ref>);

    void removeBatch(<ref>ContactId</ref>[] ids,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void find(<ref>ContactArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);

    long addChangeListener(<ref>AddressBookChangeCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);

    <ref>ContactGroup</ref> getGroup(<ref>ContactGroupId</ref> groupId) raises(<ref>WebAPIException</ref>);

    void addGroup(<ref>ContactGroup</ref> group) raises(<ref>WebAPIException</ref>);

    void updateGroup(<ref>ContactGroup</ref> group) raises(<ref>WebAPIException</ref>);

    void removeGroup(<ref>ContactGroupId</ref> groupId) raises(<ref>WebAPIException</ref>);

    <ref>ContactGroup</ref>[] getGroups() raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface Person {
    readonly attribute <ref>PersonId</ref> id;

    readonly attribute DOMString displayName;

    readonly attribute long contactCount;

    readonly attribute boolean hasPhoneNumber;

    readonly attribute boolean hasEmail;

    attribute boolean isFavorite;

    attribute DOMString? photoURI;

    attribute DOMString? ringtoneURI;

    attribute <ref>ContactId</ref> displayContactId;

    void link(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);

    <ref>Person</ref> unlink(<ref>ContactId</ref> contactId) raises(<ref>WebAPIException</ref>);
  };

  dictionary ContactInit {
    <ref>ContactName</ref> name;
    <ref>ContactAddress</ref>[] addresses;
    DOMString photoURI;
    <ref>ContactPhoneNumber</ref>[] phoneNumbers;
    <ref>ContactEmailAddress</ref>[] emails;
    Date birthday;
    <ref>ContactAnniversary</ref>[] anniversaries;
    <ref>ContactOrganization</ref>[] organizations;
    DOMString[] notes;
    <ref>ContactWebSite</ref>[] urls;
    DOMString ringtoneURI;
    <ref>ContactGroupId</ref>[] groupIds;
  };

  [Constructor(optional <ref>ContactInit</ref>? ContactInitDict),
   Constructor(DOMString stringRepresentation)]
  interface Contact {
    readonly attribute <ref>ContactId</ref>? id;

    readonly attribute <ref>PersonId</ref>? personId;

    readonly attribute <ref>AddressBookId</ref>? addressBookId;

    readonly attribute Date? lastUpdated;

    readonly attribute boolean isFavorite;

    attribute <ref>ContactName</ref>? name setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactAddress</ref>[] addresses setraises(<ref>WebAPIException</ref>);

    attribute DOMString? photoURI setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactPhoneNumber</ref>[] phoneNumbers setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactEmailAddress</ref>[] emails setraises(<ref>WebAPIException</ref>);

    attribute Date? birthday setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactAnniversary</ref>[] anniversaries setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactOrganization</ref>[] organizations setraises(<ref>WebAPIException</ref>);

    attribute DOMString[] notes setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactWebSite</ref>[] urls setraises(<ref>WebAPIException</ref>);

    attribute DOMString? ringtoneURI setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactGroupId</ref>[] groupIds setraises(<ref>WebAPIException</ref>);

    DOMString convertToString(optional <ref>ContactTextFormat</ref>? format) raises(<ref>WebAPIException</ref>);

    <ref>Contact</ref> clone() raises(<ref>WebAPIException</ref>);
  };

  [Constructor(<ref>AddressBookId</ref> addressBookId, <ref>ContactId</ref> contactId)]
  interface ContactRef {
    attribute <ref>AddressBookId</ref> addressBookId;

    attribute <ref>ContactId</ref> contactId;
  };

  dictionary ContactNameInit {
    DOMString prefix;
    DOMString suffix;
    DOMString firstName;
    DOMString middleName;
    DOMString lastName;
    DOMString[] nicknames;
    DOMString phoneticFirstName;
    DOMString phoneticLastName;
  };

  [Constructor(optional <ref>ContactNameInit</ref>? nameInitDict)]
  interface ContactName {
    attribute DOMString? prefix;

    attribute DOMString? suffix;

    attribute DOMString? firstName;

    attribute DOMString? middleName;

    attribute DOMString? lastName;

    attribute DOMString[] nicknames;

    attribute DOMString? phoneticFirstName;

    attribute DOMString? phoneticLastName;

    readonly attribute DOMString? displayName;
  };

  dictionary ContactOrganizationInit {
    DOMString name;
    DOMString department;
    DOMString title;
    DOMString role;
    DOMString logoURI;
  };

  [Constructor(optional <ref>ContactOrganizationInit</ref>? orgInitDict)]
  interface ContactOrganization {
    attribute DOMString? name;

    attribute DOMString? department;

    attribute DOMString? title;

    attribute DOMString? role;

    attribute DOMString? logoURI;
  };

  [Constructor(DOMString url, optional DOMString type)]
  interface ContactWebSite
  {
    attribute DOMString url;

    attribute DOMString type;
  };

  [Constructor(Date date, optional DOMString? label)]
  interface ContactAnniversary
  {
    attribute Date date;

    attribute DOMString? label;
  };

  dictionary ContactAddressInit
  {
    DOMString country;
    DOMString region;
    DOMString city;
    DOMString streetAddress;
    DOMString additionalInformation;
    DOMString postalCode;
    boolean isDefault;
    DOMString[] types;
  };

  [Constructor(optional <ref>ContactAddressInit</ref>? addressInitDict)]
  interface ContactAddress
  {
    attribute DOMString? country;

    attribute DOMString? region;

    attribute DOMString? city;

    attribute DOMString? streetAddress;

    attribute DOMString? additionalInformation;

    attribute DOMString? postalCode;

    attribute boolean isDefault;

    attribute DOMString[] types;
  };

  [Constructor(DOMString number, optional DOMString[] types, optional boolean isDefault)]
  interface ContactPhoneNumber
  {
    attribute DOMString number;

    attribute boolean isDefault;

    attribute DOMString[] types;
  };

  [Constructor(DOMString email, optional DOMString[] types, optional boolean isDefault)]
  interface ContactEmailAddress
  {
    attribute DOMString email;

    attribute boolean isDefault;

    attribute DOMString[] types;
  };

  [Constructor(DOMString name, optional DOMString? ringtoneURI, optional DOMString? photoURI)]
  interface ContactGroup
  {
    readonly attribute <ref>ContactGroupId</ref>? id;

    readonly attribute <ref>AddressBookId</ref>? addressBookId;

    attribute DOMString name;

    attribute DOMString? ringtoneURI;

    attribute DOMString? photoURI;

    readonly attribute DOMString readOnly;
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface PersonArraySuccessCallback {
    void onsuccess(<ref>Person</ref>[] persons);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface ContactArraySuccessCallback {
    void onsuccess(<ref>Contact</ref>[] contacts);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface AddressBookArraySuccessCallback {
    void onsuccess(<ref>AddressBook</ref>[] addressbooks);
  };

  [Callback, NoInterfaceObject] interface AddressBookChangeCallback {
    void oncontactsadded(<ref>Contact</ref>[] contacts);

    void oncontactsupdated(<ref>Contact</ref>[] contacts);

    void oncontactsremoved(<ref>ContactId</ref>[] contactIds);
  };

  [Callback, NoInterfaceObject] interface PersonsChangeCallback {
    void onpersonsadded(<ref>Person</ref>[] persons);

    void onpersonsupdated(<ref>Person</ref>[] persons);

    void onpersonsremoved(<ref>PersonId</ref>[] personIds);
  };
};</webidl>
    <descriptive>
        <brief>
 This API is for managing Address Books.
        </brief>
       <description>
        <p>
A contact is a set of information that describes a contact. The contact contains information, such as phone numbers,
e-mail addresses, etc.
        </p>
        <p>
<a href='http://www.ietf.org/rfc/rfc2426.txt'> RFC 2426 vCard MIME Directory Profile</a> defines a format for exchanging contacts. Contact API refers to this specification to provide a mapping of the specified contact attributes.
        </p>
        <p>
A <em>person </em>is a set of information that describes a person. Two different <em>contacts</em> that indicate the same person will have the same person ID. A person has a display contact ID that indicates a contact that represents information of the person. A person is automatically created when a new contact is added.
        </p>
        <p>
This API provides functionality to read, create, remove, and update contacts in specific address books. Address books can be obtained using the <em>getAddressBooks()</em> method, which returns an array of <em>AddressBook</em> objects.
        </p>
        <p>
For more information on the Contact features, see <a href="../../org.tizen.web.appprogramming/html/guide/social_guide/contact.htm">Contact Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
    </descriptive>
    <Typedef name="AddressBookId" id="::Contact::AddressBookId">
      <webidl>  typedef DOMString AddressBookId;</webidl>
      <descriptive>
          <brief>
 The address book identifier.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="ContactId" id="::Contact::ContactId">
      <webidl>  typedef DOMString ContactId;</webidl>
      <descriptive>
          <brief>
 The contact identifier.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="PersonId" id="::Contact::PersonId">
      <webidl>  typedef DOMString PersonId;</webidl>
      <descriptive>
          <brief>
 The person identifier.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="ContactGroupId" id="::Contact::ContactGroupId">
      <webidl>  typedef DOMString ContactGroupId;</webidl>
      <descriptive>
          <brief>
 The group identifier.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Enum name="ContactTextFormat" id="::Contact::ContactTextFormat">
      <webidl>  enum ContactTextFormat {&quot;VCARD_30&quot;};</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the contact format that is used for export.   * The possible values are:
          </brief>
         <description>
          <ul>
            <li>
VCARD_30 - vCard v3.0 format            </li>
          </ul>
          <p>
Currently, vCard v3.0 is the only format supported by the Tizen platform.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="VCARD_30">
        <webidl>&quot;VCARD_30</webidl>
      </EnumValue>
    </Enum>
    <Interface name="ContactManagerObject" id="::Contact::ContactManagerObject">
      <webidl>  [NoInterfaceObject] interface ContactManagerObject {
    readonly attribute <ref>ContactManager</ref> contact;
  };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated by the <em>Tizen </em>object from the Tizen Platform.
          </brief>
         <description>
          <p>
There is a <em>tizen.contact </em>object that allows access to the Contact API functionality.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="contact" id="::Contact::ContactManagerObject::contact">
        <webidl>    readonly attribute <ref>ContactManager</ref> contact;</webidl>
        <Type name="ContactManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="ContactManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>ContactManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="ContactManager" id="::Contact::ContactManager">
      <webidl>  [NoInterfaceObject] interface ContactManager {

    void getAddressBooks(<ref>AddressBookArraySuccessCallback</ref> successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    <ref>AddressBook</ref> getUnifiedAddressBook() raises(<ref>WebAPIException</ref>);

    <ref>AddressBook</ref> getDefaultAddressBook() raises(<ref>WebAPIException</ref>);

    <ref>AddressBook</ref> getAddressBook(<ref>AddressBookId</ref> addressBookId) raises(<ref>WebAPIException</ref>);

    <ref>Person</ref> get(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);

    void update(<ref>Person</ref> person) raises(<ref>WebAPIException</ref>);

    void updateBatch(<ref>Person</ref>[] persons,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void remove(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);

    void removeBatch(<ref>PersonId</ref>[] personIds,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void find(<ref>PersonArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);

    long addChangeListener(<ref>PersonsChangeCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);

    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface provides access to the API functionality.
          </brief>
         <description>
          <p>
This interface offers a method to retrieve the address books objects.
The address book objects can be manipulated with the provided functionalities to add, remove, and update the contained information.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getAddressBooks" id="::Contact::ContactManager::getAddressBooks">
        <webidl>    void getAddressBooks(<ref>AddressBookArraySuccessCallback</ref> successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the available address books.
            </brief>
           <description>
            <p>
If the operation completes successfully, the successCallback must
be invoked with the phone address book and the SIM address book (if any).
Other address books present in the device should also be returned.
            </p>
            <p>
If no address book is present, the <em>successCallback</em> will be invoked with an empty array.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If the event given in argument is not a recurring event.              </li>
              <li>
UnknownError - If any other error occurs while trying to get the address books.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code>  var addressbook;

  // Define the error callback for all the asynchronous calls
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  function contactsFoundCB(contacts) {
    // The contact has been successfully found
    // Let's try to change the first name
    contacts[0].name.firstName = 'Jeffrey Ross';
    try {
      addressbook.update(contacts[0]);
    } catch (err) {
      console.log( 'The following error occurred while updating: ' +  err.name);
    }
    console.log('First contact was updated');
  }

  // Define the success callback for retrieving all the
  // Address Books
  function addressBooksCB(addressbooks) {
    if(addressbooks.length > 0) {
      addressbook = addressbooks[0];
      console.log('The addressbook type is ' + addressbook.type +
            ' and name ' + addressbook.name);

      var contact = new tizen.Contact(
                         {name: new tizen.ContactName({firstName:'Jeffrey',
                                 lastName:'Hyman',
                                 nicknames:['joey ramone']}),
                          emails:[new tizen.ContactEmailAddress('user@domain.com')],
                          phoneNumbers:[new tizen.ContactPhoneNumber('123456789')]});

      addressbook.add(contact);

      // The contact has been successfully added
      // Checks whether the added contact can be retrieved from the address book or not.
      // If the address book is empty, only the item added through saveContact
      // should be returned
      var filter = new tizen.AttributeFilter('name.firstName', 'CONTAINS', 'Jeffrey');
      try {
        addressbook.find(contactsFoundCB, errorCB, filter);
      } catch (err) {
        console.log( 'The following error occurred while finding: ' +  err.name);
      }
    }
  }

  // Get a list of available address books.
  tizen.contact.getAddressBooks(addressBooksCB, errorCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="AddressBookArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getUnifiedAddressBook" id="::Contact::ContactManager::getUnifiedAddressBook">
        <webidl>    <ref>AddressBook</ref> getUnifiedAddressBook() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the aggregation of all address books.
            </brief>
           <description>
            <p>
The unified address book is a logical address book that represents an aggregation of all address books
that are obtained by getAddressBooks() and contains all contacts in the address books.
Note that the unified address book does not have an address book ID
and it is set to <var>null</var>.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code>  var addressbook;

  // Define the error callback
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  function contactsFoundCB(contacts) {
    // The contact has been successfully found
    // Let's try to change the first name
    contacts[0].name.firstName = 'Jeffrey Ross';
    try {
      addressbook.update(contacts[0]);
      console.log('First contact was updated');
    } catch (err) {
      console.log( 'The following error occurred while updating: ' +  err.name);
    }
  }

  // Get unified address book.
  addressbook = tizen.contact.getUnifiedAddressBook();

  // Add a new contact
  var contact = new tizen.Contact(
                     {name: new tizen.ContactName({firstName:'Jeffrey',
                             lastName:'Hyman',
                             nicknames:['joey ramone']}),
                      emails:[new tizen.ContactEmailAddress('user@domain.com')],
                      phoneNumbers:[new tizen.ContactPhoneNumber('123456789')]});

  try {
    addressbook.add(contact);
  } catch (err) {
    console.log( 'The following error occurred while adding: ' +  err.name);
  }

  // The contact has been successfully added
  // Let's try to check if we can retrieve the added
  // contact from the address book. If the address book
  // was empty only the item added through saveContact should
  // be returned
  var filter = new tizen.AttributeFiilter('name.firstName', 'CONTAINS', 'Jeffrey');
  try {
    addressbook.find(contactsFoundCB, errorCB, filter);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type name="AddressBook">
          <descriptive>
              <description><p>
 AddressBook The unified AddressBook object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getDefaultAddressBook" id="::Contact::ContactManager::getDefaultAddressBook">
        <webidl>    <ref>AddressBook</ref> getDefaultAddressBook() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the default address book.
            </brief>
           <description>
            <p>
The default address book is the appointed addressbook from platform or operator.
This is one of addressBooks and it has the address book ID.
            </p>
            <p>
If the operation completes successfully, it must return the
default address book.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code>  var addressbook;

  // Define the error callback
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  function contactsFoundCB(contacts) {
    // The contact has been successfully found
    // Let's try to change the first name
    contacts[0].name.firstName = 'Jeffrey Ross';
    try {
      addressbook.update(contacts[0]);
      console.log('First contact was updated');
    } catch (err) {
      console.log( 'The following error occurred while updating: ' +  err.name);
    }
  }

  // Get default address book.
  addressbook = tizen.contact.getDefaultAddressBook();

  // Add a new contact
  var contact = new tizen.Contact(
                     {name: new tizen.ContactName({firstName:'Jeffrey',
                             lastName:'Hyman',
                             nicknames:['joey ramone']}),
                      emails:[new tizen.ContactEmailAddress('user@domain.com')],
                      phoneNumbers:[new tizen.ContactPhoneNumber('123456789')]});

  try {
    addressbook.add(contact);
  } catch (err) {
    console.log( 'The following error occurred while adding: ' +  err.name);
  }

  // The contact has been successfully added
  // Checks whether the added contact can be retrieved from the address book or not.
  // If the address book is empty, only the item added
  // through em>saveContact /em>should be returned
  var filter = new tizen.AttributeFiilter('name.firstName', 'CONTAINS', 'Jeffrey');
  try {
    addressbook.find(contactsFoundCB, errorCB, filter);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type name="AddressBook">
          <descriptive>
              <description><p>
 AddressBook The default AddressBook object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAddressBook" id="::Contact::ContactManager::getAddressBook">
        <webidl>    <ref>AddressBook</ref> getAddressBook(<ref>AddressBookId</ref> addressBookId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the address book with the specified identifier.
            </brief>
           <description>
            <p>
If the operation completes successfully, it must return the
address book with the specified identifier.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code> var contactRef; // ContactRef supposed to be initialized
 try {
   // Retrieves the Contact corresponding to a given ContactRef.
   var addressBook = tizen.contact.getAddressBook(contactRef.addressBookId);
   var contact = addressBook.get(contactRef.contactId);
   console.log(&quot;Successfully resolved contact with id: &quot; + contactRef.contactId);
 } catch(err) {
   console.log(&quot;Error: &quot; + err.name);
 }
 </Code>
        </descriptive>
        <Type name="AddressBook">
          <descriptive>
              <description><p>
 AddressBook The matching AddressBook object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="addressBookId">
            <descriptive>
                <description><p>
 The address book identifier.
                </p></description>
            </descriptive>
            <Type name="AddressBookId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if there is no address book
with the given identifier.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="get" id="::Contact::ContactManager::get">
        <webidl>    <ref>Person</ref> get(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the person with the specified identifier.
            </brief>
           <description>
            <p>
If the operation completes successfully, it must return the
person with the specified identifier.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code> var contactRef; // ContactRef supposed to be initialized
 try {
   // Retrieves the Person corresponding to a Contact.
   var addressBook = tizen.contact.getAddressBook(contactRef.addressBookId);
   var contact = addressBook.get(contactRef.contactId);
   var person = tizen.contact.get(contact.personId);
   console.log(&quot;Successfully resolved person with id: &quot; + contact.personId);
 } catch(err) {
   console.log(&quot;Error: &quot; + err.name);
 }
 </Code>
        </descriptive>
        <Type name="Person">
          <descriptive>
              <description><p>
 Person The matching Person object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="personId">
            <descriptive>
                <description><p>
 The Person identifier.
                </p></description>
            </descriptive>
            <Type name="PersonId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if there is no person
with the given identifier.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="update" id="::Contact::ContactManager::update">
        <webidl>    void update(<ref>Person</ref> person) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates a person in the address book synchronously.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  // Define the error callback
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  function personsFoundCB(persons) {
    // The person has been successfully found
    // Let's try to change the isFavorite attribute
    persons[0].isFavorite = true;
    try {
      tizen.contact.update(persons[0]);
      console.log('First person was updated');
    } catch (err) {
      console.log( 'The following error occurred while updating: ' +  err.name);
    }
  }

  try {
    tizen.contact.find(personsFoundCB, errorCB);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="person">
            <descriptive>
                <description><p>
 The person object to be updated.
                </p></description>
            </descriptive>
            <Type name="Person"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if the person could not be updated
to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="updateBatch" id="::Contact::ContactManager::updateBatch">
        <webidl>    void updateBatch(<ref>Person</ref>[] persons,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates several existing persons in the contact DB asynchronously.
            </brief>
           <description>
            <p>
The <em>errorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If an identifier in the IDs parameter does not correspond to the <em>id</em> attribute of any person in the contact DB.              </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs, while trying to add the persons.              </li>
            </ul>
            <p>
If the details of any persons cannot be updated, the error callback function that was passed in the invocation will be called.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  // Define the error callback for all the asynchronous calls
  function errorCB(err) {
    console.log('The following error occurred: ' +  err.name);
  }

  function personsUpdatedCB() {
    console.log('Contacts were updated');
  }

  function personsFoundCB(persons) {
    // The person has been successfully found
    for(var i = 0; i &#60; persons.length; i++) {
      persons[i].isFavorite = true;
    }
    try {
      tizen.contact.updateBatch(persons, personsUpdatedCB, errorCB);
    } catch (err) {
      console.log('The following error occurred while updating: ' +  err.name);
    }
  }

  try {
    tizen.contact.find(personsFoundCB, errorCB);
  } catch (err) {
    console.log('The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="persons">
            <descriptive>
                <description><p>
 A list of Person objects to be saved in the terminal storage.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Person"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when the request to update the details of a person fail.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::Contact::ContactManager::remove">
        <webidl>    void remove(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a person from the contact DB synchronously.
            </brief>
           <description>
            <p>
Removes the person that corresponds to the specified identifier and the contacts related to the person as well. This function will throw an exception if it fails to remove the specified person.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  // Define the error callback
  function errorCB(err) {
    console.log('The following error occurred: ' +  err.name);
  }

  function personsFoundCB(persons) {
    // The person has been successfully found
    if(persons.length > 0) {
      try {
        tizen.contact.remove(persons[0].id);
        console.log('First person was removed');
      } catch (err) {
        console.log('The following error occurred while removing: ' +  err.name);
      }
    } else {
      console.log( 'No persons.');
    }
  }

  try {
    tizen.contact.find(personsFoundCB, errorCB);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="personId">
            <descriptive>
                <description><p>
 An identifier (ID attribute) of the Person object to delete.
                </p></description>
            </descriptive>
            <Type name="PersonId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match
any persons.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if the person could not be removed
to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeBatch" id="::Contact::ContactManager::removeBatch">
        <webidl>    void removeBatch(<ref>PersonId</ref>[] personIds,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes persons from contact DB asynchronously.
            </brief>
           <description>
            <p>
Removes the persons that correspond to the specified identifiers as well as the contacts related to them.
            </p>
            <p>
The <em>errorCallback() </em>is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If an identifier in the <em>personIds </em>parameter does not correspond to the ID of any person in the contact DB. (Otherwise, the implementation will attempt to remove the contacts corresponding to these identifiers).              </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs while trying to remove the persons.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  // Define the error callback
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  function personsRemovedCB() {
    console.log('Contacts were removed');
  }

  function personsFoundCB(persons) {
    // The person has been successfully found
    if(persons.length > 2) {
      try {
        tizen.contact.removeBatch([persons[0].id, persons[1].id], personsRemovedCB, errorCB);
      } catch (err) {
        console.log( 'The following error occurred while removing: ' +  err.name);
      }
    } else {
      console.log( 'Not enough persons.');
    }
  }

  try {
    tizen.contact.find(personsFoundCB, errorCB);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="personIds">
            <descriptive>
                <description><p>
 A list of identifiers (id attribute) for the Person objects to delete.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="PersonId"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when the request to delete persons fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="find" id="::Contact::ContactManager::find">
        <webidl>    void find(<ref>PersonArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets an array of all <em>Person </em>objects from the contact DB or the ones that match the optionally supplied filter.
            </brief>
           <description>
            <p>
If the filter is passed and contains valid values, only those values in the
address book that match the filter criteria as specified in the AbstractFilter
interface will be returned in the successCallback. If no filter is passed, the filter
contains any invalid values, the filter is <var>null </var> or undefined, then
the implementation must return the full list of contact items
in the successCallback. If no persons are available in the contact DB or no
person matches the filter criteria, the successCallback will be invoked
with an empty array.
            </p>
            <p>
The <em>errorCallback() </em>is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs while trying to retrieve the persons.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code>  // Define the error callback.
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  // Define the person search success callback.
  function personsFoundCB(persons) {
    console.log(persons.length + ' results found.');
  }

  // Finds all the persons in the contact DB that have the word Ramone in their display name
  var filter = new tizen.AttributeFilter('displayName', 'CONTAINS', 'Ramone');

  // The persons returned by the find() query will be sorted in the ascending order of their display name.
  var sortingMode =  new tizen.SortMode('displayName', 'ASC');
  try {
    tizen.contact.find(personsFoundCB, errorCB,
                     filter, sortingMode);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="PersonArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 A filter to select which persons are returned.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="sortMode">
            <descriptive>
                <description><p>
 A variable to determine the sort order in which the persons are returned.
                </p></description>
            </descriptive>
            <Type name="SortMode" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addChangeListener" id="::Contact::ContactManager::addChangeListener">
        <webidl>    long addChangeListener(<ref>PersonsChangeCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Subscribes to receive notifications about persons' changes.
            </brief>
           <description>
            <p>
When executed, the implementation must immediately return a subscription identifier that identifies
the watch operation. After returning the identifier, the watch operation is started
asynchronously.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code> var watcherId = 0; // watcher identifier

 var watcher = {
   onpersonsadded: function(persons) {
     console.log(persons.length + ' persons were added');
   },
   onpersonsupdated: function(persons) {
     console.log(persons.length + ' persons were updated');
   },
   onpersonsremoved: function(ids) {
     console.log(ids.length + ' persons were deleted');
   }
 };

 // registers to be notified when the persons' changes
 watcherId = tizen.contact.addChangeListener(watcher);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long Identifier used to clear the watch subscription.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 Contains the methods for different types of change notifications.
                </p></description>
            </descriptive>
            <Type name="PersonsChangeCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters
contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeChangeListener" id="::Contact::ContactManager::removeChangeListener">
        <webidl>    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsubscribes a persons' changes watch operation.
            </brief>
           <description>
            <p>
If the watchId argument is valid and corresponds to a subscription already in
place, the watch process must immediately stop and no further callbacks MUST be
invoked. If the watchId argument is not valid or does not correspond to a
valid subscription, the method should return without any further action.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code> var watcherId = 0; // watcher identifier

 // Receives persons' changes
 var watcher = {
   onpersonsadded: function(persons) {
     console.log(persons.length + ' persons were added');
   },
   onpersonsupdated: function(persons) {
     console.log(persons.length + ' persons were updated');
   },
   onpersonsremoved: function(ids) {
     console.log(ids.length + ' persons were removed');
   }
 };

 // Cancel the watch operation
 function cancelWatch() {
    tizen.contact.removeChangeListener(watcherId);
 }

 // registers to be notified when the persons' changes
 watcherId = tizen.contact.addChangeListener(watcher);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="watchId">
            <descriptive>
                <description><p>
 A subscription Identifier.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type NotFoundError, if there is no listener
with the given identifier.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="AddressBook" id="::Contact::AddressBook">
      <webidl>  [NoInterfaceObject] interface AddressBook {

    readonly attribute <ref>AddressBookId</ref>? id;

    readonly attribute DOMString name;

    readonly attribute boolean readOnly;

    <ref>Contact</ref> get(<ref>ContactId</ref> id) raises(<ref>WebAPIException</ref>);

    void add(<ref>Contact</ref> contact) raises(<ref>WebAPIException</ref>);

    void addBatch(<ref>Contact</ref>[] contacts,
                  optional <ref>ContactArraySuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void update(<ref>Contact</ref> contact) raises(<ref>WebAPIException</ref>);

    void updateBatch(<ref>Contact</ref>[] contacts,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void remove(<ref>ContactId</ref> id) raises(<ref>WebAPIException</ref>);

    void removeBatch(<ref>ContactId</ref>[] ids,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void find(<ref>ContactArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);

    long addChangeListener(<ref>AddressBookChangeCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);

    <ref>ContactGroup</ref> getGroup(<ref>ContactGroupId</ref> groupId) raises(<ref>WebAPIException</ref>);

    void addGroup(<ref>ContactGroup</ref> group) raises(<ref>WebAPIException</ref>);

    void updateGroup(<ref>ContactGroup</ref> group) raises(<ref>WebAPIException</ref>);

    void removeGroup(<ref>ContactGroupId</ref> groupId) raises(<ref>WebAPIException</ref>);

    <ref>ContactGroup</ref>[] getGroups() raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface provides methods to manage an address book.
          </brief>
         <description>
          <p>
An address book is a collection of contacts and groups. This interface offers methods to manage the address book and to manipulate contacts within the address book, such as:
          </p>
          <ul>
            <li>
 <em>get()</em> - To get contacts that have a specific ID            </li>
            <li>
 <em>find()</em> - To find contacts using filters            </li>
            <li>
 <em>add() </em>or <em>addBatch()</em> - To add contacts to a specific address book            </li>
            <li>
 <em>update() </em>or <em>updateBatch()</em> - To update contacts in a specific address book            </li>
            <li>
 <em>remove() </em>or <em>removeBatch() </em> - To remove existing contacts            </li>
            <li>
 <em>addChangeListener() </em>or <em>removeChangeListener() </em> - To watch for address book changes            </li>
          </ul>
          <p>
This interface also offers methods to manipulate groups within the address book, such as:
          </p>
          <ul>
            <li>
 <em>getGroup()</em> - To get a group having specific ID            </li>
            <li>
 <em>getGroups()</em> - To get groups in a specific address book            </li>
            <li>
 <em>addGroup() </em> - To add groups to a specific address book             </li>
            <li>
 <em>updateGroup() </em> - To update groups in a specific address book            </li>
            <li>
 <em>removeGroup() </em> - To remove existing groups            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Contact::AddressBook::id">
        <webidl>    readonly attribute <ref>AddressBookId</ref>? id;</webidl>
        <descriptive>
            <brief>
 An attribute to uniquely identify the address book.
            </brief>
           <description>
            <p>
The value of this attribute shall be <var>null </var> if the address book
is the unified address book.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="AddressBookId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Contact::AddressBook::name">
        <webidl>    readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 The address book descriptive name.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="readOnly" id="::Contact::AddressBook::readOnly">
        <webidl>    readonly attribute boolean readOnly;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate if the address book is read-only.
            </brief>
           <description>
            <p>
Some on line address books cannot be edited and will have this
flag set to <var>true</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="get" id="::Contact::AddressBook::get">
        <webidl>    <ref>Contact</ref> get(<ref>ContactId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the contact with the specified identifier.
            </brief>
           <description>
            <p>
If the operation completes successfully, it must return the
contact with the specified identifier.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code> var contactRef; // ContactRef supposed to be initialized
 try {
   // Retrieves the Contact corresponding to a given ContactRef.
   var addressBook = tizen.contact.getAddressBook(contactRef.addressBookId);
   var contact = addressBook.get(contactRef.contactId);
   console.log(&quot;Successfully resolved contact with id: &quot; + contactRef.contactId);
 } catch(err) {
   console.log(&quot;Error: &quot; + err.name);
 }
 </Code>
        </descriptive>
        <Type name="Contact">
          <descriptive>
              <description><p>
 Contact The matching Contact object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 A contact identifier.
                </p></description>
            </descriptive>
            <Type name="ContactId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if there is no contact
with the given identifier.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="add" id="::Contact::AddressBook::add">
        <webidl>    void add(<ref>Contact</ref> contact) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a contact to the address book synchronously.
            </brief>
           <description>
            <p>
If the contact is successfully inserted in the addressbook, the Contact object
will have its identifier (id attribute) set when the function returns.
This operation is done successfully, new person object is also generated automatically.
            </p>
            <p>
If you wish to update an
existing contact, call the update() method instead. If you wish to add a copy
of an existing Contact object, call Contact.clone() method first and pass the
clone to the add() method.
            </p>
            <p>
The contact shall be added to default address book if the address book
is the unified address book.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Get default address book
  addressbook = tizen.contact.getDefaultAddressBook();

  try {
    var contact = new tizen.Contact({name: new tizen.ContactName({firstName:'Jeffrey',
                                          lastName:'Hyman',
                                          nicknames:['joey ramone']}),
                                    emails:[new tizen.ContactEmailAddress('user@domain.com')],
                                    phoneNumbers:[new tizen.ContactPhoneNumber('123456789')]});
    addressbook.add(contact);
    console.log('Contact added with id ' + contact.id);
  } catch (err) {
    console.log( 'The following error occurred while adding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contact">
            <descriptive>
                <description><p>
 A contact to be added.
                </p></description>
            </descriptive>
            <Type name="Contact"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs while trying to insert the contact.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addBatch" id="::Contact::AddressBook::addBatch">
        <webidl>    void addBatch(<ref>Contact</ref>[] contacts,
                  optional <ref>ContactArraySuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds several contacts to the address book asynchronously.
            </brief>
           <description>
            <p>
If all the contacts are successfully added to the address book,
the success callback will be invoked, passing the list of Contact objects
that were added, with their identifier set (id attribute).
            </p>
            <p>
The <em>errorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value, the contact has any invalid value or the address book has some restrictions (such as, limitations in the size of text attributes) because of which the contact items were not added.              </li>
              <li>
UnknownError - If any other error occurs, while trying to add the contacts.              </li>
            </ul>
            <p>
If you wish to update an
existing contact, call the update() method instead. If you wish to add a copy
of an existing Contact object, call Contact.clone() method first and pass the
clone to the add() method.
            </p>
            <p>
If any of the contacts cannot be added, the error callback
function that was passed in the invocation will be called.
            </p>
            <p>
The contacts shall be added to local phone address book if the address book
is the default address book.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Define the error callback
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  // Define the add contact success callback
  function contactsAddedCB(contacts) {
    console.log( contacts.length + ' contact(s) were successfully added to an Address Book' );
  };

  // Get default address book
  addressbook = tizen.contact.getDefaultAddressBook();

  var c1 = new tizen.Contact({name: new tizen.ContactName({firstName:'Jeffrey',
                             lastName:'Hyman',
                             nicknames:['joey ramone']}),
                             emails:[new tizen.ContactEmailAddress('user1@domain.com')],
                             phoneNumbers:[new tizen.ContactPhoneNumber('123456789')]});

  var c2 = new tizen.Contact({name: new tizen.ContactName({firstName:'Elton',
                             lastName:'John',
                             nicknames:['El']}),
                             emails:[new tizen.ContactEmailAddress('user2@domain.com')],
                             phoneNumbers:[new tizen.ContactPhoneNumber('987654321')]});

  try {
    addressbook.addBatch([c1, c2], contactsAddedCB, errorCB);
  } catch (err) {
    console.log( 'The following error occurred while adding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contacts">
            <descriptive>
                <description><p>
 A list of contacts to add.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Contact"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="ContactArraySuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when the request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="update" id="::Contact::AddressBook::update">
        <webidl>    void update(<ref>Contact</ref> contact) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates a contact in the address book synchronously.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Define the error callback
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  function contactsFoundCB(contacts) {
    // The contact has been successfully found
    // Let's try to change the first name
    contacts[0].name.firstName = 'Christopher';
    try {
      addressbook.update(contacts[0]);
      console.log('First contact was updated');
    } catch (err) {
      console.log( 'The following error occurred while updating: ' +  err.name);
    }
  }

  // Get default address book.
  addressbook = tizen.contact.getDefaultAddressBook();

  var filter = new tizen.AttributeFilter('name.firstName', 'CONTAINS', 'Chris');
  try {
    addressbook.find(contactsFoundCB, errorCB, filter);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contact">
            <descriptive>
                <description><p>
 A contact object to update.
                </p></description>
            </descriptive>
            <Type name="Contact"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if the contact could not be updated
to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="updateBatch" id="::Contact::AddressBook::updateBatch">
        <webidl>    void updateBatch(<ref>Contact</ref>[] contacts,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates several existing contacts in the address book asynchronously.
            </brief>
           <description>
            <p>
The <em>errorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If an identifier in the IDs parameter does not correspond to the <em>id </em>attribute of any contact in the address book.              </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs, while trying to add the contacts.              </li>
            </ul>
            <p>
If any of the contacts could not be updated, the error callback
function that was passed in the invocation will be called.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Define the error callback for all the asynchronous calls
  function errorCB(err) {
    console.log('The following error occurred: ' +  err.name);
  }

  function contactsUpdatedCB() {
    console.log('Contacts were updated');
  }

  function contactsFoundCB(contacts) {
    // The contact has been successfully found
    for(var i = 0; i &#60; contacts.length; i++) {
      contacts[i].name.firstName = 'Christopher';
    }
    try {
      addressbook.updateBatch(contacts, contactsUpdatedCB, errorCB);
    } catch (err) {
      console.log('The following error occurred while updating: ' +  err.name);
    }
  }

  // Get default address book.
  addressbook = tizen.contact.getDefaultAddressBook();

  var filter = new tizen.AttributeFilter('name.firstName', 'CONTAINS', 'Chris');
  try {
    addressbook.find(contactsFoundCB, errorCB, filter);
  } catch (err) {
    console.log('The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contacts">
            <descriptive>
                <description><p>
 A list of contact objects to be saved in the terminal storage.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Contact"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when the request to update contacts fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::Contact::AddressBook::remove">
        <webidl>    void remove(<ref>ContactId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a contact from the address book synchronously.
            </brief>
           <description>
            <p>
Removes the contact in the address book that corresponds to the specified
identifier. This function will throw an exception if it failed to
remove the specified contact.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Define the error callback
  function errorCB(err) {
    console.log('The following error occurred: ' +  err.name);
  }

  function contactsFoundCB(contacts) {
    // The contact has been successfully found
    if(contacts.length > 0) {
      try {
        addressbook.remove(contacts[0].id);
        console.log('First contact was removed');
      } catch (err) {
        console.log('The following error occurred while removing: ' +  err.name);
      }
    } else {
      console.log( 'No contacts.');
    }
  }

  // Get default address book.
  addressbook = tizen.contact.getDefaultAddressBook();

  var filter = new tizen.AttributeFilter('name.firstName', 'CONTAINS', 'Chris');
  try {
    addressbook.find(contactsFoundCB, errorCB, filter);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 An identifier (id attribute) of the contact object to delete.
                </p></description>
            </descriptive>
            <Type name="ContactId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match
any contact in the address book.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if the contact could not be removed
to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeBatch" id="::Contact::AddressBook::removeBatch">
        <webidl>    void removeBatch(<ref>ContactId</ref>[] ids,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes several contacts from the address book asynchronously.
            </brief>
           <description>
            <p>
The <em>errorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If an identifier in the IDs parameter does not correspond to the <em>id </em>attribute of any contact in the address book (Otherwise, the implementation will attempt to remove the contacts that correspond to these identifiers).              </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs while trying to remove the contacts.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Define the error callback
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  function contactsRemovedCB() {
    console.log('Contacts were removed');
  }

  function contactsFoundCB(contacts) {
    // The contact has been successfully found
    if(contacts.length > 2) {
      try {
        addressbook.removeBatch([contacts[0].id, contacts[1].id], contactsRemovedCB, errorCB);
      } catch (err) {
        console.log( 'The following error occurred while removing: ' +  err.name);
      }
    } else {
      console.log( 'Not enough contacts.');
    }
  }

  // Get default address book.
  addressbook = tizen.contact.getDefaultAddressBook();

  var filter = new tizen.AttributeFilter('name.firstName', 'CONTAINS', 'Chris');
  try {
    addressbook.find(contactsFoundCB, errorCB, filter);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="ids">
            <descriptive>
                <description><p>
 A list of identifiers (id attribute) for the contact objects to be deleted.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="ContactId"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when the request to delete contacts fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="find" id="::Contact::AddressBook::find">
        <webidl>    void find(<ref>ContactArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Finds an array of all Contact objects from the specified address book or an array of
Contact objects that match the optionally supplied filter.
            </brief>
           <description>
            <p>
If the filter is passed and contains valid values, only those values in the
address book that match the filter criteria as specified in the AbstractFilter
interface will be returned in the successCallback. If no filter is passed, the filter
contains any invalid values, the filter is <var>null</var> or undefined, then
the implementation MUST return the full list of contact items
in the successCallback. If no contacts are available in the address book or no
contact matches the filter criteria, the successCallback will be invoked
with an empty array.
            </p>
            <p>
The <em>errorCallback() </em>is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs while trying to retrieve the contacts.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code>  var addressbook;

  // Define the error callback.
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  // Define the contact search success callback.
  function contactsFoundCB(contacts) {
     console.log(contacts.length + ' results found.');
  }

  // Get default address book
  addressbook = tizen.contact.getDefaultAddressBook();

  // Find all contacts in the address book that have &quot;Ramone&quot; in the nick name.
  var filter = new tizen.AttributeFilter('name.nicknames', 'CONTAINS', 'Ramone');

  // The contacts returned by the find() query will be sorted by
  // ascending last name.
  var sortingMode =  new tizen.SortMode('name.lastName', 'ASC');
  try {
    addressbook.find(contactsFoundCB, errorCB,
                     filter, sortingModes);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="ContactArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 A filter used to select which contacts are returned.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="sortMode">
            <descriptive>
                <description><p>
 A variable to determine the sort order in which the contacts are returned.
                </p></description>
            </descriptive>
            <Type name="SortMode" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addChangeListener" id="::Contact::AddressBook::addChangeListener">
        <webidl>    long addChangeListener(<ref>AddressBookChangeCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Subscribes to receive notifications about address book changes.
            </brief>
           <description>
            <p>
When executed, the implementation must immediately return a subscription identifier that identifies
the watch operation. After returning the identifier, the watch operation is started
asynchronously.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code> var watcherId = 0; // watcher identifier
 var addressbook; // This example assumes addressbook is initialized

 var watcher = {
   oncontactsadded: function(contacts) {
     console.log(contacts.length + ' contacts were added');
   },
   oncontactsupdated: function(contacts) {
     console.log(contacts.length + ' contacts were updated');
   },
   oncontactsremoved: function(ids) {
     console.log(ids.length + ' contacts were deleted');
   }
 };

 // Registers to be notified when the address book changes
 watcherId = addressbook.addChangeListener(watcher);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long An identifier used to clear the watch subscription.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when different types of address book change notifications are received.
                </p></description>
            </descriptive>
            <Type name="AddressBookChangeCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call if address book changes cannot be watched.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters
contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeChangeListener" id="::Contact::AddressBook::removeChangeListener">
        <webidl>    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsubscribes an address book changes watch operation.
            </brief>
           <description>
            <p>
If the watchId argument is valid and corresponds to a subscription already in
place, the watch process MUST immediately stop and no further callbacks MUST be
invoked. If the watchId argument is not valid or does not correspond to a
valid subscription, the method should return without any further action.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code> var watcherId = 0; // watcher identifier
 var addressbook; // This example assumes addressbook is initialized

 // Receives address book changes
 var watcher = {
   oncontactsadded: function(contacts) {
     console.log(contacts.length + ' contacts were added');
   },
   oncontactsupdated: function(contacts) {
     console.log(contacts.length + ' contacts were updated');
   },
   oncontactsremoved: function(ids) {
     console.log(ids.length + ' contacts were removed');
   }
 };

 // Cancel the watch operation
 function cancelWatch() {
    addressbook.removeChangeListener(watcherId);
 }

 // registers to be notified when the address book changes
 watcherId = addressbook.addChangeListener(watcher);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="watchId">
            <descriptive>
                <description><p>
 A subscription identifier.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type NotFoundError, if there is no listener
with the given identifier.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getGroup" id="::Contact::AddressBook::getGroup">
        <webidl>    <ref>ContactGroup</ref> getGroup(<ref>ContactGroupId</ref> groupId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the group with the specified identifier.
            </brief>
           <description>
            <p>
If the operation completes successfully, it must return the
group with the given identifier.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code> try {
   // Retrieves the Person corresponding to a Contact.
   var addressBook = tizen.contact.getAddressBook(contactRef.addressBookId);
   var contact = addressBook.get(contactRef.contactId);
   var group = addressBook.getGroup(contact.groupIds[0].id);
   console.log(&quot;Successfully resolved group with id: &quot; + contact.groupIds[0].id);
 } catch(err) {
   console.log(&quot;Error: &quot; + err.name);
 }
 </Code>
        </descriptive>
        <Type name="ContactGroup">
          <descriptive>
              <description><p>
 ContactGroup The matching ContactGroup object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="groupId">
            <descriptive>
                <description><p>
 A group identifier.
                </p></description>
            </descriptive>
            <Type name="ContactGroupId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if there is no contact
with the given identifier.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addGroup" id="::Contact::AddressBook::addGroup">
        <webidl>    void addGroup(<ref>ContactGroup</ref> group) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a group to the address book.
            </brief>
           <description>
            <p>
If the group is successfully inserted in the addressbook, the Group object
will have its identifier (id attribute) set when the function returns.
            </p>
            <p>
The group shall be added to local phone address book if the address book
is the default address book.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Get address book
  var addressbooks = tizen.contact.getAddressBooks();
  addressbook = addressbooks[0];

  try {
    var group = new tizen.ContactGroup('Company');
    addressbook.addGroup(group);
    console.log('Group added with id ' + group.id);
  } catch (err) {
    console.log( 'The following error occurred while adding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="group">
            <descriptive>
                <description><p>
 A ContactGroup object to be added.
                </p></description>
            </descriptive>
            <Type name="ContactGroup"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs while trying to insert the contact.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="updateGroup" id="::Contact::AddressBook::updateGroup">
        <webidl>    void updateGroup(<ref>ContactGroup</ref> group) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates a group in the address book.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Get address book.
  var addressbooks = tizen.contact.getAddressBooks();
  addressbook = addressbooks[0];

  try {
    groups = addressbook.getGroups();
    groups[0].name = 'Friends';
    addressbook.updateGroup(groups[0]);
    console.log('First group was updated');
  } catch (err) {
    console.log( 'The following error occurred while adding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="group">
            <descriptive>
                <description><p>
 A ContactGroup object to be updated.
                </p></description>
            </descriptive>
            <Type name="ContactGroup"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if the group could not be updated
to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeGroup" id="::Contact::AddressBook::removeGroup">
        <webidl>    void removeGroup(<ref>ContactGroupId</ref> groupId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a group from the address book.
            </brief>
           <description>
            <p>
Removes the group in the address book that corresponds to the specified identifier. This method will throw an exception if it failed to remove the specified group.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var addressbook;

  // Get default address book.
  var addressbooks = tizen.contact.getAddressBooks();
  addressbook = addressbooks[0];

  try {
    groups = addressbook.getGroups();
    addressbook.removeGroup(groups[0].id);
    console.log('First group was removed');
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="groupId">
            <descriptive>
                <description><p>
 An identifier (id attribute) of the ContactGroup object to be deleted.
                </p></description>
            </descriptive>
            <Type name="ContactGroupId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match
any contact in the address book.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if the group could not be removed
to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getGroups" id="::Contact::AddressBook::getGroups">
        <webidl>    <ref>ContactGroup</ref>[] getGroups() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets an array of all ContactGroup objects from the specified address book.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.read
            </privilege>
            <Code>  var addressbook;

  // Get default address book.
  var addressbooks = tizen.contact.getAddressBooks();
  addressbook = addressbooks[0];

  try {
    groups = addressbook.getGroups();
    console.log('Number of groups is ' + groups.length);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 ContactGroup[] The array of ContactGroup object from this address book.
              </p></description>
          </descriptive>
          <Type name="ContactGroup"/>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match
any contact in the address book.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if the group could not be retrieved due
to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Person" id="::Contact::Person">
      <webidl>  [NoInterfaceObject] interface Person {
    readonly attribute <ref>PersonId</ref> id;

    readonly attribute DOMString displayName;

    readonly attribute long contactCount;

    readonly attribute boolean hasPhoneNumber;

    readonly attribute boolean hasEmail;

    attribute boolean isFavorite;

    attribute DOMString? photoURI;

    attribute DOMString? ringtoneURI;

    attribute <ref>ContactId</ref> displayContactId;

    void link(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);

    <ref>Person</ref> unlink(<ref>ContactId</ref> contactId) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The person object.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Contact::Person::id">
        <webidl>    readonly attribute <ref>PersonId</ref> id;</webidl>
        <descriptive>
            <brief>
 The identifier of the person.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="PersonId"/>
      </Attribute>
      <Attribute readonly="readonly" name="displayName" id="::Contact::Person::displayName">
        <webidl>    readonly attribute DOMString displayName;</webidl>
        <descriptive>
            <brief>
 An attribute to identify a person by storing the display name in a string.
It is selected from the contacts' display names.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="contactCount" id="::Contact::Person::contactCount">
        <webidl>    readonly attribute long contactCount;</webidl>
        <descriptive>
            <brief>
 An attribute to count the number of the contacts that belong to a person.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="hasPhoneNumber" id="::Contact::Person::hasPhoneNumber">
        <webidl>    readonly attribute boolean hasPhoneNumber;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate if a person has a phone number.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="hasEmail" id="::Contact::Person::hasEmail">
        <webidl>    readonly attribute boolean hasEmail;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate if the person has an email addresses.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="isFavorite" id="::Contact::Person::isFavorite">
        <webidl>    attribute boolean isFavorite;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate whether the contact is a favorite or not.
            </brief>
           <description>
            <p>
Indicates if the person was marked as <em>Favorite</em> or not.
            </p>
            <p>
By default, this attribute is set to <var>false</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="photoURI" id="::Contact::Person::photoURI">
        <webidl>    attribute DOMString? photoURI;</webidl>
        <descriptive>
            <brief>
 The URI of a picture of a person.
            </brief>
           <description>
            <p>
This attribute is used to store a URI that points to an image that can represent the
person object. This attribute only contains a local file URI.
Person's photoURI is bounded to linked contacts' valid photoURI.
It means that if photoURI is existed, it can't become <var>null</var> and except linked contact's photoURI, any file can't be set as photoURI
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="ringtoneURI" id="::Contact::Person::ringtoneURI">
        <webidl>    attribute DOMString? ringtoneURI;</webidl>
        <descriptive>
            <brief>
 An attribute to specify and store the URI of a custom ringtone for a contact.
            </brief>
           <description>
            <p>
By default, this attribute is initialized to <var>null</var>.
This attribute only contains a local file URI.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="displayContactId" id="::Contact::Person::displayContactId">
        <webidl>    attribute <ref>ContactId</ref> displayContactId;</webidl>
        <descriptive>
            <brief>
 The ID of a contact that represents information of the person.
            </brief>
           <description>
            <p>
The contact, this value is indicating, is used to show detailed information of the person.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ContactId"/>
      </Attribute>
      <Operation name="link" id="::Contact::Person::link">
        <webidl>    void link(<ref>PersonId</ref> personId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Aggregates another person to this person.
            </brief>
           <description>
            <p>
Person is a meta object which aggregates contacts and to make a person, user should combine related contacts.
For this operation, link method is provided.
If &quot;Person A&quot; is linked to &quot;Person B&quot;, contacts related to &quot;Person A&quot; are aggregated to &quot;Person B&quot;.
After this function returns, the target &quot;Person A&quot; is removed from DB.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  // Define the error callback for all the asynchronous calls
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  function personsFoundCB(persons) {
    // The persons has been successfully found
    try {
      persons[0].link(persons[1].id);
      console.log('Second person was merged to the first person.');
    } catch (err) {
      console.log( 'The following error occurred while updating: ' +  err.name);
    }
  }

  try {
    tizen.contact.find(personsFoundCB, errorCB);
  } catch (err) {
    console.log( 'The following error occurred while adding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="personId">
            <descriptive>
                <description><p>
 The ID of person to be merged.
                </p></description>
            </descriptive>
            <Type name="PersonId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs while trying to insert the contact.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unlink" id="::Contact::Person::unlink">
        <webidl>    <ref>Person</ref> unlink(<ref>ContactId</ref> contactId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Separates a contact from this person.
            </brief>
           <description>
            <p>
Person is aggregated contacts and if a user wants to detach one contact from person, unlink method is provided.
Unlink is basically detaching a contact object from linked contacts so only a contact Id linked to the person can be used as the input parameter.
This function returns a newly created Person object that indicates the separated contact.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/contact.write
            </privilege>
            <Code>  var myPersonId = '1'; //ID of modified

  var addressbook; // Default addressbook
  var person;    // Existing person obtained from addressbook
  var newPerson; // New person, which will be created during unlink

  // Define the error callback.
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  // Define the contact search success callback.
  function contactsFoundCB(contacts) {
    if (contacts.length > 1) {
      try {
        // unlink first contact
        newPerson = person.unlink(contacts[0].id);
      } catch (err) {
        console.log( 'The following error occurred while unlink: ' +  err.name);
      }
    } else {
        console.log( 'Not enough contacts ');
    }
  }

  try {
    // Get person
    person = tizen.contact.get(myPersonId);

    // Get default address book
    addressbook = tizen.contact.getDefaultAddressBook();

    // Find all contacts in the default address book that personId
    // is exactly myPersonId
    var filter = new tizen.AttributeFilter('personId', 'EXACTLY', myPersonId);

    addressbook.find(contactsFoundCB, errorCB, filter);
  } catch (err) {
    console.log( 'The following error occurred while processing: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type name="Person"/>
        <ArgumentList>
          <Argument name="contactId">
            <descriptive>
                <description><p>
 The ID of contact to unlink.
                </p></description>
            </descriptive>
            <Type name="ContactId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameter
contains invalid values.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs while trying to insert the contact.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Dictionary name="ContactInit" id="::Contact::ContactInit">
      <webidl>  dictionary ContactInit {
    <ref>ContactName</ref> name;
    <ref>ContactAddress</ref>[] addresses;
    DOMString photoURI;
    <ref>ContactPhoneNumber</ref>[] phoneNumbers;
    <ref>ContactEmailAddress</ref>[] emails;
    Date birthday;
    <ref>ContactAnniversary</ref>[] anniversaries;
    <ref>ContactOrganization</ref>[] organizations;
    DOMString[] notes;
    <ref>ContactWebSite</ref>[] urls;
    DOMString ringtoneURI;
    <ref>ContactGroupId</ref>[] groupIds;
  };</webidl>
      <descriptive>
          <brief>
 Provides a dictionary for specifying contact attributes upon contact creation.
          </brief>
         <description>
          <p>
This dictionary is used to input parameters when contacts are created.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="name" id="::Contact::ContactInit::name">
        <webidl>    <ref>ContactName</ref> name;</webidl>
        <Type name="ContactName"/>
      </DictionaryMember>
      <DictionaryMember name="addresses" id="::Contact::ContactInit::addresses">
        <webidl>    <ref>ContactAddress</ref>[] addresses;</webidl>
        <Type type="array">
          <Type name="ContactAddress"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="photoURI" id="::Contact::ContactInit::photoURI">
        <webidl>    DOMString photoURI;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="phoneNumbers" id="::Contact::ContactInit::phoneNumbers">
        <webidl>    <ref>ContactPhoneNumber</ref>[] phoneNumbers;</webidl>
        <Type type="array">
          <Type name="ContactPhoneNumber"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="emails" id="::Contact::ContactInit::emails">
        <webidl>    <ref>ContactEmailAddress</ref>[] emails;</webidl>
        <Type type="array">
          <Type name="ContactEmailAddress"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="birthday" id="::Contact::ContactInit::birthday">
        <webidl>    Date birthday;</webidl>
        <Type type="Date"/>
      </DictionaryMember>
      <DictionaryMember name="anniversaries" id="::Contact::ContactInit::anniversaries">
        <webidl>    <ref>ContactAnniversary</ref>[] anniversaries;</webidl>
        <Type type="array">
          <Type name="ContactAnniversary"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="organizations" id="::Contact::ContactInit::organizations">
        <webidl>    <ref>ContactOrganization</ref>[] organizations;</webidl>
        <Type type="array">
          <Type name="ContactOrganization"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="notes" id="::Contact::ContactInit::notes">
        <webidl>    DOMString[] notes;</webidl>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="urls" id="::Contact::ContactInit::urls">
        <webidl>    <ref>ContactWebSite</ref>[] urls;</webidl>
        <Type type="array">
          <Type name="ContactWebSite"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="ringtoneURI" id="::Contact::ContactInit::ringtoneURI">
        <webidl>    DOMString ringtoneURI;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="groupIds" id="::Contact::ContactInit::groupIds">
        <webidl>    <ref>ContactGroupId</ref>[] groupIds;</webidl>
        <Type type="array">
          <Type name="ContactGroupId"/>
        </Type>
      </DictionaryMember>
    </Dictionary>
    <Interface name="Contact" id="::Contact::Contact">
      <webidl>  [Constructor(optional <ref>ContactInit</ref>? ContactInitDict),
   Constructor(DOMString stringRepresentation)]
  interface Contact {
    readonly attribute <ref>ContactId</ref>? id;

    readonly attribute <ref>PersonId</ref>? personId;

    readonly attribute <ref>AddressBookId</ref>? addressBookId;

    readonly attribute Date? lastUpdated;

    readonly attribute boolean isFavorite;

    attribute <ref>ContactName</ref>? name setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactAddress</ref>[] addresses setraises(<ref>WebAPIException</ref>);

    attribute DOMString? photoURI setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactPhoneNumber</ref>[] phoneNumbers setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactEmailAddress</ref>[] emails setraises(<ref>WebAPIException</ref>);

    attribute Date? birthday setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactAnniversary</ref>[] anniversaries setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactOrganization</ref>[] organizations setraises(<ref>WebAPIException</ref>);

    attribute DOMString[] notes setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactWebSite</ref>[] urls setraises(<ref>WebAPIException</ref>);

    attribute DOMString? ringtoneURI setraises(<ref>WebAPIException</ref>);

    attribute <ref>ContactGroupId</ref>[] groupIds setraises(<ref>WebAPIException</ref>);

    DOMString convertToString(optional <ref>ContactTextFormat</ref>? format) raises(<ref>WebAPIException</ref>);

    <ref>Contact</ref> clone() raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface is used to create a <em>Contact </em>object.
          </brief>
          <version>
 1.0
          </version>
          <Code>  // Get the default address book
  var addressbook = tizen.contact.getDefaultAddressBook();

  var contact = null;

  try {
    contact = new tizen.Contact(
                      &quot;BEGIN:VCARD\n&quot;+
                      &quot;VERSION:3.0\n&quot;+
                      &quot;N:Gump;Forrest\n&quot;+
                      &quot;FN:Forrest Gump\n&quot;+
                      &quot;ORG:Bubba Gump Shrimp Co.\n&quot;+
                      &quot;TITLE:Shrimp Man\n&quot;+
                      &quot;TEL;WORK:(111) 555-1212\n&quot;+
                      &quot;TEL;HOME:(404) 555-1212\n&quot;+
                      &quot;EMAIL;WORK;PREF:forrestgump@example.com\n&quot;+
                      &quot;END:VCARD&quot;);
  } catch (err) {
    console.log( 'The following error occurred while converting: ' +  err.name);
  }

  try {
    if (contact) {
      addressbook.add(contact);
      console.log('Contact was added with ID ' + contact.id);
    }
  } catch (err) {
    console.log( 'The following error occurred while adding: ' +  err.name);
  }
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(optional <ref>ContactInit</ref>? ContactInitDict)</webidl>
          <ArgumentList>
            <Argument optional="optional" name="ContactInitDict">
              <Type name="ContactInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>   Constructor(DOMString stringRepresentation)</webidl>
          <ArgumentList>
            <Argument name="stringRepresentation">
              <Type type="DOMString"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Contact::Contact::id">
        <webidl>    readonly attribute <ref>ContactId</ref>? id;</webidl>
        <descriptive>
            <brief>
 An attribute to identify a raw contact.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="ContactId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="personId" id="::Contact::Contact::personId">
        <webidl>    readonly attribute <ref>PersonId</ref>? personId;</webidl>
        <descriptive>
            <brief>
 The identifier of the person corresponding to the raw contact.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="PersonId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="addressBookId" id="::Contact::Contact::addressBookId">
        <webidl>    readonly attribute <ref>AddressBookId</ref>? addressBookId;</webidl>
        <descriptive>
            <brief>
 The identifier of the address book that corresponds to the raw contact.
By default, this attribute is set to <var>null</var>.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="AddressBookId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="lastUpdated" id="::Contact::Contact::lastUpdated">
        <webidl>    readonly attribute Date? lastUpdated;</webidl>
        <descriptive>
            <brief>
 The timestamp for the last update of a contact.
            </brief>
           <description>
            <p>
Specifies revision information about the contact.
            </p>
            <p>
By default, this attribute is set to <var>null</var>. Initially, once a contact is added to an address book, this value is the same as the creation date.
For more details, see RFC 2426, Section 3.6.4.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="isFavorite" id="::Contact::Contact::isFavorite">
        <webidl>    readonly attribute boolean isFavorite;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate whether a contact is favorite or not.
            </brief>
           <description>
            <p>
This value is associated with the <em>isFavorite</em> attribute of Person that this contact indicates.
            </p>
            <p>
By default, this attribute is set to <var>false</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   if (contact.isFavorite) {
     // ...
   }
 </Code>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="name" id="::Contact::Contact::name">
        <webidl>    attribute <ref>ContactName</ref>? name setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the name of a contact.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="ContactName" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="addresses" id="::Contact::Contact::addresses">
        <webidl>    attribute <ref>ContactAddress</ref>[] addresses setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The contact addresses.
            </brief>
           <description>
            <p>
By default, this attribute is set to an empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var contactInit = {};
 var contactAddr = new tizen.ContactAddres({streetAddress:'Gran Via, 32',
                                            postalCode:'50013',
                                                  city:'Zaragoza',
                                                  country:'ES'});
 contactInit.addresses = [contactAddr];
 </Code>
        </descriptive>
        <Type type="array">
          <Type name="ContactAddress"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="photoURI" id="::Contact::Contact::photoURI">
        <webidl>    attribute DOMString? photoURI setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The URI to the picture of the contact.
            </brief>
           <description>
            <p>
This attribute is used to store a URI that points to an image that can represent the
contact object. This attribute only contains a local file URI.
See RFC 2426, Section 3.1.4.
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  var contactInit = {};
  contactInit.photoURI = 'file:///opt/media/Downloads/mypicture.jpg';
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="phoneNumbers" id="::Contact::Contact::phoneNumbers">
        <webidl>    attribute <ref>ContactPhoneNumber</ref>[] phoneNumbers setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The telephone numbers of the contact.
            </brief>
           <description>
            <p>
By default, this attribute is set to empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   var contactInit = {};
   var phoneNumber = new tizen.ContactPhoneNumber('123456789');
   contactInit.phoneNumbers = [phoneNumber];
 </Code>
        </descriptive>
        <Type type="array">
          <Type name="ContactPhoneNumber"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="emails" id="::Contact::Contact::emails">
        <webidl>    attribute <ref>ContactEmailAddress</ref>[] emails setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The email addresses of the contact.
            </brief>
           <description>
            <p>
By default, this attribute is set to empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   var contactInit = {};
   var email = new tizen.ContactEmailAddress('deedee@ramones.com');
   contactInit.emails = [email];
 </Code>
        </descriptive>
        <Type type="array">
          <Type name="ContactEmailAddress"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="birthday" id="::Contact::Contact::birthday">
        <webidl>    attribute Date? birthday setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The birthday of the contact.
            </brief>
           <description>
            <p>
Defines specify the birthday of the contact (see RFC 2426 -
Section 3.1.5).
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   var contactInit = {};
   contactInit.birthday = new Date(1996, 4, 15);
 </Code>
        </descriptive>
        <Type type="Date" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="anniversaries" id="::Contact::Contact::anniversaries">
        <webidl>    attribute <ref>ContactAnniversary</ref>[] anniversaries setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The list of anniversaries for the contact.
            </brief>
           <description>
            <p>
Defines specify arbitrary anniversaries for the contact (in addition to the birthday).
            </p>
            <p>
By default, this attribute is set to empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   var contactInit = {};
   var marriage_anniv = new tizen.ContactAnniversary(new Date(1976, 11, 2), 'Marriage');
   contactInit.anniversaries = [marriage_anniv];
 </Code>
        </descriptive>
        <Type type="array">
          <Type name="ContactAnniversary"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="organizations" id="::Contact::Contact::organizations">
        <webidl>    attribute <ref>ContactOrganization</ref>[] organizations setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The organizations the contact belongs to.
            </brief>
           <description>
            <p>
Contains information related to the contact's company or organization.
            </p>
            <p>
For more details, see RFC 2426, Section 3.5.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="ContactOrganization"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="notes" id="::Contact::Contact::notes">
        <webidl>    attribute DOMString[] notes setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The notes associated to the contact.
            </brief>
           <description>
            <p>
To specify supplemental information or a comment related to the contact.
            </p>
            <p>
For more details, see RFC 2426, Section 3.6.2.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="urls" id="::Contact::Contact::urls">
        <webidl>    attribute <ref>ContactWebSite</ref>[] urls setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The URLs associated to the contact.
            </brief>
           <description>
            <p>
By default, this attribute is initialized to an empty array.
            </p>
            <p>
In case multiple URLs are available, the first one is the default one.
For more details, see RFC 2426, Section 3.6.8.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="ContactWebSite"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="ringtoneURI" id="::Contact::Contact::ringtoneURI">
        <webidl>    attribute DOMString? ringtoneURI setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The URI to the custom ringtone for the contact.
            </brief>
           <description>
            <p>
To specify a custom ringtone for the contact.
            </p>
            <p>
By default, this attribute is initialized to <var>null</var>.
This attribute only contains a local file URI scheme;
For more details, see RFC 2426, Section 3.6.6.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="groupIds" id="::Contact::Contact::groupIds">
        <webidl>    attribute <ref>ContactGroupId</ref>[] groupIds setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The groups the contact belongs to.
            </brief>
           <description>
            <p>
To associate groups to the contact.
            </p>
            <p>
By default, this attribute is initialized to an empty array.
            </p>
            <p>
In a case where multiple categories are available, the first one is the default one.
See RFC 2426, Section 3.6.1.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="ContactGroupId"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Operation name="convertToString" id="::Contact::Contact::convertToString">
        <webidl>    DOMString convertToString(optional <ref>ContactTextFormat</ref>? format) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Converts the Contact item to a string format.
            </brief>
           <description>
            <p>
A textual representation for the contact will be generated and returned synchronously.
The export format is set via the format parameter.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  var addressbook;

  // Define the error callback.
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  // Define the contact find success callback.
  function contactsFoundCB(contacts) {
    try {
      // Convert the first contact to vCard 3.0 format
      var vcard = contacts[0].convertToString(&quot;VCARD_30&quot;);
      console.log('textual representation of the contact is: ' + vcard);
    } catch (err) {
      console.log( 'The following error occurred while converting: ' +  err.name);
    }
  }

  // Get the default address book
  addressbook = tizen.contact.getDefaultAddressBook();

  // Find all contact in the address book whose first name contains the string 'Chris'.
  var filter = new tizen.AttributeFilter('firstName', 'CONTAINS', 'Chris');
  try {
    addressbook.find(contactsFoundCB, errorCB, filter);
  } catch (err) {
    console.log( 'The following error occurred while finding: ' +  err.name);
  }
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The string representation of the Contact item.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="format">
            <descriptive>
                <description><p>
 Format to use for export. If this value is <var>null</var> or empty, it converts to platform default format.
                </p></description>
            </descriptive>
            <Type name="ContactTextFormat" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the functionality
is not allowed.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="clone" id="::Contact::Contact::clone">
        <webidl>    <ref>Contact</ref> clone() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
           <description>
            <p>
Creates a clone of the Contact object, detached from any address book.
            </p>
            <p>
The Contact object returned by the <var>clone()</var> method will have its identifier
set to <var>null</var> and will be detached from any address book.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>  // Get default address book.
  var addressbook = tizen.contact.getDefaultAddressBook();

  var bob = new tizen.Contact();
  bob.name = new tizen.ContactName({firstName:'Bob',
                                    lastName:'Smith'});
  addressbook.add(bob);
  var alice = bob.clone();
  contact.name.firstName = &quot;Alice&quot;; // Bob's wife
  addressbook.add(alice);
 </Code>
        </descriptive>
        <Type name="Contact">
          <descriptive>
              <description><p>
 Contact A new clone of the Contact object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the functionality
is not allowed.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature
is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="ContactRef" id="::Contact::ContactRef">
      <webidl>  [Constructor(<ref>AddressBookId</ref> addressBookId, <ref>ContactId</ref> contactId)]
  interface ContactRef {
    attribute <ref>AddressBookId</ref> addressBookId;

    attribute <ref>ContactId</ref> contactId;
  };</webidl>
      <descriptive>
          <brief>
 The fully-defined contact reference.
          </brief>
         <description>
          <p>
It contains both the identifier of the address book which the contact is in, and
the contact identifier within this address book.
          </p>
          <p>
This interface is used by other APIs to uniquely and globally identify contacts.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(<ref>AddressBookId</ref> addressBookId, <ref>ContactId</ref> contactId)</webidl>
          <ArgumentList>
            <Argument name="addressBookId">
              <Type name="AddressBookId"/>
            </Argument>
            <Argument name="contactId">
              <Type name="ContactId"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="addressBookId" id="::Contact::ContactRef::addressBookId">
        <webidl>    attribute <ref>AddressBookId</ref> addressBookId;</webidl>
        <descriptive>
            <brief>
 The address book identifier.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="AddressBookId"/>
      </Attribute>
      <Attribute name="contactId" id="::Contact::ContactRef::contactId">
        <webidl>    attribute <ref>ContactId</ref> contactId;</webidl>
        <descriptive>
            <brief>
 The contact identifier inside the address book.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="ContactId"/>
      </Attribute>
    </Interface>
    <Dictionary name="ContactNameInit" id="::Contact::ContactNameInit">
      <webidl>  dictionary ContactNameInit {
    DOMString prefix;
    DOMString suffix;
    DOMString firstName;
    DOMString middleName;
    DOMString lastName;
    DOMString[] nicknames;
    DOMString phoneticFirstName;
    DOMString phoneticLastName;
  };</webidl>
      <descriptive>
          <brief>
 The properties of a ContactName, to pass to the ContactName constructor.
          </brief>
         <description>
          <p>
See ContactName interface for more information about the members.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="prefix" id="::Contact::ContactNameInit::prefix">
        <webidl>    DOMString prefix;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="suffix" id="::Contact::ContactNameInit::suffix">
        <webidl>    DOMString suffix;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="firstName" id="::Contact::ContactNameInit::firstName">
        <webidl>    DOMString firstName;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="middleName" id="::Contact::ContactNameInit::middleName">
        <webidl>    DOMString middleName;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="lastName" id="::Contact::ContactNameInit::lastName">
        <webidl>    DOMString lastName;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="nicknames" id="::Contact::ContactNameInit::nicknames">
        <webidl>    DOMString[] nicknames;</webidl>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="phoneticFirstName" id="::Contact::ContactNameInit::phoneticFirstName">
        <webidl>    DOMString phoneticFirstName;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="phoneticLastName" id="::Contact::ContactNameInit::phoneticLastName">
        <webidl>    DOMString phoneticLastName;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
    </Dictionary>
    <Interface name="ContactName" id="::Contact::ContactName">
      <webidl>  [Constructor(optional <ref>ContactNameInit</ref>? nameInitDict)]
  interface ContactName {
    attribute DOMString? prefix;

    attribute DOMString? suffix;

    attribute DOMString? firstName;

    attribute DOMString? middleName;

    attribute DOMString? lastName;

    attribute DOMString[] nicknames;

    attribute DOMString? phoneticFirstName;

    attribute DOMString? phoneticLastName;

    readonly attribute DOMString? displayName;
  };</webidl>
      <descriptive>
          <brief>
 This interface contains all information related to a contact name.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(optional <ref>ContactNameInit</ref>? nameInitDict)</webidl>
          <ArgumentList>
            <Argument optional="optional" name="nameInitDict">
              <Type name="ContactNameInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="prefix" id="::Contact::ContactName::prefix">
        <webidl>    attribute DOMString? prefix;</webidl>
        <descriptive>
            <brief>
 The name prefix of a contact.
            </brief>
           <description>
            <p>
By default, this attribute is initialized to
<var>null</var>. See also RFC 2426, Section 3.1.1.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   contact.name.prefix = &quot;Dr.&quot;;
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="suffix" id="::Contact::ContactName::suffix">
        <webidl>    attribute DOMString? suffix;</webidl>
        <descriptive>
            <brief>
 The name suffix of a contact.
            </brief>
           <description>
            <p>
By default, this attribute is initialized to
<var>null</var>. See also RFC 2426, Section 3.1.1.
            </p>
           </description>
            <version>
 2.0
            </version>
            <Code>   contact.name.suffix = &quot;Jr.&quot;;
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="firstName" id="::Contact::ContactName::firstName">
        <webidl>    attribute DOMString? firstName;</webidl>
        <descriptive>
            <brief>
 The first (given) name of a contact.
            </brief>
           <description>
            <p>
By default, this attribute is initialized to
<var>null</var>. See also RFC 2426, Section 3.1.1.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   contact.name.firstName = 'Douglas';
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="middleName" id="::Contact::ContactName::middleName">
        <webidl>    attribute DOMString? middleName;</webidl>
        <descriptive>
            <brief>
 The middle name of a contact.
            </brief>
           <description>
            <p>
By default, this attribute is initialized to
<var>null</var>. See also RFC 2426, Section 3.1.1.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   contact.name.middleName = 'Glenn';
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="lastName" id="::Contact::ContactName::lastName">
        <webidl>    attribute DOMString? lastName;</webidl>
        <descriptive>
            <brief>
 The last (family) name of a contact.
            </brief>
           <description>
            <p>
By default, this attribute is initialized to
<var>null</var>. See also RFC 2426, Section 3.1.1.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   contact.name.lastName = 'Colvin';
 </Code>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="nicknames" id="::Contact::ContactName::nicknames">
        <webidl>    attribute DOMString[] nicknames;</webidl>
        <descriptive>
            <brief>
 The nicknames of a contact.
            </brief>
           <description>
            <p>
The nickname is a name used instead of, or in addition to, the given name of a contact,
place, or thing. It can also be used to specify a familiar form of a proper name.
            </p>
            <p>
By default, this attribute is initialized to an empty array.
            </p>
            <p>
In case multiple nicknames are available the first one is the default.
See RFC 2426, Section 3.1.3.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code>   contact.name.nickNames = ['Dee Dee'];
 </Code>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute name="phoneticFirstName" id="::Contact::ContactName::phoneticFirstName">
        <webidl>    attribute DOMString? phoneticFirstName;</webidl>
        <descriptive>
            <brief>
 The phonetic first name of a contact.
            </brief>
           <description>
            <p>
Describes how the first name should be
pronounced. This is very important in
some languages, such as Japanese, because the
same 'Kanji' may have several pronunciations.
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="phoneticLastName" id="::Contact::ContactName::phoneticLastName">
        <webidl>    attribute DOMString? phoneticLastName;</webidl>
        <descriptive>
            <brief>
 The phonetic last name of a contact.
            </brief>
           <description>
            <p>
Describes how the last name should be
pronounced. This is very important in
some languages, such as Japanese, because the
same 'Kanji' may have several pronunciations.
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="displayName" id="::Contact::ContactName::displayName">
        <webidl>    readonly attribute DOMString? displayName;</webidl>
        <descriptive>
            <brief>
 The display name of a contact.
            </brief>
           <description>
            <p>
The string which can be displayed to identify the contact. It is composed of the first
and last names if available, otherwise, it will fall back to the most adequate
field available to identify the contact (such as nickname).
            </p>
            <p>
By default, this attribute is set to <var>null</var>. Initially, once a contact is added to an address book, this value is composed.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Dictionary name="ContactOrganizationInit" id="::Contact::ContactOrganizationInit">
      <webidl>  dictionary ContactOrganizationInit {
    DOMString name;
    DOMString department;
    DOMString title;
    DOMString role;
    DOMString logoURI;
  };</webidl>
      <descriptive>
          <brief>
 The properties of a ContactOrganization, to pass to the ContactOrganization constructor.
          </brief>
         <description>
          <p>
See ContactOrganization interface for information about members.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="name" id="::Contact::ContactOrganizationInit::name">
        <webidl>    DOMString name;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="department" id="::Contact::ContactOrganizationInit::department">
        <webidl>    DOMString department;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="title" id="::Contact::ContactOrganizationInit::title">
        <webidl>    DOMString title;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="role" id="::Contact::ContactOrganizationInit::role">
        <webidl>    DOMString role;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="logoURI" id="::Contact::ContactOrganizationInit::logoURI">
        <webidl>    DOMString logoURI;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
    </Dictionary>
    <Interface name="ContactOrganization" id="::Contact::ContactOrganization">
      <webidl>  [Constructor(optional <ref>ContactOrganizationInit</ref>? orgInitDict)]
  interface ContactOrganization {
    attribute DOMString? name;

    attribute DOMString? department;

    attribute DOMString? title;

    attribute DOMString? role;

    attribute DOMString? logoURI;
  };</webidl>
      <descriptive>
          <brief>
 This interface contains the information about the organization or
company that a contact belongs to.
          </brief>
         <description>
          <p>
By default, each of the attributes of this interface are <var>null</var>.
          </p>
          <p>
For more details, see RFC 2426, Section 3.5.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> var organization = new tizen.ContactOrganization({name: &quot;Intel&quot;, role: &quot;SW Engineer&quot;});
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(optional <ref>ContactOrganizationInit</ref>? orgInitDict)</webidl>
          <ArgumentList>
            <Argument optional="optional" name="orgInitDict">
              <Type name="ContactOrganizationInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="name" id="::Contact::ContactOrganization::name">
        <webidl>    attribute DOMString? name;</webidl>
        <descriptive>
            <brief>
 The name of an organization.
            </brief>
           <description>
            <p>
For more details, see RFC 2426, Section 3.5.5.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="department" id="::Contact::ContactOrganization::department">
        <webidl>    attribute DOMString? department;</webidl>
        <descriptive>
            <brief>
 The organizational unit name.
            </brief>
           <description>
            <p>
For more details, see RFC 2426, Section 3.5.5.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="title" id="::Contact::ContactOrganization::title">
        <webidl>    attribute DOMString? title;</webidl>
        <descriptive>
            <brief>
 The job title.
            </brief>
           <description>
            <p>
To specify the job title, functional position or function (such as 'Director,
Research and Development').
            </p>
            <p>
For more details, see RFC 2426, Section 3.5.1.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="role" id="::Contact::ContactOrganization::role">
        <webidl>    attribute DOMString? role;</webidl>
        <descriptive>
            <brief>
 An attribute to store the role, occupation, or business category
(such as 'Programmer').
            </brief>
           <description>
            <p>
For more details, see RFC 2426, Section 3.5.2.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="logoURI" id="::Contact::ContactOrganization::logoURI">
        <webidl>    attribute DOMString? logoURI;</webidl>
        <descriptive>
            <brief>
 The URI to the logo of a company.
            </brief>
           <description>
            <p>
To specify a graphic image of a logo associated with an organization.
This attribute only contains file URI Scheme;
remote pictures could be loaded to local with Download API.
For more details, see RFC 2426, Section 3.5.3.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="ContactWebSite" id="::Contact::ContactWebSite">
      <webidl>  [Constructor(DOMString url, optional DOMString type)]
  interface ContactWebSite
  {
    attribute DOMString url;

    attribute DOMString type;
  };</webidl>
      <descriptive>
          <brief>
 The ContactWebSite object that contains the URL and the type of web site.
          </brief>
         <description>
          <p>
For more details, see RFC 2426, Section 3.6.8.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code>  var contactInit = {}
  var blog = new tizen.ContactWebSite('http://www.domain.com', 'BLOG');
  contactInit.urls = [blog];
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString url, optional DOMString type)</webidl>
          <ArgumentList>
            <Argument name="url">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="type">
              <Type type="DOMString"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="url" id="::Contact::ContactWebSite::url">
        <webidl>    attribute DOMString url;</webidl>
        <descriptive>
            <brief>
 The URL for the contact's web site.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="type" id="::Contact::ContactWebSite::type">
        <webidl>    attribute DOMString type;</webidl>
        <descriptive>
            <brief>
 The type of web site.
            </brief>
           <description>
            <p>
At least the following values must be supported:
            </p>
            <ul>
              <li>
HOMEPAGE - Indicates a home page.              </li>
              <li>
BLOG - Indicates a blog.              </li>
            </ul>
            <p>
By default, this attribute is set to HOMEPAGE.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="ContactAnniversary" id="::Contact::ContactAnniversary">
      <webidl>  [Constructor(Date date, optional DOMString? label)]
  interface ContactAnniversary
  {
    attribute Date date;

    attribute DOMString? label;
  };</webidl>
      <descriptive>
          <brief>
 This interface implements the <em>ContactAnniversary </em>object that contains the date and description of an anniversary.
          </brief>
          <version>
 1.0
          </version>
          <Code>  var contactInit = {}
  var marriage_anniv = new tizen.ContactAnniversary(new Date(1976, 11, 2), 'Marriage');
  contactInit.anniversaries = [marriage_anniv];
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(Date date, optional DOMString? label)</webidl>
          <ArgumentList>
            <Argument name="date">
              <Type type="Date"/>
            </Argument>
            <Argument optional="optional" name="label">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="date" id="::Contact::ContactAnniversary::date">
        <webidl>    attribute Date date;</webidl>
        <descriptive>
            <brief>
 The date of an anniversary.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
      <Attribute name="label" id="::Contact::ContactAnniversary::label">
        <webidl>    attribute DOMString? label;</webidl>
        <descriptive>
            <brief>
 The text describing an anniversary.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Dictionary name="ContactAddressInit" id="::Contact::ContactAddressInit">
      <webidl>  dictionary ContactAddressInit
  {
    DOMString country;
    DOMString region;
    DOMString city;
    DOMString streetAddress;
    DOMString additionalInformation;
    DOMString postalCode;
    boolean isDefault;
    DOMString[] types;
  };</webidl>
      <descriptive>
          <brief>
 The properties of a ContactAddress to pass to the ContactAddress constructor.
          </brief>
         <description>
          <p>
See ContactAddress interface for more information about the members.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="country" id="::Contact::ContactAddressInit::country">
        <webidl>    DOMString country;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="region" id="::Contact::ContactAddressInit::region">
        <webidl>    DOMString region;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="city" id="::Contact::ContactAddressInit::city">
        <webidl>    DOMString city;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="streetAddress" id="::Contact::ContactAddressInit::streetAddress">
        <webidl>    DOMString streetAddress;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="additionalInformation" id="::Contact::ContactAddressInit::additionalInformation">
        <webidl>    DOMString additionalInformation;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="postalCode" id="::Contact::ContactAddressInit::postalCode">
        <webidl>    DOMString postalCode;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="isDefault" id="::Contact::ContactAddressInit::isDefault">
        <webidl>    boolean isDefault;</webidl>
        <Type type="boolean"/>
      </DictionaryMember>
      <DictionaryMember name="types" id="::Contact::ContactAddressInit::types">
        <webidl>    DOMString[] types;</webidl>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
    </Dictionary>
    <Interface name="ContactAddress" id="::Contact::ContactAddress">
      <webidl>  [Constructor(optional <ref>ContactAddressInit</ref>? addressInitDict)]
  interface ContactAddress
  {
    attribute DOMString? country;

    attribute DOMString? region;

    attribute DOMString? city;

    attribute DOMString? streetAddress;

    attribute DOMString? additionalInformation;

    attribute DOMString? postalCode;

    attribute boolean isDefault;

    attribute DOMString[] types;
  };</webidl>
      <descriptive>
          <brief>
 This interface contains a set of attributes that represent a particular point
on the Earth's surface.
          </brief>
         <description>
          <p>
Except isDefault and types attributes, each of the attributes of this interface are set to <var>null</var> by default.
          </p>
          <p>
For more details, see RFC 2426, Section 3.2.1.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code>   var contactInit = {};
   var contactAddress = new tizen.ContactAddress({streetAddress:'Gran Via, 32',
                                                  postalCode:'50013', city:'Zaragoza',
                                                 country:'ES', types:['WORK']});
   contactInit.contactAddress = [contactAddress];
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(optional <ref>ContactAddressInit</ref>? addressInitDict)</webidl>
          <ArgumentList>
            <Argument optional="optional" name="addressInitDict">
              <Type name="ContactAddressInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="country" id="::Contact::ContactAddress::country">
        <webidl>    attribute DOMString? country;</webidl>
        <descriptive>
            <brief>
 The country of the address.
            </brief>
           <description>
            <p>
It is recommended that the country is specified
using the two-letter [ISO 3166-1] code.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="region" id="::Contact::ContactAddress::region">
        <webidl>    attribute DOMString? region;</webidl>
        <descriptive>
            <brief>
 The name of a country subdivision.
            </brief>
           <description>
            <p>
For example, State (United States) or Province (Spain).
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="city" id="::Contact::ContactAddress::city">
        <webidl>    attribute DOMString? city;</webidl>
        <descriptive>
            <brief>
 The name of the locality. For example, the city, county, town, or village.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="streetAddress" id="::Contact::ContactAddress::streetAddress">
        <webidl>    attribute DOMString? streetAddress;</webidl>
        <descriptive>
            <brief>
 The street address, for example, building number and street name/number.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="additionalInformation" id="::Contact::ContactAddress::additionalInformation">
        <webidl>    attribute DOMString? additionalInformation;</webidl>
        <descriptive>
            <brief>
 An attribute to capture any other address details that are required for an accurate address.
For example, floor number, apartment number, suite name, the name of an office occupant, etc.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="postalCode" id="::Contact::ContactAddress::postalCode">
        <webidl>    attribute DOMString? postalCode;</webidl>
        <descriptive>
            <brief>
 The postal code of the location (also known as the zip code in the US).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="isDefault" id="::Contact::ContactAddress::isDefault">
        <webidl>    attribute boolean isDefault;</webidl>
        <descriptive>
            <brief>
 The default state of an address.
            </brief>
           <description>
            <p>
Indicates if the address was marked as <em>default</em> or not for the contact.
The only one among addresses for a person can have default property,
so that this attribute might be changed without explicit modification
according to the policy of platform.
            </p>
            <p>
It deals with the 'pref' TYPE on RFC 2426, Section 3.2.1
            </p>
            <p>
By default, this attribute is set to <var>false</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="types" id="::Contact::ContactAddress::types">
        <webidl>    attribute DOMString[] types;</webidl>
        <descriptive>
            <brief>
 The case insensitive list of address types.
            </brief>
           <description>
            <p>
For more details, see RFC 2426, Section 3.2.1.
            </p>
            <p>
At least the following values must be supported:
            </p>
            <ul>
              <li>
WORK - Indicates a work address              </li>
              <li>
HOME - Indicates a home address              </li>
            </ul>
            <p>
By default, this attribute is set to HOME.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="ContactPhoneNumber" id="::Contact::ContactPhoneNumber">
      <webidl>  [Constructor(DOMString number, optional DOMString[] types, optional boolean isDefault)]
  interface ContactPhoneNumber
  {
    attribute DOMString number;

    attribute boolean isDefault;

    attribute DOMString[] types;
  };</webidl>
      <descriptive>
          <brief>
 The ContactPhoneNumber object that contains the number and the type of phone number.
          </brief>
         <description>
          <p>
This interface provides the phone number and the type of number, for example, work, home, car, etc., or the device subtype, for example, fax, fixed, or mobile.
At searching by phoneNumber, matchflag &quot;CONTAINS&quot; provides a result set which is retrieved from normalized phoneNumber as searching value.
          </p>
          <p>
For more details, see RFC 2426, Section 3.3.1
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code>   var contactInit = {};
   var phoneNumber = new tizen.ContactPhoneNumber('123456789', ['WORK','VOICE'], true);
   contactInit.phoneNumbers = [phoneNumber];
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString number, optional DOMString[] types, optional boolean isDefault)</webidl>
          <ArgumentList>
            <Argument name="number">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="types">
              <Type type="array">
                <Type type="DOMString"/>
              </Type>
            </Argument>
            <Argument optional="optional" name="isDefault">
              <Type type="boolean"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="number" id="::Contact::ContactPhoneNumber::number">
        <webidl>    attribute DOMString number;</webidl>
        <descriptive>
            <brief>
 The full phone number.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="isDefault" id="::Contact::ContactPhoneNumber::isDefault">
        <webidl>    attribute boolean isDefault;</webidl>
        <descriptive>
            <brief>
 The default state of the phone number.
            </brief>
           <description>
            <p>
Indicates if the phone number was marked as <em>default</em> or not for the contact.
The only one among phone numbers for a person can have default property,
so that this attribute might be changed without explicit modification
according to the policy of platform.
            </p>
            <p>
It deals with the 'pref' TYPE on RFC 2426, Section 3.3.1
            </p>
            <p>
By default, this attribute is set to false.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="types" id="::Contact::ContactPhoneNumber::types">
        <webidl>    attribute DOMString[] types;</webidl>
        <descriptive>
            <brief>
 The case insensitive list of phone types, as defined in RFC 2426.
            </brief>
           <description>
            <p>
Specifies the intended use of the phone number.
            </p>
            <p>
At least the following values must be supported:
            </p>
            <ul>
              <li>
<var>WORK</var> - Indicates a work number              </li>
              <li>
<var>HOME</var> - Indicates a home number              </li>
              <li>
<var>VOICE</var> - Indicates a voice number (Default)              </li>
              <li>
<var>FAX</var> - Indicates a facsimile number              </li>
              <li>
<var>MSG</var> - Indicates a messaging service on the number              </li>
              <li>
<var>CELL</var> - Indicates a cellular number              </li>
              <li>
<var>PAGER</var> - Indicates a pager number              </li>
              <li>
<var>BBS</var> - Indicates a bulletin board service number              </li>
              <li>
<var>MODEM</var> - Indicates a MODEM number              </li>
              <li>
<var>CAR</var> - Indicates a car-phone number              </li>
              <li>
<var>ISDN</var> - Indicates an ISDN number              </li>
              <li>
<var>VIDEO</var> - Indicates a video-phone number              </li>
              <li>
<var>PCS</var> - Personal Communication Standard               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="ContactEmailAddress" id="::Contact::ContactEmailAddress">
      <webidl>  [Constructor(DOMString email, optional DOMString[] types, optional boolean isDefault)]
  interface ContactEmailAddress
  {
    attribute DOMString email;

    attribute boolean isDefault;

    attribute DOMString[] types;
  };</webidl>
      <descriptive>
          <brief>
 The ContactEmailAddress object that contains the email address and the type of email address.
          </brief>
         <description>
          <p>
For more details, see RFC 2426, Section 3.3.2.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code>  var contactInit = {};
  var email = new tizen.ContactEmailAddress('user@domain.com', ['WORK']);
  contactInit.emails = [email];
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString email, optional DOMString[] types, optional boolean isDefault)</webidl>
          <ArgumentList>
            <Argument name="email">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="types">
              <Type type="array">
                <Type type="DOMString"/>
              </Type>
            </Argument>
            <Argument optional="optional" name="isDefault">
              <Type type="boolean"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="email" id="::Contact::ContactEmailAddress::email">
        <webidl>    attribute DOMString email;</webidl>
        <descriptive>
            <brief>
 The full email address.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="isDefault" id="::Contact::ContactEmailAddress::isDefault">
        <webidl>    attribute boolean isDefault;</webidl>
        <descriptive>
            <brief>
 The default state of an email address.
            </brief>
           <description>
            <p>
Indicates if the email address was marked as <em>default</em> or not for the contact.
The only one among email addresses for a person can have default property,
so that this attribute might be changed without explicit modification
according to the policy of platform.
            </p>
            <p>
It deals with the 'pref' TYPE on RFC 2426, Section 3.3.2
            </p>
            <p>
By default, this attribute is set to false.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="types" id="::Contact::ContactEmailAddress::types">
        <webidl>    attribute DOMString[] types;</webidl>
        <descriptive>
            <brief>
 The case insensitive list of email types.
            </brief>
           <description>
            <p>
Specifies the intended use of the email address.
            </p>
            <p>
At least the following values must be supported:
            </p>
            <ul>
              <li>
WORK - Indicates a work email              </li>
              <li>
HOME - Indicates a home email              </li>
              <li>
MOBILE - Indicates a mobile email              </li>
            </ul>
            <p>
By default, this attribute is set to WORK.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="ContactGroup" id="::Contact::ContactGroup">
      <webidl>  [Constructor(DOMString name, optional DOMString? ringtoneURI, optional DOMString? photoURI)]
  interface ContactGroup
  {
    readonly attribute <ref>ContactGroupId</ref>? id;

    readonly attribute <ref>AddressBookId</ref>? addressBookId;

    attribute DOMString name;

    attribute DOMString? ringtoneURI;

    attribute DOMString? photoURI;

    readonly attribute DOMString readOnly;
  };</webidl>
      <descriptive>
          <brief>
 The group object.
          </brief>
          <version>
 2.0
          </version>
          <Code>  var addressbook = null;
  var group = null;

  // Define the error callback for all the asynchronous calls
  function errorCB(err) {
    console.log( 'The following error occurred: ' +  err.name);
  }

  // Define the success callback for retrieving all the
  // Address Books
  function addressBooksCB(addressbooks) {
    addressbook = addressbooks[0];
    try {
      group = new tizen.ContactGroup('Family', 'file://opt/media/Downloads/ring.mp3');
    } catch (err) {
      console.log( 'The following error occurred while converting: ' +  err.name);
    }

    try {
      if (group) {
        addressbook.addGroup(group);
        console.log('Group was added with ID ' + group.id);
      }
    } catch (err) {
      console.log( 'The following error occurred while adding: ' +  err.name);
    }
  }

  tizen.contact.getAddressBooks(addressBooksCB, errorCB);

 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString name, optional DOMString? ringtoneURI, optional DOMString? photoURI)</webidl>
          <ArgumentList>
            <Argument name="name">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="ringtoneURI">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="photoURI">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Contact::ContactGroup::id">
        <webidl>    readonly attribute <ref>ContactGroupId</ref>? id;</webidl>
        <descriptive>
            <brief>
 The identifier of a group.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ContactGroupId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="addressBookId" id="::Contact::ContactGroup::addressBookId">
        <webidl>    readonly attribute <ref>AddressBookId</ref>? addressBookId;</webidl>
        <descriptive>
            <brief>
 The identifier of the address book that the group belongs to.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="AddressBookId" nullable="nullable"/>
      </Attribute>
      <Attribute name="name" id="::Contact::ContactGroup::name">
        <webidl>    attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 The name of a group.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="ringtoneURI" id="::Contact::ContactGroup::ringtoneURI">
        <webidl>    attribute DOMString? ringtoneURI;</webidl>
        <descriptive>
            <brief>
 The URI to the custom ringtone for a group.
            </brief>
           <description>
            <p>
To specify a custom ringtone for a group.
            </p>
            <p>
By default, this attribute is initialized to <var>null</var>.
This attribute only contains a local file URI.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="photoURI" id="::Contact::ContactGroup::photoURI">
        <webidl>    attribute DOMString? photoURI;</webidl>
        <descriptive>
            <brief>
 An attribute to store a URI that points to an image that can represent the<em> Group </em>object. This attribute only contains a local file URI.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="readOnly" id="::Contact::ContactGroup::readOnly">
        <webidl>    readonly attribute DOMString readOnly;</webidl>
        <descriptive>
            <brief>
 The flag indicating if the group can be modified / removed or not.
Some groups cannot be edited if this flag sets to <var>true</var>.
            </brief>
           <description>
            <p>
By default, this attribute is set to false.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="PersonArraySuccessCallback" id="::Contact::PersonArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface PersonArraySuccessCallback {
    void onsuccess(<ref>Person</ref>[] persons);
  };</webidl>
      <descriptive>
          <brief>
 The success callback that is used for retrieving
a list of persons.
          </brief>
         <description>
          <p>
The success callback that takes an array of persons as an input
argument. It is used in the asynchronous operation to
get or save a list of persons.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Contact::PersonArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>Person</ref>[] persons);</webidl>
        <descriptive>
            <brief>
 The method invoked when a list of persons is retrieved successfully.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="persons">
            <descriptive>
                <description><p>
 List of persons.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Person"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ContactArraySuccessCallback" id="::Contact::ContactArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ContactArraySuccessCallback {
    void onsuccess(<ref>Contact</ref>[] contacts);
  };</webidl>
      <descriptive>
          <brief>
 The success callback that is used for saving and retrieving
a list of contacts.
          </brief>
         <description>
          <p>
The success callback that takes an array of contacts as an input
argument. It is used in the asynchronous operation to
get or save a list of contacts.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Contact::ContactArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>Contact</ref>[] contacts);</webidl>
        <descriptive>
            <brief>
 The method invoked when a list of contacts is retrieved successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contacts">
            <descriptive>
                <description><p>
 List of contacts.
The Contacts that were successfully saved must have their identifiers set.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Contact"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="AddressBookArraySuccessCallback" id="::Contact::AddressBookArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface AddressBookArraySuccessCallback {
    void onsuccess(<ref>AddressBook</ref>[] addressbooks);
  };</webidl>
      <descriptive>
          <brief>
 The success callback when retrieving a list of AddressBooks.
          </brief>
         <description>
          <p>
The success callback that takes an array of AddressBooks as an input
argument. It is used in the asynchronous operation to
get address books.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Contact::AddressBookArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>AddressBook</ref>[] addressbooks);</webidl>
        <descriptive>
            <brief>
 The method invoked when a list of address books is retrieved successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="addressbooks">
            <descriptive>
                <description><p>
 The address books to retrieve.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="AddressBook"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="AddressBookChangeCallback" id="::Contact::AddressBookChangeCallback">
      <webidl>  [Callback, NoInterfaceObject] interface AddressBookChangeCallback {
    void oncontactsadded(<ref>Contact</ref>[] contacts);

    void oncontactsupdated(<ref>Contact</ref>[] contacts);

    void oncontactsremoved(<ref>ContactId</ref>[] contactIds);
  };</webidl>
      <descriptive>
          <brief>
 The interface for specifying the methods to be called for address book
change notifications.
          </brief>
         <description>
          <p>
This interface specifies a set of functions that will be invoked every time an address
book change occurs (contact addition/update/deletion).
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="oncontactsadded" id="::Contact::AddressBookChangeCallback::oncontactsadded">
        <webidl>    void oncontactsadded(<ref>Contact</ref>[] contacts);</webidl>
        <descriptive>
            <brief>
 The method invoked when contacts are added to the address book.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contacts">
            <descriptive>
                <description><p>
 A list of contacts to add.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Contact"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="oncontactsupdated" id="::Contact::AddressBookChangeCallback::oncontactsupdated">
        <webidl>    void oncontactsupdated(<ref>Contact</ref>[] contacts);</webidl>
        <descriptive>
            <brief>
 The method invoked when contacts are updated in the address book.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contacts">
            <descriptive>
                <description><p>
 A list of contacts to update.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Contact"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="oncontactsremoved" id="::Contact::AddressBookChangeCallback::oncontactsremoved">
        <webidl>    void oncontactsremoved(<ref>ContactId</ref>[] contactIds);</webidl>
        <descriptive>
            <brief>
 The method invoked when contacts are deleted from the address book.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contactIds">
            <descriptive>
                <description><p>
 A list of identifiers for the contacts to delete.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="ContactId"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="PersonsChangeCallback" id="::Contact::PersonsChangeCallback">
      <webidl>  [Callback, NoInterfaceObject] interface PersonsChangeCallback {
    void onpersonsadded(<ref>Person</ref>[] persons);

    void onpersonsupdated(<ref>Person</ref>[] persons);

    void onpersonsremoved(<ref>PersonId</ref>[] personIds);
  };</webidl>
      <descriptive>
          <brief>
 The interface for specifying the methods to be called for change notifications.
          </brief>
         <description>
          <p>
This interface specifies a set of functions that will be invoked every time person's
list change occurs (person addition/update/deletion).
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onpersonsadded" id="::Contact::PersonsChangeCallback::onpersonsadded">
        <webidl>    void onpersonsadded(<ref>Person</ref>[] persons);</webidl>
        <descriptive>
            <brief>
 The method invoked when persons are added to the person list.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="persons">
            <descriptive>
                <description><p>
 A list of persons to add.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Person"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onpersonsupdated" id="::Contact::PersonsChangeCallback::onpersonsupdated">
        <webidl>    void onpersonsupdated(<ref>Person</ref>[] persons);</webidl>
        <descriptive>
            <brief>
 The method invoked when persons are updated in the person list.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="persons">
            <descriptive>
                <description><p>
 A list of persons to update.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Person"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onpersonsremoved" id="::Contact::PersonsChangeCallback::onpersonsremoved">
        <webidl>    void onpersonsremoved(<ref>PersonId</ref>[] personIds);</webidl>
        <descriptive>
            <brief>
 The method invoked when persons are deleted from the person list.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="personIds">
            <descriptive>
                <description><p>
 A list of identifiers for the persons to delete.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="PersonId"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Content" id="::Content">
    <webidl>module Content {

  enum ContentDirectoryStorageType { &quot;INTERNAL&quot;, &quot;EXTERNAL&quot; };

  enum ContentType { &quot;IMAGE&quot;, &quot;VIDEO&quot;, &quot;AUDIO&quot;, &quot;OTHER&quot; };

  enum AudioContentLyricsType { &quot;SYNCHRONIZED&quot;, &quot;UNSYNCHRONIZED&quot; };

  enum ImageContentOrientation { &quot;NORMAL&quot;, &quot;FLIP_HORIZONTAL&quot;, &quot;ROTATE_180&quot;, &quot;FLIP_VERTICAL&quot;, &quot;TRANSPOSE&quot;, &quot;ROTATE_90&quot;, &quot;TRANSVERSE&quot;, &quot;ROTATE_270&quot; };

  typedef DOMString ContentId;

  typedef DOMString ContentDirectoryId;

  [NoInterfaceObject] interface ContentManagerObject {
    readonly attribute <ref>ContentManager</ref> content;
  };
  <ref>Tizen</ref> implements <ref>ContentManagerObject</ref>;

  [NoInterfaceObject] interface ContentManager {

    void update(<ref>Content</ref> content) raises(<ref>WebAPIException</ref>);

    void updateBatch(<ref>Content</ref>[] contents,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void getDirectories(<ref>ContentDirectoryArraySuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void find(<ref>ContentArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>ContentDirectoryId</ref>? directoryId,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode,
              optional unsigned long? count,
              optional unsigned long? offset) raises(<ref>WebAPIException</ref>);


    void scanFile(DOMString contentURI,
                  optional <ref>ContentScanSuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void setChangeListener(<ref>ContentChangeCallback</ref> changeCallback) raises(<ref>WebAPIException</ref>);

    void unsetChangeListener() raises(<ref>WebAPIException</ref>);

  };

  [Callback=FunctionOnly, NoInterfaceObject] interface ContentArraySuccessCallback {
    void onsuccess(<ref>Content</ref>[] contents);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface ContentDirectoryArraySuccessCallback {
    void onsuccess(<ref>ContentDirectory</ref>[] directories);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface ContentScanSuccessCallback {
    void onsuccess(DOMString contentURI);
  };

  [Callback, NoInterfaceObject] interface ContentChangeCallback {
    void oncontentadded(<ref>Content</ref> content);

    void oncontentupdated(<ref>Content</ref> content);

    void oncontentremoved(<ref>ContentId</ref> id);
  };


  [NoInterfaceObject] interface ContentDirectory {

    readonly attribute <ref>ContentDirectoryId</ref> id;

    readonly attribute DOMString directoryURI;

    readonly attribute DOMString title;

    readonly attribute <ref>ContentDirectoryStorageType</ref> storageType;

    readonly attribute Date? modifiedDate;

   };

  [NoInterfaceObject] interface Content {

    readonly attribute DOMString[] editableAttributes;

    readonly attribute <ref>ContentId</ref> id;

    attribute DOMString name;

    readonly attribute <ref>ContentType</ref> type;

    readonly attribute DOMString mimeType;

    readonly attribute DOMString title;

    readonly attribute DOMString contentURI;

    readonly attribute DOMString[]? thumbnailURIs;

    readonly attribute Date? releaseDate;

    readonly attribute Date? modifiedDate;

    readonly attribute unsigned long size;

    attribute DOMString? description;

    attribute unsigned long rating;
  };

  [NoInterfaceObject] interface VideoContent : <ref>Content</ref> {

    attribute <ref>SimpleCoordinates</ref>? geolocation;

    readonly attribute DOMString? album;

    readonly attribute DOMString[]? artists;

    readonly attribute unsigned long duration;

    readonly attribute unsigned long width;

    readonly attribute unsigned long height;

  };


  [NoInterfaceObject] interface AudioContentLyrics {

    readonly attribute <ref>AudioContentLyricsType</ref> type;

    readonly attribute unsigned long[] timestamps;

    readonly attribute DOMString[] texts;
  };

  [NoInterfaceObject] interface AudioContent : <ref>Content</ref> {

    readonly attribute DOMString? album;

    readonly attribute DOMString[]? genres;

    readonly attribute DOMString[]? artists;

    readonly attribute DOMString[]? composers;

    readonly attribute <ref>AudioContentLyrics</ref>? lyrics;

    readonly attribute DOMString? copyright;

    readonly attribute unsigned long bitrate;

    readonly attribute unsigned short? trackNumber;

    readonly attribute unsigned long duration;

  };

  [NoInterfaceObject] interface ImageContent : <ref>Content</ref> {

    attribute <ref>SimpleCoordinates</ref>? geolocation;

    readonly attribute unsigned long width;

    readonly attribute unsigned long height;

    attribute <ref>ImageContentOrientation</ref> orientation;

  };
};</webidl>
    <descriptive>
        <brief>
 This API provides functionality to discover contents such as images, videos, music, or other.
        </brief>
       <description>
        <p>
It is possible to search for specific contents using filters.
The API also supports setting attributes of specific contents.
        </p>
        <p>
For more information on the Content features, see <a href="../../org.tizen.web.appprogramming/html/guide/content_guide/mediacontent.htm">Content Guide</a>.
        </p>
       </description>
        <version>
 2.0
        </version>
    </descriptive>
    <Enum name="ContentDirectoryStorageType" id="::Content::ContentDirectoryStorageType">
      <webidl>  enum ContentDirectoryStorageType { &quot;INTERNAL&quot;, &quot;EXTERNAL&quot; };</webidl>
      <descriptive>
         <description>
          <p>
Defines whether a content directory is stored on internal or external storage (such as a removable memory card).
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="INTERNAL">
        <webidl> &quot;INTERNAL</webidl>
      </EnumValue>
      <EnumValue stringvalue="EXTERNAL">
        <webidl> &quot;EXTERNAL</webidl>
      </EnumValue>
    </Enum>
    <Enum name="ContentType" id="::Content::ContentType">
      <webidl>  enum ContentType { &quot;IMAGE&quot;, &quot;VIDEO&quot;, &quot;AUDIO&quot;, &quot;OTHER&quot; };</webidl>
      <descriptive>
         <description>
          <p>
Defines the type of content such as image, video, audio and other.
          </p>
         </description>
          <version>
 2.0
          </version>
          <remark>
 &quot;OTHER&quot; type is added since 2.1.
          </remark>
      </descriptive>
      <EnumValue stringvalue="IMAGE">
        <webidl> &quot;IMAGE</webidl>
      </EnumValue>
      <EnumValue stringvalue="VIDEO">
        <webidl> &quot;VIDEO</webidl>
      </EnumValue>
      <EnumValue stringvalue="AUDIO">
        <webidl> &quot;AUDIO</webidl>
      </EnumValue>
      <EnumValue stringvalue="OTHER">
        <webidl> &quot;OTHER</webidl>
      </EnumValue>
    </Enum>
    <Enum name="AudioContentLyricsType" id="::Content::AudioContentLyricsType">
      <webidl>  enum AudioContentLyricsType { &quot;SYNCHRONIZED&quot;, &quot;UNSYNCHRONIZED&quot; };</webidl>
      <descriptive>
         <description>
          <p>
Defines whether the lyric supplied with an audio file is time-synchronized or not.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="SYNCHRONIZED">
        <webidl> &quot;SYNCHRONIZED</webidl>
      </EnumValue>
      <EnumValue stringvalue="UNSYNCHRONIZED">
        <webidl> &quot;UNSYNCHRONIZED</webidl>
      </EnumValue>
    </Enum>
    <Enum name="ImageContentOrientation" id="::Content::ImageContentOrientation">
      <webidl>  enum ImageContentOrientation { &quot;NORMAL&quot;, &quot;FLIP_HORIZONTAL&quot;, &quot;ROTATE_180&quot;, &quot;FLIP_VERTICAL&quot;, &quot;TRANSPOSE&quot;, &quot;ROTATE_90&quot;, &quot;TRANSVERSE&quot;, &quot;ROTATE_270&quot; };</webidl>
      <descriptive>
         <description>
          <p>
Defines an orientation of an image.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="NORMAL">
        <webidl> &quot;NORMAL</webidl>
      </EnumValue>
      <EnumValue stringvalue="FLIP_HORIZONTAL">
        <webidl> &quot;FLIP_HORIZONTAL</webidl>
      </EnumValue>
      <EnumValue stringvalue="ROTATE_180">
        <webidl> &quot;ROTATE_180</webidl>
      </EnumValue>
      <EnumValue stringvalue="FLIP_VERTICAL">
        <webidl> &quot;FLIP_VERTICAL</webidl>
      </EnumValue>
      <EnumValue stringvalue="TRANSPOSE">
        <webidl> &quot;TRANSPOSE</webidl>
      </EnumValue>
      <EnumValue stringvalue="ROTATE_90">
        <webidl> &quot;ROTATE_90</webidl>
      </EnumValue>
      <EnumValue stringvalue="TRANSVERSE">
        <webidl> &quot;TRANSVERSE</webidl>
      </EnumValue>
      <EnumValue stringvalue="ROTATE_270">
        <webidl> &quot;ROTATE_270</webidl>
      </EnumValue>
    </Enum>
    <Typedef name="ContentId" id="::Content::ContentId">
      <webidl>  typedef DOMString ContentId;</webidl>
      <descriptive>
          <brief>
 Content identifier.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="ContentDirectoryId" id="::Content::ContentDirectoryId">
      <webidl>  typedef DOMString ContentDirectoryId;</webidl>
      <descriptive>
          <brief>
 Content directory identifier.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Interface name="ContentManagerObject" id="::Content::ContentManagerObject">
      <webidl>  [NoInterfaceObject] interface ContentManagerObject {
    readonly attribute <ref>ContentManager</ref> content;
  };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated by the Tizen object.
          </brief>
         <description>
          <p>
There is a <em>tizen.content </em>object that allows accessing the functionality of the Content module.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="content" id="::Content::ContentManagerObject::content">
        <webidl>    readonly attribute <ref>ContentManager</ref> content;</webidl>
        <Type name="ContentManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="ContentManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>ContentManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="ContentManager" id="::Content::ContentManager">
      <webidl>  [NoInterfaceObject] interface ContentManager {

    void update(<ref>Content</ref> content) raises(<ref>WebAPIException</ref>);

    void updateBatch(<ref>Content</ref>[] contents,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void getDirectories(<ref>ContentDirectoryArraySuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void find(<ref>ContentArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>ContentDirectoryId</ref>? directoryId,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode,
              optional unsigned long? count,
              optional unsigned long? offset) raises(<ref>WebAPIException</ref>);


    void scanFile(DOMString contentURI,
                  optional <ref>ContentScanSuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void setChangeListener(<ref>ContentChangeCallback</ref> changeCallback) raises(<ref>WebAPIException</ref>);

    void unsetChangeListener() raises(<ref>WebAPIException</ref>);

  };</webidl>
      <descriptive>
          <brief>
 This interface provides operations to retrieve and manipulate contents.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="update" id="::Content::ContentManager::update">
        <webidl>    void update(<ref>Content</ref> content) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates attributes of the content in content database synchronously.
            </brief>
           <description>
            <p>
When an application has changed some attributes of a content, this method allows
writing it back to the content database.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/content.write
            </privilege>
            <remark>
 The <em>editableAttributes </em>in <em>Content </em>interface indicates
the attributes that can be changed.
This API does not support updating the metadata of a file.
            </remark>
            <Code> // Assume the content is a Content object as a result of find method.
 // Check the description is editable, and then set a description.
 if (content.editableAttributes.indexOf(&quot;description&quot;) >= 0) {
     content.description = &quot;Sample content&quot;;
 }
 tizen.content.update(content);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="content">
            <descriptive>
                <description><p>
 The content to update.
                </p></description>
            </descriptive>
            <Type name="Content"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters
contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="updateBatch" id="::Content::ContentManager::updateBatch">
        <webidl>    void updateBatch(<ref>Content</ref>[] contents,
                     optional <ref>SuccessCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates a batch of content attributes in the content database synchronously.
            </brief>
           <description>
            <p>
When an application has changed any attributes in array of content, this method allows writing them
back to the content database.
            </p>
            <p>
The errorCallback can be launched with any of these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/content.write
            </privilege>
            <remark>
 The <em>editableAttributes </em>in <em>Content </em>interface indicates
the attributes that can be changed.
This API does not support updating the metadata of a file.
            </remark>
            <Code> // The following example increases rating of an content by 1

 function errorCB(err) {
     console.log( 'The following error occurred: ' +  err.name);
 }

 function successCB() {
     console.log('Attributes set successfully');
 }

 // Assume the content is a Content object as a result of find method.
 // Check the rating is editable, and then increase by 1.
 if (content.editableAttributes.indexOf(&quot;rating&quot;) >= 0) {
     content.rating++;
 }
 tizen.content.updateBatch([content], successCB, errorCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contents">
            <descriptive>
                <description><p>
 Array of content to change.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Content"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 Function called when attributes have been changed.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 Function called when an error has occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getDirectories" id="::Content::ContentManager::getDirectories">
        <webidl>    void getDirectories(<ref>ContentDirectoryArraySuccessCallback</ref> successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets a list of content directory.
            </brief>
           <description>
            <p>
This method returns (via callback) a list of content directory objects. To obtain a list of contents
in a specific directory, use find() method with the directory ID.
            </p>
            <p>
The errorCallback is launched with this error type:
            </p>
            <ul>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <Code> // The following example retrieves content directories in the storage.

 function errorCB(err) {
     console.log( 'The following error occurred: ' +  err.name);
 }

 function printDirectory(directory, index, directories) {
     console.log('directoryURI: ' + directory.directoryURI + ' Title: ' + directory.title);
 }
 function getDirectoriesCB(directories) {
     directories.forEach(printDirectory);
 }

 tizen.content.getDirectories(getDirectoriesCB, errorCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 Function called when content directories have been retrieved successfully.
                </p></description>
            </descriptive>
            <Type name="ContentDirectoryArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 Function called when an error has occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="find" id="::Content::ContentManager::find">
        <webidl>    void find(<ref>ContentArraySuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional <ref>ContentDirectoryId</ref>? directoryId,
              optional <ref>AbstractFilter</ref>? filter,
              optional <ref>SortMode</ref>? sortMode,
              optional unsigned long? count,
              optional unsigned long? offset) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Finds contents that satisfy the conditions set by a filter.
            </brief>
           <description>
            <p>
This method allows searching based on a supplied filter. For more detail on AbstractFilter, see
<a href="../../org.tizen.web.device.apireference/tizen/tizen.html#::Tizen::AbstractFilter">Tizen</a> module. The filter allows precise searching such
as &quot;return all songs by artist U2, ordered by name&quot;.
            </p>
            <p>
The errorCallback can be launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/content.read
            </privilege>
            <Code> // The following example retrieves all songs from the album &quot;The Joshua Tree&quot;, by artist &quot;U2&quot;, ordered by the track number.
 var count = 100;
 var offset = 0;
 var sortMode = new tizen.SortMode(&quot;trackNumber&quot;, &quot;ASC&quot;);
 var artistFilter = new tizen.AttributeFilter(&quot;artists&quot;, &quot;EXACTLY&quot;, &quot;U2&quot;);
 var albumFilter = new tizen.AttributeFilter(&quot;album&quot;, &quot;EXACTLY&quot;, &quot;The Joshua Tree&quot;);
 var filter = new tizen.CompositeFilter(&quot;INTERSECTION&quot;, [albumFilter, artistFilter]);

 function errorCB(err) {
     console.log( 'The following error occurred: ' +  err.name);
 }

 function printContent(content, index, contents) {
     console.log('Track: ' + content.trackNumber + ' Title: ' + content.title + 'Duration: ' + content.duration + 'URL: ' + content.contentURI + 'MIME: ' + content.mimeType);
 }

 function findCB(contents) {
     console.log('The Joshua Tree by U2:');
     contents.forEach(printContent);
     // Increase the offset as much as the count and then find content again.
     if (contents.length == count) {
         offset += count;
         tizen.content.find(findCB, errorCB, null, filter, sortMode, count, offset);
     }
 }

 tizen.content.find(findCB, errorCB, null, filter, sortMode, count, offset);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 Function called when a content have been retrieved.
                </p></description>
            </descriptive>
            <Type name="ContentArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 Function called when an error has occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="directoryId">
            <descriptive>
                <description><p>
 Directory ID that is use to select content to retrieve in a specified directory.
                </p></description>
            </descriptive>
            <Type name="ContentDirectoryId" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 Filter that is used to select content to retrieve.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="sortMode">
            <descriptive>
                <description><p>
 Used to determine the sort order in which the content are returned.
                </p></description>
            </descriptive>
            <Type name="SortMode" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="count">
            <descriptive>
                <description><p>
 Maximum amount of content to return.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="offset">
            <descriptive>
                <description><p>
 Offset of the result set.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="scanFile" id="::Content::ContentManager::scanFile">
        <webidl>    void scanFile(DOMString contentURI,
                  optional <ref>ContentScanSuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Scan a file to create or update a content in the content database.
            </brief>
           <description>
            <p>
When an application creates or updates a content, this method allows scan it
to insert or update the content in the content database.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/content.write
            </privilege>
            <Code> // The following example scan 'tizen.jpg' in media directory

 function errorCB(err) {
     console.log( 'The following error occurred: ' +  err.name);
 }

 function successCB(path) {
     console.log('scanning is completed');
 }

 var path = &quot;file:///opt/usr/media/tizen.jpg&quot;;
 tizen.content.scanFile(path, successCB, errorCB);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contentURI">
            <descriptive>
                <description><p>
 The URI of content to scan.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 Function called when scanning has been completed.
                </p></description>
            </descriptive>
            <Type name="ContentScanSuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 Function called when an error has occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters
contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setChangeListener" id="::Content::ContentManager::setChangeListener">
        <webidl>    void setChangeListener(<ref>ContentChangeCallback</ref> changeCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets a listener to receive notifications about content changes.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/content.read
            </privilege>
            <Code> var listener= {
    oncontentadded: function(content) {
        console.log(content.contentURI + ' content is added');
    },
    oncontentupdated: function(content) {
        console.log(content.contentURI + ' content is updated');
    },
    oncontentremoved: function(id) {
        console.log(id + ' is removed');
    }
 };

 // Registers to be notified when the content changes
 tizen.content.setChangeListener(listener);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="changeCallback">
            <descriptive>
                <description><p>
 A callback to be invoked for receiving content change notification.
                </p></description>
            </descriptive>
            <Type name="ContentChangeCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unsetChangeListener" id="::Content::ContentManager::unsetChangeListener">
        <webidl>    void unsetChangeListener() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsets the listener to unsubscribes from receiving notification for any content changes.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/content.read
            </privilege>
            <Code> tizen.content.unsetChangeListener();

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="ContentArraySuccessCallback" id="::Content::ContentArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ContentArraySuccessCallback {
    void onsuccess(<ref>Content</ref>[] contents);
  };</webidl>
      <descriptive>
          <brief>
 The callback function used to return a list of content objects.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Content::ContentArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>Content</ref>[] contents);</webidl>
        <descriptive>
            <brief>
 Called when the list of content is retrieved successfully.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contents">
            <descriptive>
                <description><p>
 The array of <em>Content </em>objects.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Content"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ContentDirectoryArraySuccessCallback" id="::Content::ContentDirectoryArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ContentDirectoryArraySuccessCallback {
    void onsuccess(<ref>ContentDirectory</ref>[] directories);
  };</webidl>
      <descriptive>
          <brief>
 The callback function used to return a list of ContentDirectory objects.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Content::ContentDirectoryArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>ContentDirectory</ref>[] directories);</webidl>
        <descriptive>
            <brief>
 Called when the list of directory is retrieved successfully.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="directories">
            <descriptive>
                <description><p>
 The array of <em>ContentDirectory </em>objects.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="ContentDirectory"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ContentScanSuccessCallback" id="::Content::ContentScanSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ContentScanSuccessCallback {
    void onsuccess(DOMString contentURI);
  };</webidl>
      <descriptive>
          <brief>
 The callback function used to return a content to scan has been completed.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Content::ContentScanSuccessCallback::onsuccess">
        <webidl>    void onsuccess(DOMString contentURI);</webidl>
        <descriptive>
            <brief>
 Called when the scanning has been completed.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="contentURI">
            <descriptive>
                <description><p>
 The URI of <em>Content </em>objects.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ContentChangeCallback" id="::Content::ContentChangeCallback">
      <webidl>  [Callback, NoInterfaceObject] interface ContentChangeCallback {
    void oncontentadded(<ref>Content</ref> content);

    void oncontentupdated(<ref>Content</ref> content);

    void oncontentremoved(<ref>ContentId</ref> id);
  };</webidl>
      <descriptive>
          <brief>
 This interface specifies a set of methods that are invoked every time a content change occurs.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="oncontentadded" id="::Content::ContentChangeCallback::oncontentadded">
        <webidl>    void oncontentadded(<ref>Content</ref> content);</webidl>
        <descriptive>
            <brief>
 Called when content is added.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="content">
            <descriptive>
                <description><p>
 The content to add.
                </p></description>
            </descriptive>
            <Type name="Content"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="oncontentupdated" id="::Content::ContentChangeCallback::oncontentupdated">
        <webidl>    void oncontentupdated(<ref>Content</ref> content);</webidl>
        <descriptive>
            <brief>
 Called when content is updated.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="content">
            <descriptive>
                <description><p>
 The content to update.
                </p></description>
            </descriptive>
            <Type name="Content"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="oncontentremoved" id="::Content::ContentChangeCallback::oncontentremoved">
        <webidl>    void oncontentremoved(<ref>ContentId</ref> id);</webidl>
        <descriptive>
            <brief>
 Called when content is removed.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The id of content to remove.
                </p></description>
            </descriptive>
            <Type name="ContentId"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ContentDirectory" id="::Content::ContentDirectory">
      <webidl>  [NoInterfaceObject] interface ContentDirectory {

    readonly attribute <ref>ContentDirectoryId</ref> id;

    readonly attribute DOMString directoryURI;

    readonly attribute DOMString title;

    readonly attribute <ref>ContentDirectoryStorageType</ref> storageType;

    readonly attribute Date? modifiedDate;

   };</webidl>
      <descriptive>
          <brief>
 This interface that provides access to properties of a content directory.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Content::ContentDirectory::id">
        <webidl>    readonly attribute <ref>ContentDirectoryId</ref> id;</webidl>
        <descriptive>
            <brief>
 The opaque content directory identifier.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ContentDirectoryId"/>
      </Attribute>
      <Attribute readonly="readonly" name="directoryURI" id="::Content::ContentDirectory::directoryURI">
        <webidl>    readonly attribute DOMString directoryURI;</webidl>
        <descriptive>
            <brief>
 The directory path on the device.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="title" id="::Content::ContentDirectory::title">
        <webidl>    readonly attribute DOMString title;</webidl>
        <descriptive>
            <brief>
 The directory name.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="storageType" id="::Content::ContentDirectory::storageType">
        <webidl>    readonly attribute <ref>ContentDirectoryStorageType</ref> storageType;</webidl>
        <descriptive>
            <brief>
 The type of a device storage.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ContentDirectoryStorageType"/>
      </Attribute>
      <Attribute readonly="readonly" name="modifiedDate" id="::Content::ContentDirectory::modifiedDate">
        <webidl>    readonly attribute Date? modifiedDate;</webidl>
        <descriptive>
            <brief>
 The last modified date for a directory.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="Date" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="Content" id="::Content::Content">
      <webidl>  [NoInterfaceObject] interface Content {

    readonly attribute DOMString[] editableAttributes;

    readonly attribute <ref>ContentId</ref> id;

    attribute DOMString name;

    readonly attribute <ref>ContentType</ref> type;

    readonly attribute DOMString mimeType;

    readonly attribute DOMString title;

    readonly attribute DOMString contentURI;

    readonly attribute DOMString[]? thumbnailURIs;

    readonly attribute Date? releaseDate;

    readonly attribute Date? modifiedDate;

    readonly attribute unsigned long size;

    attribute DOMString? description;

    attribute unsigned long rating;
  };</webidl>
      <descriptive>
          <brief>
 This interface provides access to properties of a content.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="editableAttributes" id="::Content::Content::editableAttributes">
        <webidl>    readonly attribute DOMString[] editableAttributes;</webidl>
        <descriptive>
            <brief>
 The list of attributes that can be editable to the local backend using update or updateBatch method.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="id" id="::Content::Content::id">
        <webidl>    readonly attribute <ref>ContentId</ref> id;</webidl>
        <descriptive>
            <brief>
 The opaque content identifier.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ContentId"/>
      </Attribute>
      <Attribute name="name" id="::Content::Content::name">
        <webidl>    attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 The content name. The initial value is the file name of the content.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::Content::Content::type">
        <webidl>    readonly attribute <ref>ContentType</ref> type;</webidl>
        <descriptive>
            <brief>
 The content type.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ContentType"/>
      </Attribute>
      <Attribute readonly="readonly" name="mimeType" id="::Content::Content::mimeType">
        <webidl>    readonly attribute DOMString mimeType;</webidl>
        <descriptive>
            <brief>
 The content MIME type.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="title" id="::Content::Content::title">
        <webidl>    readonly attribute DOMString title;</webidl>
        <descriptive>
            <brief>
 The content title.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="contentURI" id="::Content::Content::contentURI">
        <webidl>    readonly attribute DOMString contentURI;</webidl>
        <descriptive>
            <brief>
 The URI to access the content.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="thumbnailURIs" id="::Content::Content::thumbnailURIs">
        <webidl>    readonly attribute DOMString[]? thumbnailURIs;</webidl>
        <descriptive>
            <brief>
 The array of content thumbnails URIs.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="releaseDate" id="::Content::Content::releaseDate">
        <webidl>    readonly attribute Date? releaseDate;</webidl>
        <descriptive>
            <brief>
 The date when a content has been released to the public. If only the release year is known, then the month and date are set to January and 1st respectively.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="Date" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="modifiedDate" id="::Content::Content::modifiedDate">
        <webidl>    readonly attribute Date? modifiedDate;</webidl>
        <descriptive>
            <brief>
 The last modified date for a content.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="Date" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="size" id="::Content::Content::size">
        <webidl>    readonly attribute unsigned long size;</webidl>
        <descriptive>
            <brief>
 The file size of the content in bytes.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute name="description" id="::Content::Content::description">
        <webidl>    attribute DOMString? description;</webidl>
        <descriptive>
            <brief>
 The content description.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="rating" id="::Content::Content::rating">
        <webidl>    attribute unsigned long rating;</webidl>
        <descriptive>
            <brief>
 The content rating and this value can vary from <var>0 </var>to <var>10</var>.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
    <Interface name="VideoContent" id="::Content::VideoContent">
      <webidl>  [NoInterfaceObject] interface VideoContent : <ref>Content</ref> {

    attribute <ref>SimpleCoordinates</ref>? geolocation;

    readonly attribute DOMString? album;

    readonly attribute DOMString[]? artists;

    readonly attribute unsigned long duration;

    readonly attribute unsigned long width;

    readonly attribute unsigned long height;

  };</webidl>
      <descriptive>
          <brief>
 This interface extends a basic <em>Content </em>object with video-specific attributes.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="Content"/>
      </InterfaceInheritance>
      <Attribute name="geolocation" id="::Content::VideoContent::geolocation">
        <webidl>    attribute <ref>SimpleCoordinates</ref>? geolocation;</webidl>
        <descriptive>
            <brief>
 The geographical location where the video was made.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="SimpleCoordinates" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="album" id="::Content::VideoContent::album">
        <webidl>    readonly attribute DOMString? album;</webidl>
        <descriptive>
            <brief>
 The album name to which the video belongs.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="artists" id="::Content::VideoContent::artists">
        <webidl>    readonly attribute DOMString[]? artists;</webidl>
        <descriptive>
            <brief>
 The list of artists who created the video.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="duration" id="::Content::VideoContent::duration">
        <webidl>    readonly attribute unsigned long duration;</webidl>
        <descriptive>
            <brief>
 The video duration in milliseconds.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="width" id="::Content::VideoContent::width">
        <webidl>    readonly attribute unsigned long width;</webidl>
        <descriptive>
            <brief>
 The width of a video in pixels.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="height" id="::Content::VideoContent::height">
        <webidl>    readonly attribute unsigned long height;</webidl>
        <descriptive>
            <brief>
 The height of the video in pixels.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
    <Interface name="AudioContentLyrics" id="::Content::AudioContentLyrics">
      <webidl>  [NoInterfaceObject] interface AudioContentLyrics {

    readonly attribute <ref>AudioContentLyricsType</ref> type;

    readonly attribute unsigned long[] timestamps;

    readonly attribute DOMString[] texts;
  };</webidl>
      <descriptive>
          <brief>
 This interface provides lyrics for music.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="type" id="::Content::AudioContentLyrics::type">
        <webidl>    readonly attribute <ref>AudioContentLyricsType</ref> type;</webidl>
        <descriptive>
            <brief>
 The type of lyrics, that is, whether they are synchronized with the music or not.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="AudioContentLyricsType"/>
      </Attribute>
      <Attribute readonly="readonly" name="timestamps" id="::Content::AudioContentLyrics::timestamps">
        <webidl>    readonly attribute unsigned long[] timestamps;</webidl>
        <descriptive>
            <brief>
 The array of timestamps in milliseconds for lyrics.
            </brief>
           <description>
            <p>
If the lyrics are not synchronized (if there is no time information for the lyrics) the array is undefined.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="unsigned long"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="texts" id="::Content::AudioContentLyrics::texts">
        <webidl>    readonly attribute DOMString[] texts;</webidl>
        <descriptive>
            <brief>
 The array of lyric snippets.
            </brief>
           <description>
            <p>
If the lyrics are not synchronized, the array has only one member with full lyrics.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="AudioContent" id="::Content::AudioContent">
      <webidl>  [NoInterfaceObject] interface AudioContent : <ref>Content</ref> {

    readonly attribute DOMString? album;

    readonly attribute DOMString[]? genres;

    readonly attribute DOMString[]? artists;

    readonly attribute DOMString[]? composers;

    readonly attribute <ref>AudioContentLyrics</ref>? lyrics;

    readonly attribute DOMString? copyright;

    readonly attribute unsigned long bitrate;

    readonly attribute unsigned short? trackNumber;

    readonly attribute unsigned long duration;

  };</webidl>
      <descriptive>
          <brief>
 This interface extends a basic <em>Content </em>object with audio-specific attributes.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="Content"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="album" id="::Content::AudioContent::album">
        <webidl>    readonly attribute DOMString? album;</webidl>
        <descriptive>
            <brief>
 The album name to which the audio belongs.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="genres" id="::Content::AudioContent::genres">
        <webidl>    readonly attribute DOMString[]? genres;</webidl>
        <descriptive>
            <brief>
 The list of genres to which the audio belongs.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="artists" id="::Content::AudioContent::artists">
        <webidl>    readonly attribute DOMString[]? artists;</webidl>
        <descriptive>
            <brief>
 The list of artists who created the audio.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="composers" id="::Content::AudioContent::composers">
        <webidl>    readonly attribute DOMString[]? composers;</webidl>
        <descriptive>
            <brief>
 The list of composers for the music.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="lyrics" id="::Content::AudioContent::lyrics">
        <webidl>    readonly attribute <ref>AudioContentLyrics</ref>? lyrics;</webidl>
        <descriptive>
            <brief>
 The lyrics of a song in an audio file.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="AudioContentLyrics" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="copyright" id="::Content::AudioContent::copyright">
        <webidl>    readonly attribute DOMString? copyright;</webidl>
        <descriptive>
            <brief>
 The copyright information.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="bitrate" id="::Content::AudioContent::bitrate">
        <webidl>    readonly attribute unsigned long bitrate;</webidl>
        <descriptive>
            <brief>
 The audio bitrate in bits per second. By default, this value is 0.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="trackNumber" id="::Content::AudioContent::trackNumber">
        <webidl>    readonly attribute unsigned short? trackNumber;</webidl>
        <descriptive>
            <brief>
 The track number if the audio belongs to an album.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="duration" id="::Content::AudioContent::duration">
        <webidl>    readonly attribute unsigned long duration;</webidl>
        <descriptive>
            <brief>
 The audio duration in milliseconds.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
    <Interface name="ImageContent" id="::Content::ImageContent">
      <webidl>  [NoInterfaceObject] interface ImageContent : <ref>Content</ref> {

    attribute <ref>SimpleCoordinates</ref>? geolocation;

    readonly attribute unsigned long width;

    readonly attribute unsigned long height;

    attribute <ref>ImageContentOrientation</ref> orientation;

  };</webidl>
      <descriptive>
          <brief>
 This interface extends a basic <em>Content </em>object with image-specific attributes.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="Content"/>
      </InterfaceInheritance>
      <Attribute name="geolocation" id="::Content::ImageContent::geolocation">
        <webidl>    attribute <ref>SimpleCoordinates</ref>? geolocation;</webidl>
        <descriptive>
            <brief>
 The geographical location where the image has been made.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="SimpleCoordinates" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="width" id="::Content::ImageContent::width">
        <webidl>    readonly attribute unsigned long width;</webidl>
        <descriptive>
            <brief>
 The width of an image in pixels.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="height" id="::Content::ImageContent::height">
        <webidl>    readonly attribute unsigned long height;</webidl>
        <descriptive>
            <brief>
 The height of an image in pixels.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute name="orientation" id="::Content::ImageContent::orientation">
        <webidl>    attribute <ref>ImageContentOrientation</ref> orientation;</webidl>
        <descriptive>
            <brief>
 The image orientation.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ImageContentOrientation"/>
      </Attribute>
    </Interface>
  </Module>
  <Module name="DataControl" id="::DataControl">
    <webidl>module DataControl {
    enum DataType { &quot;MAP&quot;, &quot;SQL&quot;};

    [NoInterfaceObject] interface DataControlManagerObject {
        readonly attribute <ref>DataControlManager</ref> datacontrol;
    };
    <ref>Tizen</ref> implements <ref>DataControlManagerObject</ref>;


    [NoInterfaceObject] interface DataControlManager {
        <ref>DataControlConsumerObject</ref> getDataControlConsumer(DOMString providerId, DOMString dataId, <ref>DataType</ref> type) raises(<ref>WebAPIException</ref>);
    };


    [NoInterfaceObject] interface DataControlConsumerObject {
        readonly attribute <ref>DataType</ref> type;
        readonly attribute DOMString providerId;
        readonly attribute DOMString dataId;
    };


    [NoInterfaceObject] interface SQLDataControlConsumer : <ref>DataControlConsumerObject</ref> {
        void insert(unsigned long reqId, <ref>RowData</ref> insertionData,
                    optional <ref>DataControlInsertSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void update(unsigned long reqId, <ref>RowData</ref> updateData, DOMString where,
                    optional <ref>DataControlSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void remove(unsigned long reqId, DOMString where,
                    optional <ref>DataControlSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);


        void select(unsigned long reqId, DOMString[] columns, DOMString where,
                    <ref>DataControlSelectSuccessCallback</ref> successCallback, optional <ref>DataControlErrorCallback</ref>? errorCallback,
                    optional unsigned long? page, optional unsigned long? maxNumberPerPage) raises(<ref>WebAPIException</ref>);
    };

    [NoInterfaceObject] interface MappedDataControlConsumer : <ref>DataControlConsumerObject</ref> {
        void addValue(unsigned long reqId, DOMString key, DOMString value,
                     optional <ref>DataControlSuccessCallback</ref>? successCallback,
                     optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

         void removeValue(unsigned long reqId, DOMString key, DOMString value,
                          <ref>DataControlSuccessCallback</ref> successCallback,
                          optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

         void getValue(unsigned long reqId, DOMString key,
                       <ref>DataControlGetValueSuccessCallback</ref> successCallback,
                       optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

         void updateValue(unsigned long reqId, DOMString key, DOMString oldValue, DOMString newValue,
                          <ref>DataControlSuccessCallback</ref> successCallback,
                          optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
    };


    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlSuccessCallback {
        void onsuccess(unsigned long reqId);
    };


    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlErrorCallback {
        void onerror(unsigned long reqId, <ref>WebAPIError</ref> error);
    };


    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlInsertSuccessCallback {
        void onsuccess(unsigned long reqId, long insertRowId);
    };



    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlSelectSuccessCallback {
        void onsuccess(<ref>RowData</ref>[] rows, unsigned long reqId);
    };


    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlGetValueSuccessCallback {
        void onsuccess(DOMString[] values, unsigned long reqid);
    };


    dictionary RowData {
        DOMString[] columns;
        DOMString[] values;
    };
};</webidl>
    <descriptive>
        <brief>
 This specification defines a DataControl API for applications.
        </brief>
       <description>
        <p>
The DataControl functionality provides a way to access specific data that is exported by other applications.
        </p>
        <p>
Please read the <a href="../../org.tizen.native.appprogramming/html/guide/app/data_controls.htm">Native DataControl API</a> to know how to share own application data with other applications.
        </p>
       </description>
        <version>
 2.1
        </version>
    </descriptive>
    <Enum name="DataType" id="::DataControl::DataType">
      <webidl>    enum DataType { &quot;MAP&quot;, &quot;SQL&quot;};</webidl>
      <descriptive>
          <brief>
 Data types.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="MAP">
        <webidl> &quot;MAP</webidl>
      </EnumValue>
      <EnumValue stringvalue="SQL">
        <webidl> &quot;SQL</webidl>
      </EnumValue>
    </Enum>
    <Interface name="DataControlManagerObject" id="::DataControl::DataControlManagerObject">
      <webidl>    [NoInterfaceObject] interface DataControlManagerObject {
        readonly attribute <ref>DataControlManager</ref> datacontrol;
    };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated in the <em>Tizen</em> object.
          </brief>
         <description>
          <p>
There is a <em>tizen.datacontrol</em> object that allows access to the
DataControl API.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="datacontrol" id="::DataControl::DataControlManagerObject::datacontrol">
        <webidl>        readonly attribute <ref>DataControlManager</ref> datacontrol;</webidl>
        <Type name="DataControlManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="DataControlManagerObject">
      <webidl>    <ref>Tizen</ref> implements <ref>DataControlManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="DataControlManager" id="::DataControl::DataControlManager">
      <webidl>    [NoInterfaceObject] interface DataControlManager {
        <ref>DataControlConsumerObject</ref> getDataControlConsumer(DOMString providerId, DOMString dataId, <ref>DataType</ref> type) raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface provides access to the <em>DataControlManager </em>object.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getDataControlConsumer" id="::DataControl::DataControlManager::getDataControlConsumer">
        <webidl>        <ref>DataControlConsumerObject</ref> getDataControlConsumer(DOMString providerId, DOMString dataId, <ref>DataType</ref> type) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets <em>DataControlConsumerObject</em> with a given DataType.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code> //The data provider, a native application, should be pre-installed and launched.
 //The same provider id should be defined for the use of this API between a native application(provider) and a web application(consumer).
 //In this example, DictionaryDataControlProvider native sample application is used as a data control provider.

 //Gets SQL type DataControlConsumerObject
 try {
     var globalSQLConsumer = tizen.datacontrol.getDataControlConsumer(
     &quot;http://tizen.org/datacontrol/provider/DictionaryDataControlProvider&quot;, &quot;Dictionary&quot;, &quot;SQL&quot;);
 } catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }
 // Gets MAP type DataControlConsumerObject
 try {
      globalMappedConsumer = tizen.datacontrol.getDataControlConsumer(
      &quot;http://tizen.org/datacontrol/provider/DictionaryDataControlProvider&quot;, &quot;Dictionary&quot;, &quot;MAP&quot;);
 } catch (err) {
      console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type name="DataControlConsumerObject">
          <descriptive>
              <description><p>
 DataControlConsumerObject The local <em>DataControlConsumerObject</em>.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="providerId">
            <descriptive>
                <description><p>
 A provider ID to use and it should be shared between DataControl provider and DataControl consumer.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="dataId">
            <descriptive>
                <description><p>
 A string for identifying a specific data.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="type">
            <descriptive>
                <description><p>
 The DataType to use.
                </p></description>
            </descriptive>
            <Type name="DataType"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is mismatched.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="DataControlConsumerObject" id="::DataControl::DataControlConsumerObject">
      <webidl>    [NoInterfaceObject] interface DataControlConsumerObject {
        readonly attribute <ref>DataType</ref> type;
        readonly attribute DOMString providerId;
        readonly attribute DOMString dataId;
    };</webidl>
      <descriptive>
          <brief>
 This interface provides common attributes for other derived DataControlCunsumerObject.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="type" id="::DataControl::DataControlConsumerObject::type">
        <webidl>        readonly attribute <ref>DataType</ref> type;</webidl>
        <descriptive>
            <brief>
 An attribute to store the DataType.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="DataType"/>
      </Attribute>
      <Attribute readonly="readonly" name="providerId" id="::DataControl::DataControlConsumerObject::providerId">
        <webidl>        readonly attribute DOMString providerId;</webidl>
        <descriptive>
            <brief>
 An attribute to hold a provider identifier of the application whom it shares the DataControl with.
This attribute should be known to users who want to interact with application to provide.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="dataId" id="::DataControl::DataControlConsumerObject::dataId">
        <webidl>        readonly attribute DOMString dataId;</webidl>
        <descriptive>
            <brief>
 The dataId identifies specific data, usually a database table to process(insert, delete, update).
The string consists of one or more components, separated by a slash('/').
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="SQLDataControlConsumer" id="::DataControl::SQLDataControlConsumer">
      <webidl>    [NoInterfaceObject] interface SQLDataControlConsumer : <ref>DataControlConsumerObject</ref> {
        void insert(unsigned long reqId, <ref>RowData</ref> insertionData,
                    optional <ref>DataControlInsertSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void update(unsigned long reqId, <ref>RowData</ref> updateData, DOMString where,
                    optional <ref>DataControlSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

        void remove(unsigned long reqId, DOMString where,
                    optional <ref>DataControlSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);


        void select(unsigned long reqId, DOMString[] columns, DOMString where,
                    <ref>DataControlSelectSuccessCallback</ref> successCallback, optional <ref>DataControlErrorCallback</ref>? errorCallback,
                    optional unsigned long? page, optional unsigned long? maxNumberPerPage) raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface defines SQL data type operatiors.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="DataControlConsumerObject"/>
      </InterfaceInheritance>
      <Operation name="insert" id="::DataControl::SQLDataControlConsumer::insert">
        <webidl>        void insert(unsigned long reqId, <ref>RowData</ref> insertionData,
                    optional <ref>DataControlInsertSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Inserts new rows into a table owned by an SQL-type data control provider.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code> function successcb(id)
 {
     console.log(&quot;ok : reqid &quot;+ id);
 }

 function errorcb(id, error)
 {
     console.log(&quot;error id : &quot; + id + &quot;, error msg : &quot; + error.message);
 }

 try {
     var rowData = {
         columns : [&quot;WORD&quot;, &quot;WORD_DESC&quot;] ,
         values  : [&quot;'tizen1'&quot;, &quot;'tizen2'&quot;]
     };
     // Defines globalReqId before
     // Increases globalReqId for uniqueness
     globalReqId++;
     globalSQLConsumer.insert(globalReqId, rowData, successcb, errorcb);
 } catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>So a developer should increase <em>reqId </em>value to ensure it is unique for each method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="insertionData">
            <descriptive>
                <description><p>
 The data on columns and values to insert.
                </p></description>
            </descriptive>
            <Type name="RowData"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="DataControlInsertSuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="DataControlErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the passed parameter is not available on data provider side or platform or if an SQL query with invalid parameters has been made.
                </p></description>
                <description><p>
 with error type IOError, if a DB operation has failed.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="update" id="::DataControl::SQLDataControlConsumer::update">
        <webidl>        void update(unsigned long reqId, <ref>RowData</ref> updateData, DOMString where,
                    optional <ref>DataControlSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates values of a table owned by an SQL-type data control provider.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code> function successcb(id)
 {
     console.log(&quot;ok : reqid &quot; + id);
 }

 function errorcb(id, error)
 {
     console.log(&quot;error id : &quot; + id + &quot;, error msg : &quot; + error.message);
 }

 try {
     var rowData = {
         columns : [&quot;WORD&quot;, &quot;WORD_DESC&quot;] ,
         values  : [&quot;'tizen1'&quot;, &quot;'samsung platform!'&quot;]
     };
     // Defines globalReqId before
     // Increases globalReqId for uniqueness
     globalReqId++;
     globalSQLConsumer.update(globalReqId, rowData, &quot;WORD='tizen1'&quot;, successcb, errorcb);
 } catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>So a developer should increase <em>reqId </em>value to ensure it is unique for each method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="updateData">
            <descriptive>
                <description><p>
 The data on columns and values to update.
                </p></description>
            </descriptive>
            <Type name="RowData"/>
          </Argument>
          <Argument name="where">
            <descriptive>
                <description><p>
 A filter to select desired rows to update. <br/>It is an SQL <var>WHERE</var> clause excluding the <var>WHERE</var> itself such as <var>column1 = 'stringValue' AND column2 = numericValue</var>.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="DataControlSuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="DataControlErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the passed parameter is not available on data provider side or platform or if an SQL query with invalid parameters has been made.
                </p></description>
                <description><p>
 with error type IOError, if a DB operation has failed.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::DataControl::SQLDataControlConsumer::remove">
        <webidl>        void remove(unsigned long reqId, DOMString where,
                    optional <ref>DataControlSuccessCallback</ref>? successCallback,
                    optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Delete rows from a table that is owned by an SQL-type data control provider.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code> function successcb(id)
 {
     console.log(&quot;ok : reqid &quot; + id);
 }

 function errorcb(id, error)
 {
     console.log(&quot;error id : &quot; + id + &quot;, error msg : &quot; + error.message);
 }

 try {
     // Defines globalReqId before
     // Increases globalReqId for uniqueness
     globalReqId++;
     globalSQLConsumer.remove(globalReqId, &quot;WORD='tizen1'&quot;, successcb, errorcb);
 } catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>So a developer should increase <em>reqId </em>value to ensure it is unique for each method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="where">
            <descriptive>
                <description><p>
 A filter to select desired rows to remove. <br/>It is an SQL <var>WHERE</var> clause excluding the <var>WHERE</var> itself such as <var>column1 = 'stringValue' AND column2 = numericValue</var>.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="DataControlSuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="DataControlErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the passed parameter is not available on data provider side or platform or if an SQL query with invalid parameters is made.
                </p></description>
                <description><p>
 with error type IOError, if a DB operation has failed.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="select" id="::DataControl::SQLDataControlConsumer::select">
        <webidl>        void select(unsigned long reqId, DOMString[] columns, DOMString where,
                    <ref>DataControlSelectSuccessCallback</ref> successCallback, optional <ref>DataControlErrorCallback</ref>? errorCallback,
                    optional unsigned long? page, optional unsigned long? maxNumberPerPage) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Selects the specified columns to be queried. The result set of the specified columns is retrieved from a table owned by an SQL-type data control provider.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code> function getValueSuccessCB(result, id)
 {
     var length = result.length;
     for (var i = 0; i &#60; length; i++)
     {
         var j = 0;
         for (j = 0; j &#60; result[i].columns.length; j++)
         {
             console.log(&quot;column: &quot; + result[i].columns[j] + &quot;, value: &quot; + result[i].values[j]);
         }
     }
 }

 function errorcb(id, error)
 {
     console.log(&quot;error id : &quot; + id + &quot;, error msg : &quot; + error.message);
 }

 try {
     // Defines globalReqId before
     // Increases globalReqId for uniqueness
     var array = [&quot;WORD&quot;, &quot;WORD_DESC&quot; ];
     globalReqId++;
     globalSQLConsumer.select(globalReqId, array, &quot;WORD='tizen1'&quot;, getValueSuccessCB, errorcb);
 }
 catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }


</Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>So a developer should increase <em>reqId </em>value to ensure it is unique for each method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="columns">
            <descriptive>
                <description><p>
 The columns to select.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="DOMString"/>
            </Type>
          </Argument>
          <Argument name="where">
            <descriptive>
                <description><p>
 A filter to select desired rows. <br/>It is an SQL <var>WHERE</var> clause excluding the <var>WHERE</var> itself such as <var>column1 = 'stringValue' AND column2 = numericValue</var>.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="DataControlSelectSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="DataControlErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="page">
            <descriptive>
                <description><p>
 The page number of the result set. <br/>It starts from <var>1</var>. If the number is out of page, DataControlSelectSuccessCallback will be invoked with no result data.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="maxNumberPerPage">
            <descriptive>
                <description><p>
 The maximum number of rows on a page.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the passed parameter is not available on data provider side or platform or if an SQL query with invalid parameters has been made.
                </p></description>
                <description><p>
 with error type IOError, if a DB operation has failed.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="MappedDataControlConsumer" id="::DataControl::MappedDataControlConsumer">
      <webidl>    [NoInterfaceObject] interface MappedDataControlConsumer : <ref>DataControlConsumerObject</ref> {
        void addValue(unsigned long reqId, DOMString key, DOMString value,
                     optional <ref>DataControlSuccessCallback</ref>? successCallback,
                     optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

         void removeValue(unsigned long reqId, DOMString key, DOMString value,
                          <ref>DataControlSuccessCallback</ref> successCallback,
                          optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

         void getValue(unsigned long reqId, DOMString key,
                       <ref>DataControlGetValueSuccessCallback</ref> successCallback,
                       optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

         void updateValue(unsigned long reqId, DOMString key, DOMString oldValue, DOMString newValue,
                          <ref>DataControlSuccessCallback</ref> successCallback,
                          optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
    };</webidl>
      <descriptive>
          <brief>
 This interface defines MAP data type operators.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="DataControlConsumerObject"/>
      </InterfaceInheritance>
      <Operation name="addValue" id="::DataControl::MappedDataControlConsumer::addValue">
        <webidl>        void addValue(unsigned long reqId, DOMString key, DOMString value,
                     optional <ref>DataControlSuccessCallback</ref>? successCallback,
                     optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds the value associated with the specified key to a key-values map owned by MAP-type data control provider.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code>
 function successcb(id)
 {
     console.log(&quot;ok : reqid &quot; + id);
 }

 function errorcb(id, error)
 {
     console.log(&quot;error id : &quot; + id + &quot;, error msg : &quot; + error.message);
 }

 try {
     // Defines globalReqId before
     // Increases globalReqId for uniqueness
     globalReqId++;
     globalMappedConsumer.addValue(globalReqId, &quot;tizen&quot;, &quot;samsung&quot;, successcb, errorcb);
 } catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>So a developer should increase <em>reqId </em>value to ensure it is unique for each method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="key">
            <descriptive>
                <description><p>
 The key to search a mapped data.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="value">
            <descriptive>
                <description><p>
 The value to add into values array mapped by the key.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="DataControlSuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="DataControlErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the passed parameter is not available on data provider side or platform.
                </p></description>
                <description><p>
 with error type IOError, if a DB operation has failed.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeValue" id="::DataControl::MappedDataControlConsumer::removeValue">
        <webidl>         void removeValue(unsigned long reqId, DOMString key, DOMString value,
                          <ref>DataControlSuccessCallback</ref> successCallback,
                          optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes the value associated with the specified key from a key-values map owned by MAP-type data control provider.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code> function successcb(id)
 {
     console.log(&quot;ok : reqid &quot; + id);
 }

 function errorcb(id, error)
 {
     console.log(&quot;error id : &quot; + id + &quot;, error msg : &quot; + error.message);
 }


 try {
     // Defines globalReqId before
     // Increases globalReqId for uniqueness
     globalReqId++;
     globalMappedConsumer.removeValue(globalReqId, &quot;tizen&quot;, &quot;intel&quot;, successcb, errorcb);
 } catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation. <br/>So a developer should increase <em>reqId </em>value to ensure it is unique for each method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="key">
            <descriptive>
                <description><p>
 The key to search a mapped data.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="value">
            <descriptive>
                <description><p>
 The value to remove from a values array mapped by the key.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="DataControlSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="DataControlErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the passed parameter is not available in data provider side or platform.
                </p></description>
                <description><p>
 with error type IOError, if a DB operation has failed.
                </p></description>
                <description><p>
 with error type NotFoundError, if the key cannot be found.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getValue" id="::DataControl::MappedDataControlConsumer::getValue">
        <webidl>         void getValue(unsigned long reqId, DOMString key,
                       <ref>DataControlGetValueSuccessCallback</ref> successCallback,
                       optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets value associated with the specified key, from a key-values map owned by MAP-type data control provider.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code> function getValueSuccessCB(result, id)
 {
     console.log(result.length + &quot;:&quot; + result[0]);
 }

 function errorcb(id, error)
 {
     console.log(&quot;error id : &quot; + id + &quot;, error msg : &quot; + error.message);
 }

 try {
     // Defines globalReqId before
     // Increases globalReqId for uniqueness
     globalReqId++;
     globalMappedConsumer.getValue(globalReqId, &quot;tizen&quot;, getValueSuccessCB, errorcb);
 } catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>So a developer should increase <em>reqId </em>value to ensure it is unique for each method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="key">
            <descriptive>
                <description><p>
 The key to search a mapped data.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="DataControlGetValueSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="DataControlErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the passed parameter is not available on data provider side or platform.
                </p></description>
                <description><p>
 with error type IOError, if a DB operation has failed.
                </p></description>
                <description><p>
 with error type NotFoundError, if the key cannot be found.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="updateValue" id="::DataControl::MappedDataControlConsumer::updateValue">
        <webidl>         void updateValue(unsigned long reqId, DOMString key, DOMString oldValue, DOMString newValue,
                          <ref>DataControlSuccessCallback</ref> successCallback,
                          optional <ref>DataControlErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the value associated with the specified key with a new value.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datacontrol.consumer
            </privilege>
            <Code>
 function successcb(id)
 {
     console.log(&quot;ok : reqid &quot; + id);
 }

 function errorcb(id, error)
 {
     console.log(&quot;error id : &quot; + id + &quot;, error msg : &quot; + error.message);
 }

 try {
     // Defines globalReqId before
     // Increases globalReqId for uniqueness
     globalReqId++;
     globalMappedConsumer.updateValue(globalReqId, &quot;tizen&quot;, &quot;samsung&quot;, &quot;intel&quot;, successcb, errorcb);
 } catch (err) {
     console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>So a developer should increase <em>reqId </em>value to ensure it is unique for each method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="key">
            <descriptive>
                <description><p>
 The key to search a mapped data.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="oldValue">
            <descriptive>
                <description><p>
 The value to update in values array mapped by the key.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="newValue">
            <descriptive>
                <description><p>
 The new value to replace in values array mapped by the key.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to invoke when the asynchronous call completes successfully.
                </p></description>
            </descriptive>
            <Type name="DataControlSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs.
                </p></description>
            </descriptive>
            <Type name="DataControlErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if parameter type is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the passed parameter is not available on data provider side or platform.
                </p></description>
                <description><p>
 with error type IOError, if a DB operation has failed.
                </p></description>
                <description><p>
 with error type NotFoundError, if the key cannot be found.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="DataControlSuccessCallback" id="::DataControl::DataControlSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlSuccessCallback {
        void onsuccess(unsigned long reqId);
    };</webidl>
      <descriptive>
          <brief>
 This interface provides a SuccessCallback for DataControlConsumerObject.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::DataControl::DataControlSuccessCallback::onsuccess">
        <webidl>        void onsuccess(unsigned long reqId);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DataControlErrorCallback" id="::DataControl::DataControlErrorCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlErrorCallback {
        void onerror(unsigned long reqId, <ref>WebAPIError</ref> error);
    };</webidl>
      <descriptive>
          <brief>
 This interface provides a ErrorCallback for DataControlConsumerObject.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onerror" id="::DataControl::DataControlErrorCallback::onerror">
        <webidl>        void onerror(unsigned long reqId, <ref>WebAPIError</ref> error);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="error">
            <Type name="WebAPIError"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DataControlInsertSuccessCallback" id="::DataControl::DataControlInsertSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlInsertSuccessCallback {
        void onsuccess(unsigned long reqId, long insertRowId);
    };</webidl>
      <descriptive>
          <brief>
 This interface provides a SuccessCallback for SQLDataControlConsumer.insert().
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::DataControl::DataControlInsertSuccessCallback::onsuccess">
        <webidl>        void onsuccess(unsigned long reqId, long insertRowId);</webidl>
        <descriptive>
            <brief>
 Called on success.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>so it is recommended to increase the  <em>reqId</em> value every time to guarantee the uniqueness.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="insertRowId">
            <descriptive>
                <description><p>
 The inserted row ID set by the data control provider if the specified providerResult is <var>true</var>, else <var>-1</var>.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DataControlSelectSuccessCallback" id="::DataControl::DataControlSelectSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlSelectSuccessCallback {
        void onsuccess(<ref>RowData</ref>[] rows, unsigned long reqId);
    };</webidl>
      <descriptive>
          <brief>
 This interface provides a SuccessCallback for SQLDataControlConsumer.select().
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::DataControl::DataControlSelectSuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>RowData</ref>[] rows, unsigned long reqId);</webidl>
        <descriptive>
            <brief>
 Called on success.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="rows">
            <descriptive>
                <description><p>
 This attribute holds rows of SQL selection results from another application.<br/>The array operation of rows would be different from general javascript array behavior depends on platform implementation. For example, Array.isArray(rows) returns <em>false</em>.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="RowData"/>
            </Type>
          </Argument>
          <Argument name="reqId">
            <descriptive>
                <description><p>
 A unique identifier for the current operation.<br/>so it is recommended to increase the  <em>reqId</em> value every time to guarantee the uniqueness.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="DataControlGetValueSuccessCallback" id="::DataControl::DataControlGetValueSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface DataControlGetValueSuccessCallback {
        void onsuccess(DOMString[] values, unsigned long reqid);
    };</webidl>
      <descriptive>
          <brief>
 This interface provides a SuccessCallback for MapDataControlConsumer.getValue().
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::DataControl::DataControlGetValueSuccessCallback::onsuccess">
        <webidl>        void onsuccess(DOMString[] values, unsigned long reqid);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="values">
            <Type type="array">
              <Type type="DOMString"/>
            </Type>
          </Argument>
          <Argument name="reqid">
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Dictionary name="RowData" id="::DataControl::RowData">
      <webidl>    dictionary RowData {
        DOMString[] columns;
        DOMString[] values;
    };</webidl>
      <descriptive>
          <brief>
 The dictionary represents RowData holding 1 row of SQL selection results from another application.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <DictionaryMember name="columns" id="::DataControl::RowData::columns">
        <webidl>        DOMString[] columns;</webidl>
        <descriptive>
            <brief>
 An attribute to hold column names to select, update, and insert.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="values" id="::DataControl::RowData::values">
        <webidl>        DOMString[] values;</webidl>
        <descriptive>
            <brief>
 An attribute to hold values of columns to select, update, and insert.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
    </Dictionary>
  </Module>
  <Module name="DataSynchronization" id="::DataSynchronization">
    <webidl>module DataSynchronization {

  typedef DOMString SyncProfileId;

  enum SyncMode { &quot;MANUAL&quot;, &quot;PERIODIC&quot;, &quot;PUSH&quot; };

  enum SyncType { &quot;TWO_WAY&quot;, &quot;SLOW&quot;, &quot;ONE_WAY_FROM_CLIENT&quot;, &quot;REFRESH_FROM_CLIENT&quot;, &quot;ONE_WAY_FROM_SERVER&quot;, &quot;REFRESH_FROM_SERVER&quot; };

  enum SyncInterval { &quot;5_MINUTES&quot;, &quot;15_MINUTES&quot;, &quot;1_HOUR&quot;, &quot;4_HOURS&quot;, &quot;12_HOURS&quot;, &quot;1_DAY&quot;, &quot;1_WEEK&quot;, &quot;1_MONTH&quot; };

  enum SyncServiceType { &quot;CONTACT&quot;, &quot;EVENT&quot; };

  enum SyncStatus { &quot;SUCCESS&quot;, &quot;FAIL&quot;, &quot;STOP&quot;, &quot;NONE&quot; };

  [NoInterfaceObject] interface DataSynchronizationManagerObject {
    readonly attribute <ref>DataSynchronizationManager</ref> datasync;
  };

  <ref>Tizen</ref> implements <ref>DataSynchronizationManagerObject</ref>;

  [Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode),
  Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode, <ref>SyncType</ref> type),
  Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode, <ref>SyncInterval</ref> interval)]
  interface SyncInfo {
    attribute DOMString url;

    attribute DOMString id;

    attribute DOMString password;

    attribute <ref>SyncMode</ref> mode;

    attribute <ref>SyncType</ref>? type;

    attribute <ref>SyncInterval</ref>? interval;
  };

  [Constructor(boolean enable, <ref>SyncServiceType</ref> serviceType, DOMString serverDatabaseUri, optional DOMString? id, optional DOMString? password)]
  interface SyncServiceInfo {
    attribute boolean enable;

    attribute <ref>SyncServiceType</ref> serviceType;

    attribute DOMString serverDatabaseUri;

    attribute DOMString? id;

    attribute DOMString? password;
  };

  [Constructor(DOMString profileName, <ref>SyncInfo</ref> syncInfo, optional <ref>SyncServiceInfo</ref>[]? serviceInfo)]
  interface SyncProfileInfo {
    readonly attribute <ref>SyncProfileId</ref> profileId;

    attribute DOMString profileName;

    attribute <ref>SyncInfo</ref> syncInfo;

    attribute <ref>SyncServiceInfo</ref>[]? serviceInfo;
  };

  [NoInterfaceObject] interface SyncStatistics {
    readonly attribute <ref>SyncStatus</ref> syncStatus;

    readonly attribute <ref>SyncServiceType</ref> serviceType;

    readonly attribute Date lastSyncTime;

    readonly attribute unsigned long serverToClientTotal;

    readonly attribute unsigned long serverToClientAdded;

    readonly attribute unsigned long serverToClientUpdated;

    readonly attribute unsigned long serverToClientRemoved;

    readonly attribute unsigned long clientToServerTotal;

    readonly attribute unsigned long clientToServerAdded;

    readonly attribute unsigned long clientToServerUpdated;

    readonly attribute unsigned long clientToServerRemoved;
  };

  [NoInterfaceObject] interface DataSynchronizationManager {
    void add(<ref>SyncProfileInfo</ref> profile) raises(<ref>WebAPIException</ref>);

    void update(<ref>SyncProfileInfo</ref> profile) raises(<ref>WebAPIException</ref>);

    void remove(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);

    long getMaxProfilesNum() raises(<ref>WebAPIException</ref>);

    unsigned long getProfilesNum() raises(<ref>WebAPIException</ref>);

    <ref>SyncProfileInfo</ref> get(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);

    <ref>SyncProfileInfo</ref>[] getAll() raises(<ref>WebAPIException</ref>);

    void startSync(<ref>SyncProfileId</ref> profileId, optional <ref>SyncProgressCallback</ref>? progressCallback) raises(<ref>WebAPIException</ref>);

    void stopSync(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);

    <ref>SyncStatistics</ref>[] getLastSyncStatistics(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);
  };

  [Callback, NoInterfaceObject] interface SyncProgressCallback {
    void onprogress(<ref>SyncProfileId</ref> profileId, <ref>SyncServiceType</ref> serviceType, boolean isFromServer, unsigned long totalPerService, unsigned long syncedPerService);

    void oncompleted(<ref>SyncProfileId</ref> profileId);

    void onstopped(<ref>SyncProfileId</ref> profileId);

    void onfailed(<ref>SyncProfileId</ref> profileId, <ref>WebAPIError</ref> error);
  };
};</webidl>
    <descriptive>
        <brief>
 This API provides methods to synchronize contact and event data to the server using the OMA DS 1.2 protocol.
To know the details of this specification, visit <a href="http://www.openmobilealliance.org">OMA web page</a>. And for more information on the DataSync features, see <a href="../../org.tizen.web.appprogramming/html/guide/social_guide/datasync.htm">Data Synchronization Guide</a>.
        </brief>
        <version>
 2.1
        </version>
    </descriptive>
    <Typedef name="SyncProfileId" id="::DataSynchronization::SyncProfileId">
      <webidl>  typedef DOMString SyncProfileId;</webidl>
      <descriptive>
          <brief>
 An attribute to uniquely identify a sync profile.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Enum name="SyncMode" id="::DataSynchronization::SyncMode">
      <webidl>  enum SyncMode { &quot;MANUAL&quot;, &quot;PERIODIC&quot;, &quot;PUSH&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the supported synchronization modes.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
MANUAL - Indicates that the synchronization starts by manual trigger. The sync type should be specified. The default value is <em>TWO_WAY</em>.            </li>
            <li>
PERIODIC - Indicates that the synchronization starts automatically by a preset period. The sync interval should be provided.            </li>
            <li>
PUSH - Indicates that the synchronization starts automatically when changes are made. The sync type is set to <em>TWO_WAY</em>. The synchronization can be triggered by the server based on the standard SAN(Server Alerted Notification) sync type.            </li>
          </ul>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="MANUAL">
        <webidl> &quot;MANUAL</webidl>
      </EnumValue>
      <EnumValue stringvalue="PERIODIC">
        <webidl> &quot;PERIODIC</webidl>
      </EnumValue>
      <EnumValue stringvalue="PUSH">
        <webidl> &quot;PUSH</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SyncType" id="::DataSynchronization::SyncType">
      <webidl>  enum SyncType { &quot;TWO_WAY&quot;, &quot;SLOW&quot;, &quot;ONE_WAY_FROM_CLIENT&quot;, &quot;REFRESH_FROM_CLIENT&quot;, &quot;ONE_WAY_FROM_SERVER&quot;, &quot;REFRESH_FROM_SERVER&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the supported synchronization types.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
TWO_WAY - Indicates a normal sync type in which the client and the server exchange information about modified data in these devices.            </li>
            <li>
SLOW - Indicates a form of two-way sync in which the client and the server exchange all the data from their database. This type of sync is used for the first sync, or after a synchronization failure.            </li>
            <li>
ONE_WAY_FROM_CLIENT - Indicates a sync type in which the client sends its modifications to the server but the server does not send its modifications back to the client.            </li>
            <li>
REFRESH_FROM_CLIENT - Indicates a sync type in which the client sends all its data from a database to the server (backup). The server is then expected to replace all data in the target database with the data received from the client.            </li>
            <li>
ONE_WAY_FROM_SERVER - Indicates a sync type in which the client gets all modifications from the server but the client does not send its modifications to the server.            </li>
            <li>
REFRESH_FROM_SERVER - Indicates a sync type in which the server sends all its data from a database to the client (restore). The client is then expected to replace all data in the target database with the data received from the server.            </li>
          </ul>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="TWO_WAY">
        <webidl> &quot;TWO_WAY</webidl>
      </EnumValue>
      <EnumValue stringvalue="SLOW">
        <webidl> &quot;SLOW</webidl>
      </EnumValue>
      <EnumValue stringvalue="ONE_WAY_FROM_CLIENT">
        <webidl> &quot;ONE_WAY_FROM_CLIENT</webidl>
      </EnumValue>
      <EnumValue stringvalue="REFRESH_FROM_CLIENT">
        <webidl> &quot;REFRESH_FROM_CLIENT</webidl>
      </EnumValue>
      <EnumValue stringvalue="ONE_WAY_FROM_SERVER">
        <webidl> &quot;ONE_WAY_FROM_SERVER</webidl>
      </EnumValue>
      <EnumValue stringvalue="REFRESH_FROM_SERVER">
        <webidl> &quot;REFRESH_FROM_SERVER</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SyncInterval" id="::DataSynchronization::SyncInterval">
      <webidl>  enum SyncInterval { &quot;5_MINUTES&quot;, &quot;15_MINUTES&quot;, &quot;1_HOUR&quot;, &quot;4_HOURS&quot;, &quot;12_HOURS&quot;, &quot;1_DAY&quot;, &quot;1_WEEK&quot;, &quot;1_MONTH&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the supported synchronization intervals.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
5_MINUTES - Indicates a time period of 5 minutes.            </li>
            <li>
15_MINUTES - Indicates a time period of 15 minutes.            </li>
            <li>
1_HOUR - Indicates a time period of 1 hour.            </li>
            <li>
4_HOURS - Indicates a time period of 4 hours.            </li>
            <li>
12_HOURS - Indicates a time period of 12 hours.            </li>
            <li>
1_DAY - Indicates a time period of 1 day.            </li>
            <li>
1_WEEK - Indicates a time period of 1 week.            </li>
            <li>
1_MONTH - Indicates a time period of 1 month.            </li>
          </ul>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="5_MINUTES">
        <webidl> &quot;5_MINUTES</webidl>
      </EnumValue>
      <EnumValue stringvalue="15_MINUTES">
        <webidl> &quot;15_MINUTES</webidl>
      </EnumValue>
      <EnumValue stringvalue="1_HOUR">
        <webidl> &quot;1_HOUR</webidl>
      </EnumValue>
      <EnumValue stringvalue="4_HOURS">
        <webidl> &quot;4_HOURS</webidl>
      </EnumValue>
      <EnumValue stringvalue="12_HOURS">
        <webidl> &quot;12_HOURS</webidl>
      </EnumValue>
      <EnumValue stringvalue="1_DAY">
        <webidl> &quot;1_DAY</webidl>
      </EnumValue>
      <EnumValue stringvalue="1_WEEK">
        <webidl> &quot;1_WEEK</webidl>
      </EnumValue>
      <EnumValue stringvalue="1_MONTH">
        <webidl> &quot;1_MONTH</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SyncServiceType" id="::DataSynchronization::SyncServiceType">
      <webidl>  enum SyncServiceType { &quot;CONTACT&quot;, &quot;EVENT&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the supported synchronization service type of the device.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
CONTACT - Indicates the device contact records.            </li>
            <li>
EVENT - Indicates the device calendar event records.            </li>
          </ul>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="CONTACT">
        <webidl> &quot;CONTACT</webidl>
      </EnumValue>
      <EnumValue stringvalue="EVENT">
        <webidl> &quot;EVENT</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SyncStatus" id="::DataSynchronization::SyncStatus">
      <webidl>  enum SyncStatus { &quot;SUCCESS&quot;, &quot;FAIL&quot;, &quot;STOP&quot;, &quot;NONE&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the last sync statuses.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
SUCCESS - Indicates the sync is successful.            </li>
            <li>
FAIL - Indicates the sync has failed.            </li>
            <li>
STOP - Indicates the sync has been stopped by user's action.            </li>
            <li>
NONE - Indicates the sync was never performed.            </li>
          </ul>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="SUCCESS">
        <webidl> &quot;SUCCESS</webidl>
      </EnumValue>
      <EnumValue stringvalue="FAIL">
        <webidl> &quot;FAIL</webidl>
      </EnumValue>
      <EnumValue stringvalue="STOP">
        <webidl> &quot;STOP</webidl>
      </EnumValue>
      <EnumValue stringvalue="NONE">
        <webidl> &quot;NONE</webidl>
      </EnumValue>
    </Enum>
    <Interface name="DataSynchronizationManagerObject" id="::DataSynchronization::DataSynchronizationManagerObject">
      <webidl>  [NoInterfaceObject] interface DataSynchronizationManagerObject {
    readonly attribute <ref>DataSynchronizationManager</ref> datasync;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the default data synchronization manager that is instantiated by the <em>Tizen </em>object.
There will be a <em>tizen.datasync</em> object that allows access to the functionality of the DataSynchronization API.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="datasync" id="::DataSynchronization::DataSynchronizationManagerObject::datasync">
        <webidl>    readonly attribute <ref>DataSynchronizationManager</ref> datasync;</webidl>
        <Type name="DataSynchronizationManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="DataSynchronizationManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>DataSynchronizationManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="SyncInfo" id="::DataSynchronization::SyncInfo">
      <webidl>  [Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode),
  Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode, <ref>SyncType</ref> type),
  Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode, <ref>SyncInterval</ref> interval)]
  interface SyncInfo {
    attribute DOMString url;

    attribute DOMString id;

    attribute DOMString password;

    attribute <ref>SyncMode</ref> mode;

    attribute <ref>SyncType</ref>? type;

    attribute <ref>SyncInterval</ref>? interval;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the sync information.
          </brief>
          <version>
 2.1
          </version>
          <remark>
 The <em>MANUAL</em> sync mode accepts the sync type and the <em>PERIODIC</em> mode accepts the sync interval, whereas the <em>PUSH</em> mode does not accept any additional parameters.
          </remark>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode)</webidl>
          <ArgumentList>
            <Argument name="url">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="id">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="password">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="mode">
              <Type name="SyncMode"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>  Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode, <ref>SyncType</ref> type)</webidl>
          <ArgumentList>
            <Argument name="url">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="id">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="password">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="mode">
              <Type name="SyncMode"/>
            </Argument>
            <Argument name="type">
              <Type name="SyncType"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>  Constructor(DOMString url, DOMString id, DOMString password, <ref>SyncMode</ref> mode, <ref>SyncInterval</ref> interval)</webidl>
          <ArgumentList>
            <Argument name="url">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="id">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="password">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="mode">
              <Type name="SyncMode"/>
            </Argument>
            <Argument name="interval">
              <Type name="SyncInterval"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="url" id="::DataSynchronization::SyncInfo::url">
        <webidl>    attribute DOMString url;</webidl>
        <descriptive>
            <brief>
 An attribute to store the URL of the sync server.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="id" id="::DataSynchronization::SyncInfo::id">
        <webidl>    attribute DOMString id;</webidl>
        <descriptive>
            <brief>
 An attribute to store the login ID for the sync server.
            </brief>
           <description>
            <p>
When an attempt to retrieve the saved value is made, it will return <var>null</var> to prevent any compromise on the privacy of the login ID.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="password" id="::DataSynchronization::SyncInfo::password">
        <webidl>    attribute DOMString password;</webidl>
        <descriptive>
            <brief>
 An attribute to store the login password to the sync server.
            </brief>
           <description>
            <p>
When an attempt to retrieve the saved value is made, it will return <var>null</var> to prevent any compromise on the privacy of the login password.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="mode" id="::DataSynchronization::SyncInfo::mode">
        <webidl>    attribute <ref>SyncMode</ref> mode;</webidl>
        <descriptive>
            <brief>
 An attribute to store the sync mode.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="SyncMode"/>
      </Attribute>
      <Attribute name="type" id="::DataSynchronization::SyncInfo::type">
        <webidl>    attribute <ref>SyncType</ref>? type;</webidl>
        <descriptive>
            <brief>
 An attribute to store the sync type.
            </brief>
           <description>
            <p>
This attribute is used when the sync mode is set to <em>MANUAL</em> option.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="SyncType" nullable="nullable"/>
      </Attribute>
      <Attribute name="interval" id="::DataSynchronization::SyncInfo::interval">
        <webidl>    attribute <ref>SyncInterval</ref>? interval;</webidl>
        <descriptive>
            <brief>
 An attribute to store the sync interval.
            </brief>
           <description>
            <p>
This attribute is used when the sync mode is set to <em>PERIODIC</em> option.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="SyncInterval" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="SyncServiceInfo" id="::DataSynchronization::SyncServiceInfo">
      <webidl>  [Constructor(boolean enable, <ref>SyncServiceType</ref> serviceType, DOMString serverDatabaseUri, optional DOMString? id, optional DOMString? password)]
  interface SyncServiceInfo {
    attribute boolean enable;

    attribute <ref>SyncServiceType</ref> serviceType;

    attribute DOMString serverDatabaseUri;

    attribute DOMString? id;

    attribute DOMString? password;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the sync service information.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(boolean enable, <ref>SyncServiceType</ref> serviceType, DOMString serverDatabaseUri, optional DOMString? id, optional DOMString? password)</webidl>
          <ArgumentList>
            <Argument name="enable">
              <Type type="boolean"/>
            </Argument>
            <Argument name="serviceType">
              <Type name="SyncServiceType"/>
            </Argument>
            <Argument name="serverDatabaseUri">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="id">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="password">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="enable" id="::DataSynchronization::SyncServiceInfo::enable">
        <webidl>    attribute boolean enable;</webidl>
        <descriptive>
            <brief>
 An attribute to enable or disable a service category for sync.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="serviceType" id="::DataSynchronization::SyncServiceInfo::serviceType">
        <webidl>    attribute <ref>SyncServiceType</ref> serviceType;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the sync service type.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="SyncServiceType"/>
      </Attribute>
      <Attribute name="serverDatabaseUri" id="::DataSynchronization::SyncServiceInfo::serverDatabaseUri">
        <webidl>    attribute DOMString serverDatabaseUri;</webidl>
        <descriptive>
            <brief>
 An attribute to store the sync service DB URI of the server.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="id" id="::DataSynchronization::SyncServiceInfo::id">
        <webidl>    attribute DOMString? id;</webidl>
        <descriptive>
            <brief>
 An attribute to store the sync service DB access ID to the server.
            </brief>
           <description>
            <p>
This is used only when the server requires a separate access right to each DB.
When an attempt to retrieve the saved value is made, it will return <var>null</var> to prevent any compromise on the privacy of the id.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="password" id="::DataSynchronization::SyncServiceInfo::password">
        <webidl>    attribute DOMString? password;</webidl>
        <descriptive>
            <brief>
 An attribute to store the sync service DB access password to the server.
            </brief>
           <description>
            <p>
This is used only when the server requires a separate access right to each DB.
When an attempt to retrieve the saved value is made, it will return <var>null</var> to prevent any compromise on the privacy of the password.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="SyncProfileInfo" id="::DataSynchronization::SyncProfileInfo">
      <webidl>  [Constructor(DOMString profileName, <ref>SyncInfo</ref> syncInfo, optional <ref>SyncServiceInfo</ref>[]? serviceInfo)]
  interface SyncProfileInfo {
    readonly attribute <ref>SyncProfileId</ref> profileId;

    attribute DOMString profileName;

    attribute <ref>SyncInfo</ref> syncInfo;

    attribute <ref>SyncServiceInfo</ref>[]? serviceInfo;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the sync profile information, based on which the synchronization is performed.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString profileName, <ref>SyncInfo</ref> syncInfo, optional <ref>SyncServiceInfo</ref>[]? serviceInfo)</webidl>
          <ArgumentList>
            <Argument name="profileName">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="syncInfo">
              <Type name="SyncInfo"/>
            </Argument>
            <Argument optional="optional" name="serviceInfo">
              <Type type="array" nullable="nullable">
                <Type name="SyncServiceInfo"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="profileId" id="::DataSynchronization::SyncProfileInfo::profileId">
        <webidl>    readonly attribute <ref>SyncProfileId</ref> profileId;</webidl>
        <descriptive>
            <brief>
 An attribute to store the unique identifier provided by the platform for a profile that has been successfully added.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="SyncProfileId"/>
      </Attribute>
      <Attribute name="profileName" id="::DataSynchronization::SyncProfileInfo::profileName">
        <webidl>    attribute DOMString profileName;</webidl>
        <descriptive>
            <brief>
 An attribute to store the profile name.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="syncInfo" id="::DataSynchronization::SyncProfileInfo::syncInfo">
        <webidl>    attribute <ref>SyncInfo</ref> syncInfo;</webidl>
        <descriptive>
            <brief>
 An attribute to store the sync info.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="SyncInfo"/>
      </Attribute>
      <Attribute name="serviceInfo" id="::DataSynchronization::SyncProfileInfo::serviceInfo">
        <webidl>    attribute <ref>SyncServiceInfo</ref>[]? serviceInfo;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the service info.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type name="SyncServiceInfo"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="SyncStatistics" id="::DataSynchronization::SyncStatistics">
      <webidl>  [NoInterfaceObject] interface SyncStatistics {
    readonly attribute <ref>SyncStatus</ref> syncStatus;

    readonly attribute <ref>SyncServiceType</ref> serviceType;

    readonly attribute Date lastSyncTime;

    readonly attribute unsigned long serverToClientTotal;

    readonly attribute unsigned long serverToClientAdded;

    readonly attribute unsigned long serverToClientUpdated;

    readonly attribute unsigned long serverToClientRemoved;

    readonly attribute unsigned long clientToServerTotal;

    readonly attribute unsigned long clientToServerAdded;

    readonly attribute unsigned long clientToServerUpdated;

    readonly attribute unsigned long clientToServerRemoved;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the sync statistics for a profile service.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="syncStatus" id="::DataSynchronization::SyncStatistics::syncStatus">
        <webidl>    readonly attribute <ref>SyncStatus</ref> syncStatus;</webidl>
        <descriptive>
            <brief>
 An attribute to store the last sync status for a corresponding service category.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="SyncStatus"/>
      </Attribute>
      <Attribute readonly="readonly" name="serviceType" id="::DataSynchronization::SyncStatistics::serviceType">
        <webidl>    readonly attribute <ref>SyncServiceType</ref> serviceType;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the sync service type.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="SyncServiceType"/>
      </Attribute>
      <Attribute readonly="readonly" name="lastSyncTime" id="::DataSynchronization::SyncStatistics::lastSyncTime">
        <webidl>    readonly attribute Date lastSyncTime;</webidl>
        <descriptive>
            <brief>
 An attribute to store the last sync time.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
      <Attribute readonly="readonly" name="serverToClientTotal" id="::DataSynchronization::SyncStatistics::serverToClientTotal">
        <webidl>    readonly attribute unsigned long serverToClientTotal;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the total number of items sent from the server to the client direction.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="serverToClientAdded" id="::DataSynchronization::SyncStatistics::serverToClientAdded">
        <webidl>    readonly attribute unsigned long serverToClientAdded;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the number of added items from the server to the client direction.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="serverToClientUpdated" id="::DataSynchronization::SyncStatistics::serverToClientUpdated">
        <webidl>    readonly attribute unsigned long serverToClientUpdated;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the number of updated items from the server to the client direction.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="serverToClientRemoved" id="::DataSynchronization::SyncStatistics::serverToClientRemoved">
        <webidl>    readonly attribute unsigned long serverToClientRemoved;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the number of removed items from the server to the client direction.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="clientToServerTotal" id="::DataSynchronization::SyncStatistics::clientToServerTotal">
        <webidl>    readonly attribute unsigned long clientToServerTotal;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the total number of items from the client to the server direction.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="clientToServerAdded" id="::DataSynchronization::SyncStatistics::clientToServerAdded">
        <webidl>    readonly attribute unsigned long clientToServerAdded;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the number of added items from the client to the server direction.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="clientToServerUpdated" id="::DataSynchronization::SyncStatistics::clientToServerUpdated">
        <webidl>    readonly attribute unsigned long clientToServerUpdated;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the number of updated items from the client to the server direction.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="clientToServerRemoved" id="::DataSynchronization::SyncStatistics::clientToServerRemoved">
        <webidl>    readonly attribute unsigned long clientToServerRemoved;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the number of removed items from the client to the server direction.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
    </Interface>
    <Interface name="DataSynchronizationManager" id="::DataSynchronization::DataSynchronizationManager">
      <webidl>  [NoInterfaceObject] interface DataSynchronizationManager {
    void add(<ref>SyncProfileInfo</ref> profile) raises(<ref>WebAPIException</ref>);

    void update(<ref>SyncProfileInfo</ref> profile) raises(<ref>WebAPIException</ref>);

    void remove(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);

    long getMaxProfilesNum() raises(<ref>WebAPIException</ref>);

    unsigned long getProfilesNum() raises(<ref>WebAPIException</ref>);

    <ref>SyncProfileInfo</ref> get(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);

    <ref>SyncProfileInfo</ref>[] getAll() raises(<ref>WebAPIException</ref>);

    void startSync(<ref>SyncProfileId</ref> profileId, optional <ref>SyncProgressCallback</ref>? progressCallback) raises(<ref>WebAPIException</ref>);

    void stopSync(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);

    <ref>SyncStatistics</ref>[] getLastSyncStatistics(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface allows managing profiles and synchronizing data between the server and the client device based on the stored profile information.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="add" id="::DataSynchronization::DataSynchronizationManager::add">
        <webidl>    void add(<ref>SyncProfileInfo</ref> profile) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a sync profile.
            </brief>
           <description>
            <p>
The profile ID is provided when the profile is successfully added.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> // Creates a sync info
 var syncInfo = new tizen.SyncInfo(&quot;http://example.com/sync&quot;, &quot;myId&quot;, &quot;myPassword&quot;, &quot;MANUAL&quot;, &quot;TWO_WAY&quot;);

 // Syncs both contacts and events
 var contactInfo = new tizen.SyncServiceInfo(true, &quot;CONTACT&quot;, &quot;serverContact&quot;);
 var eventInfo = new tizen.SyncServiceInfo(true, &quot;EVENT&quot;, &quot;serverEvent&quot;);
 var serviceInfo = [contactInfo, eventInfo];

 // Adds a profile to sync
 var profile = new tizen.SyncProfileInfo(&quot;MyProfile&quot;, syncInfo, serviceInfo);
 tizen.datasync.add(profile);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profile">
            <descriptive>
                <description><p>
 The sync profile information to add.
                </p></description>
            </descriptive>
            <Type name="SyncProfileInfo"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type QuotaExceededError, if the platform has already reached the maximum number of profiles.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="update" id="::DataSynchronization::DataSynchronizationManager::update">
        <webidl>    void update(<ref>SyncProfileInfo</ref> profile) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates an existing sync profile.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> // Retrieves and updates a profile
 var profile = tizen.datasync.get(profileId);

 profile.profileName = &quot;newProfileName&quot;;

 tizen.datasync.update(profile);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profile">
            <descriptive>
                <description><p>
 The sync profile information to update.
                </p></description>
            </descriptive>
            <Type name="SyncProfileInfo"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::DataSynchronization::DataSynchronizationManager::remove">
        <webidl>    void remove(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes an existing sync profile.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> // Removes a profile
 tizen.datasync.remove(profileId);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The sync profile ID to remove.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any saved profile.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getMaxProfilesNum" id="::DataSynchronization::DataSynchronizationManager::getMaxProfilesNum">
        <webidl>    long getMaxProfilesNum() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the maximum number of supported sync profiles on a platform.
Normally the platform sets a limitation on the number of supported profiles. It will return <var>0</var> or negative value if no limitation is set.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> // Gets the maximum number of supported profiles on the platform
 var numMaxProfiles = tizen.datasync.getMaxProfilesNum();
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The number of supported profiles on a platform.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getProfilesNum" id="::DataSynchronization::DataSynchronizationManager::getProfilesNum">
        <webidl>    unsigned long getProfilesNum() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the current number of sync profiles on a device.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> // Gets the present number of profiles on the device
 var numProfiles = tizen.datasync.getProfilesNum();
 </Code>
        </descriptive>
        <Type type="unsigned long">
          <descriptive>
              <description><p>
 unsigned long The current number of profiles on a device.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="get" id="::DataSynchronization::DataSynchronizationManager::get">
        <webidl>    <ref>SyncProfileInfo</ref> get(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the <em>SyncProfileInfo</em> object from a given profile ID.
            </brief>
           <description>
            <p>
The attempt to retrieve <em>SyncProfileInfo</em> doesn't get any confidential information such as the <em>password</em> of <em>SyncInfo</em> or <em>SyncServiceInfo</em> but instead will return <var>null</var>.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> // Gets the profile information with the given ID
 var profile = tizen.datasync.get(profileId);
 </Code>
        </descriptive>
        <Type name="SyncProfileInfo">
          <descriptive>
              <description><p>
 SyncProfileInfo The profile information of the given ID.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The ID to use to get the profile information.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any profile saved.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAll" id="::DataSynchronization::DataSynchronizationManager::getAll">
        <webidl>    <ref>SyncProfileInfo</ref>[] getAll() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the information of all sync profiles saved in a device.
            </brief>
           <description>
            <p>
An attempt to retrieve <em>SyncProfileInfo</em> doesn't get any confidential information such as the <em>password</em> of <em>SyncInfo</em> or <em>SyncServiceInfo</em> but instead will return <var>null</var>.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> // Gets the all profile information
 var profiles = tizen.datasync.getAll();
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 SyncProfileInfo[] The profile information array.
              </p></description>
          </descriptive>
          <Type name="SyncProfileInfo"/>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="startSync" id="::DataSynchronization::DataSynchronizationManager::startSync">
        <webidl>    void startSync(<ref>SyncProfileId</ref> profileId, optional <ref>SyncProgressCallback</ref>? progressCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Starts a sync operation with a given profile ID.
            </brief>
           <description>
            <p>
If the sync mode is set to <em>MANUAL</em>, the synchronization will not start automatically until this method is called. This method will work even in <em>PUSH</em> or <em>PERIODIC</em> mode.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> var profileId; //profileId obtained from SyncProfileInfo
 var syncCallback = {
   onprogress: function(profileId, serviceType, isFromServer, totalPerType, syncedPerType) {
     console.log('Total: ' + totalPerType + ', synced: ' + syncedPerType + ' for the sync type: ' + serviceType);
   },
   onfailed: function(profileId, error) {
      console.log('Failed with id: ' + profileId + ', error name: ' + error.name);
   }
 };

 // Starts the sync operation with the corresponding callbacks
 tizen.datasync.startSync(profileId, syncCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The profile ID with which to initiate the sync operation.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
          <Argument optional="optional" name="progressCallback">
            <descriptive>
                <description><p>
 The method to invoke when the sync operation progresses or an error occurs.
                </p></description>
            </descriptive>
            <Type name="SyncProgressCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any profile saved.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="stopSync" id="::DataSynchronization::DataSynchronizationManager::stopSync">
        <webidl>    void stopSync(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Stops an ongoing sync operation that is specified by the <em>profileId</em> parameter.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> var profileId; //profileId obtained from SyncProfileInfo
 // Stops the ongoing sync operation
 tizen.datasync.stopSync(profileId);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The ID of the ongoing sync operation to stop.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any profile saved.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getLastSyncStatistics" id="::DataSynchronization::DataSynchronizationManager::getLastSyncStatistics">
        <webidl>    <ref>SyncStatistics</ref>[] getLastSyncStatistics(<ref>SyncProfileId</ref> profileId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the sync statistics of a given profile ID.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/datasync
            </privilege>
            <Code> var profileId; //profileId obtained from SyncProfileInfo
 // Gets the sync statistics information with the given ID
 var statistics = tizen.datasync.getLastSyncStatistics(profileId);
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 SyncStatictics[] The sync statistics information of a given ID.
              </p></description>
          </descriptive>
          <Type name="SyncStatistics"/>
        </Type>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The ID to use to get the sync statistics.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any profile saved.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="SyncProgressCallback" id="::DataSynchronization::SyncProgressCallback">
      <webidl>  [Callback, NoInterfaceObject] interface SyncProgressCallback {
    void onprogress(<ref>SyncProfileId</ref> profileId, <ref>SyncServiceType</ref> serviceType, boolean isFromServer, unsigned long totalPerService, unsigned long syncedPerService);

    void oncompleted(<ref>SyncProfileId</ref> profileId);

    void onstopped(<ref>SyncProfileId</ref> profileId);

    void onfailed(<ref>SyncProfileId</ref> profileId, <ref>WebAPIError</ref> error);
  };</webidl>
      <descriptive>
          <brief>
 This interface defines progress notification callbacks for the ongoing sync operation.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onprogress" id="::DataSynchronization::SyncProgressCallback::onprogress">
        <webidl>    void onprogress(<ref>SyncProfileId</ref> profileId, <ref>SyncServiceType</ref> serviceType, boolean isFromServer, unsigned long totalPerService, unsigned long syncedPerService);</webidl>
        <descriptive>
            <brief>
 Called when a synchronization operation is started and progress is made.
            </brief>
           <description>
            <p>
The frequency of this callback invocation is dependent on the platform implementation.
Normally the packet size from a server affects it, that is, if the server sends a bigger packet containing many records in it, the platform will process it at once and invoke this callback less frequently.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The ID of the corresponding sync operation.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
          <Argument name="serviceType">
            <descriptive>
                <description><p>
 The sync service category type.
                </p></description>
            </descriptive>
            <Type name="SyncServiceType"/>
          </Argument>
          <Argument name="isFromServer">
            <descriptive>
                <description><p>
 The direction of the operation.<br/> If the direction of operation is from the server to the client, then value is<var> true</var>.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
          <Argument name="totalPerService">
            <descriptive>
                <description><p>
 The total number of records to synchronize for the current sync service type aggregating all operations.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
          <Argument name="syncedPerService">
            <descriptive>
                <description><p>
 The number of synchronized records for the current sync service type aggregating all operations.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="oncompleted" id="::DataSynchronization::SyncProgressCallback::oncompleted">
        <webidl>    void oncompleted(<ref>SyncProfileId</ref> profileId);</webidl>
        <descriptive>
            <brief>
 Called when the sync operation has completed.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The ID of the corresponding sync operation.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onstopped" id="::DataSynchronization::SyncProgressCallback::onstopped">
        <webidl>    void onstopped(<ref>SyncProfileId</ref> profileId);</webidl>
        <descriptive>
            <brief>
 Called when the sync operation is stopped by user.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The ID of the corresponding sync operation.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onfailed" id="::DataSynchronization::SyncProgressCallback::onfailed">
        <webidl>    void onfailed(<ref>SyncProfileId</ref> profileId, <ref>WebAPIError</ref> error);</webidl>
        <descriptive>
            <brief>
 Called when the sync operation fails.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="profileId">
            <descriptive>
                <description><p>
 The ID of the corresponding sync operation.
                </p></description>
            </descriptive>
            <Type name="SyncProfileId"/>
          </Argument>
          <Argument name="error">
            <descriptive>
                <description><p>
 The reason for the sync failure.
                </p></description>
            </descriptive>
            <Type name="WebAPIError"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Download" id="::Download">
    <webidl>module Download {
    typedef object DownloadHTTPHeaderFields;

    enum DownloadState { &quot;QUEUED&quot;, &quot;DOWNLOADING&quot;, &quot;PAUSED&quot;, &quot;CANCELED&quot;, &quot;COMPLETED&quot;, &quot;FAILED&quot; };

    enum DownloadNetworkType { &quot;CELLULAR&quot;, &quot;WIFI&quot;, &quot;ALL&quot; };

    [NoInterfaceObject] interface DownloadManagerObject {
        readonly attribute <ref>DownloadManager</ref> download;
    };
    <ref>Tizen</ref> implements <ref>DownloadManagerObject</ref>;

    [Constructor(DOMString url, optional DOMString? destination, optional DOMString? fileName, optional <ref>DownloadNetworkType</ref>? networkType, optional <ref>DownloadHTTPHeaderFields</ref>? httpHeader)]
    interface DownloadRequest {
        attribute DOMString url;

        attribute DOMString? destination;

        attribute DOMString? fileName;

        attribute <ref>DownloadNetworkType</ref>? networkType;

        attribute <ref>DownloadHTTPHeaderFields</ref>? httpHeader;
    };

   [NoInterfaceObject] interface DownloadManager {
       long start(<ref>DownloadRequest</ref> downloadRequest,
                    optional <ref>DownloadCallback</ref>? downloadCallback) raises(<ref>WebAPIException</ref>);

       void cancel(long downloadId) raises(<ref>WebAPIException</ref>);

       void pause(long downloadId) raises(<ref>WebAPIException</ref>);

       void resume(long downloadId) raises(<ref>WebAPIException</ref>);

       <ref>DownloadState</ref> getState(long downloadId) raises(<ref>WebAPIException</ref>);

       <ref>DownloadRequest</ref> getDownloadRequest(long downloadId) raises(<ref>WebAPIException</ref>);

       DOMString getMIMEType(long downloadId) raises(<ref>WebAPIException</ref>);

       void setListener(long downloadId, <ref>DownloadCallback</ref> downloadCallback) raises(<ref>WebAPIException</ref>);
   };

   [Callback, NoInterfaceObject] interface DownloadCallback {
       void onprogress(long downloadId, unsigned long long receivedSize, unsigned long long totalSize);

       void onpaused(long downloadId);

       void oncanceled(long downloadId);

       void oncompleted(long downloadId, DOMString fullPath);

       void onfailed(long downloadId, <ref>WebAPIError</ref> error);
   };
};</webidl>
    <descriptive>
        <brief>
 This API provides methods to asynchronously download the contents of a URL to a storage.
        </brief>
       <description>
        <p>
For more information on the Download features, see <a href="../../org.tizen.web.appprogramming/html/guide/content_guide/download.htm">Download Guide</a>.
        </p>
       </description>
        <version>
 2.0
        </version>
        <def-api-feature identifier="http://tizen.org/feature/network.wifi">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with Wi-Fi feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
        <def-api-feature identifier="http://tizen.org/feature/network.telephony">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with Cellular feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
    </descriptive>
    <Typedef name="DownloadHTTPHeaderFields" id="::Download::DownloadHTTPHeaderFields">
      <webidl>    typedef object DownloadHTTPHeaderFields;</webidl>
      <descriptive>
          <brief>
 A set of HTTP header fields.
          </brief>
         <description>
          <p>
The key / value type of each HTTP header field should be DOMString.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <Type type="object"/>
    </Typedef>
    <Enum name="DownloadState" id="::Download::DownloadState">
      <webidl>    enum DownloadState { &quot;QUEUED&quot;, &quot;DOWNLOADING&quot;, &quot;PAUSED&quot;, &quot;CANCELED&quot;, &quot;COMPLETED&quot;, &quot;FAILED&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator to indicate the state of a download operation.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
QUEUED - Indicates that the download operation is listed in a queue.            </li>
            <li>
DOWNLOADING - Indicates that the download operation is in progress.            </li>
            <li>
PAUSED - Indicates that the download operation is in a paused state by user request.            </li>
            <li>
CANCELED - Indicates that the download operation is canceled by user request.            </li>
            <li>
COMPLETED - Indicates that the download operation is in a completed state.            </li>
            <li>
FAILED - Indicates that the download operation has failed due to some reasons.            </li>
          </ul>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="QUEUED">
        <webidl> &quot;QUEUED</webidl>
      </EnumValue>
      <EnumValue stringvalue="DOWNLOADING">
        <webidl> &quot;DOWNLOADING</webidl>
      </EnumValue>
      <EnumValue stringvalue="PAUSED">
        <webidl> &quot;PAUSED</webidl>
      </EnumValue>
      <EnumValue stringvalue="CANCELED">
        <webidl> &quot;CANCELED</webidl>
      </EnumValue>
      <EnumValue stringvalue="COMPLETED">
        <webidl> &quot;COMPLETED</webidl>
      </EnumValue>
      <EnumValue stringvalue="FAILED">
        <webidl> &quot;FAILED</webidl>
      </EnumValue>
    </Enum>
    <Enum name="DownloadNetworkType" id="::Download::DownloadNetworkType">
      <webidl>    enum DownloadNetworkType { &quot;CELLULAR&quot;, &quot;WIFI&quot;, &quot;ALL&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator to indicate the network type.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
CELLULAR - Indicates that the download operation is allowed in the cellular network only.            </li>
            <li>
WIFI - Indicates that the download operation is allowed in the Wi-Fi network only.            </li>
            <li>
ALL - Indicates that the download operation is allowed in all network types.            </li>
          </ul>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="CELLULAR">
        <webidl> &quot;CELLULAR</webidl>
      </EnumValue>
      <EnumValue stringvalue="WIFI">
        <webidl> &quot;WIFI</webidl>
      </EnumValue>
      <EnumValue stringvalue="ALL">
        <webidl> &quot;ALL</webidl>
      </EnumValue>
    </Enum>
    <Interface name="DownloadManagerObject" id="::Download::DownloadManagerObject">
      <webidl>    [NoInterfaceObject] interface DownloadManagerObject {
        readonly attribute <ref>DownloadManager</ref> download;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines the default download manager that is instantiated by the <em>Tizen </em>object.
There will be a <em>tizen.download </em>object that allows access to the functionality of the Download API.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="download" id="::Download::DownloadManagerObject::download">
        <webidl>        readonly attribute <ref>DownloadManager</ref> download;</webidl>
        <Type name="DownloadManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="DownloadManagerObject">
      <webidl>    <ref>Tizen</ref> implements <ref>DownloadManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="DownloadRequest" id="::Download::DownloadRequest">
      <webidl>    [Constructor(DOMString url, optional DOMString? destination, optional DOMString? fileName, optional <ref>DownloadNetworkType</ref>? networkType, optional <ref>DownloadHTTPHeaderFields</ref>? httpHeader)]
    interface DownloadRequest {
        attribute DOMString url;

        attribute DOMString? destination;

        attribute DOMString? fileName;

        attribute <ref>DownloadNetworkType</ref>? networkType;

        attribute <ref>DownloadHTTPHeaderFields</ref>? httpHeader;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines the download request object.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString url, optional DOMString? destination, optional DOMString? fileName, optional <ref>DownloadNetworkType</ref>? networkType, optional <ref>DownloadHTTPHeaderFields</ref>? httpHeader)</webidl>
          <ArgumentList>
            <Argument name="url">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="destination">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="fileName">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="networkType">
              <Type name="DownloadNetworkType" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="httpHeader">
              <Type name="DownloadHTTPHeaderFields" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="url" id="::Download::DownloadRequest::url">
        <webidl>        attribute DOMString url;</webidl>
        <descriptive>
            <brief>
 An attribute to store the URL of the object to download.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="destination" id="::Download::DownloadRequest::destination">
        <webidl>        attribute DOMString? destination;</webidl>
        <descriptive>
            <brief>
 An attribute to store the folder path of the destination folder to which a requested file object will be downloaded.
            </brief>
           <description>
            <p>
If the destination is not specified or an empty string, the file will be downloaded to the default storage: &quot;Downloads&quot;. For more information, see <a href="../../org.tizen.web.device.apireference/tizen/filesystem.html">Filesystem API</a>.
            </p>
            <p>
The default value is an empty string.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="fileName" id="::Download::DownloadRequest::fileName">
        <webidl>        attribute DOMString? fileName;</webidl>
        <descriptive>
            <brief>
 An attribute to store the file name for the specified URL.
            </brief>
           <description>
            <p>
If the file name is not given or an empty string, the original file name from URL is used.
            </p>
            <p>
The default value is an empty string.
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="networkType" id="::Download::DownloadRequest::networkType">
        <webidl>        attribute <ref>DownloadNetworkType</ref>? networkType;</webidl>
        <descriptive>
            <brief>
 An attribute to store the allowed network type.
            </brief>
           <description>
            <p>
If the network type is not given, all network type are allowed.
            </p>
            <p>
The default value is &quot;ALL&quot;.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="DownloadNetworkType" nullable="nullable"/>
      </Attribute>
      <Attribute name="httpHeader" id="::Download::DownloadRequest::httpHeader">
        <webidl>        attribute <ref>DownloadHTTPHeaderFields</ref>? httpHeader;</webidl>
        <descriptive>
            <brief>
 An attribute to store extra HTTP header fields.
            </brief>
           <description>
            <p>
For more information about HTTP header fields, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2">RFC-2616</a>            </p>
            <p>
The default value is an empty object.
            </p>
           </description>
            <Code> var req = new tizen.DownloadRequest(&quot;http://download.tizen.org/tools/README.txt&quot;);
 req.httpHeader[&quot;Pragma&quot;] = &quot;no-cache&quot;;
 req.httpHeader[&quot;Cookie&quot;] = &quot;version=1; Skin=new&quot;;
 req.httpHeader[&quot;X-Agent&quot;] = &quot;Tizen Sample App&quot;;
 </Code>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="DownloadHTTPHeaderFields" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="DownloadManager" id="::Download::DownloadManager">
      <webidl>   [NoInterfaceObject] interface DownloadManager {
       long start(<ref>DownloadRequest</ref> downloadRequest,
                    optional <ref>DownloadCallback</ref>? downloadCallback) raises(<ref>WebAPIException</ref>);

       void cancel(long downloadId) raises(<ref>WebAPIException</ref>);

       void pause(long downloadId) raises(<ref>WebAPIException</ref>);

       void resume(long downloadId) raises(<ref>WebAPIException</ref>);

       <ref>DownloadState</ref> getState(long downloadId) raises(<ref>WebAPIException</ref>);

       <ref>DownloadRequest</ref> getDownloadRequest(long downloadId) raises(<ref>WebAPIException</ref>);

       DOMString getMIMEType(long downloadId) raises(<ref>WebAPIException</ref>);

       void setListener(long downloadId, <ref>DownloadCallback</ref> downloadCallback) raises(<ref>WebAPIException</ref>);
   };</webidl>
      <descriptive>
          <brief>
 This interface handles requests for downloading. Each step of download operation will be informed through callbacks.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="start" id="::Download::DownloadManager::start">
        <webidl>       long start(<ref>DownloadRequest</ref> downloadRequest,
                    optional <ref>DownloadCallback</ref>? downloadCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Starts a download operation with the specified URL information.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/download
            </privilege>
            <Code> var listener = {
   onprogress: function(id, receivedSize, totalSize) {
     console.log('Received with id: ' + id + ', ' + receivedSize + '/' + totalSize);
   },
   onpaused: function(id) {
     console.log('Paused with id: ' + id);
   },
   oncanceled: function(id) {
     console.log('Canceled with id: ' + id);
   },
   oncompleted: function(id, fullPath) {
     console.log('Completed with id: ' + id + ', full path: ' + fullPath);
   },
   onfailed: function(id, error) {
     console.log('Failed with id: ' + id + ', error name: ' + error.name);
   }
 };

 // Starts downloading of the file from the Web with the corresponding callbacks.
 var downloadRequest = new tizen.DownloadRequest(&quot;http://download.tizen.org/tools/README.txt&quot;, &quot;documents&quot;);
 downloadId = tizen.download.start(downloadRequest, listener);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long An identifier for each download operation.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="downloadRequest">
            <descriptive>
                <description><p>
 The URL and destination information of the object to download.
                </p></description>
            </descriptive>
            <Type name="DownloadRequest"/>
          </Argument>
          <Argument optional="optional" name="downloadCallback">
            <descriptive>
                <description><p>
 The method to invoke when the download state changes or an error occurs.
                </p></description>
            </descriptive>
            <Type name="DownloadCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="cancel" id="::Download::DownloadManager::cancel">
        <webidl>       void cancel(long downloadId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Cancels an ongoing download operation that is specified by the <em>downloadId</em> parameter.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Cancels the ongoing download operation with the specified id.
 tizen.download.cancel(downloadId);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID of the ongoing download operation to stop.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any download operation in progress.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="pause" id="::Download::DownloadManager::pause">
        <webidl>       void pause(long downloadId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Pauses an ongoing download operation that is specified by the <em>downloadId</em> parameter.
The paused download operation can be resumed later by the <em>resume()</em> method.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Pauses the ongoing download operation with the specified id.
 tizen.download.pause(downloadId);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID of the ongoing download operation to pause.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any download operation in progress.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="resume" id="::Download::DownloadManager::resume">
        <webidl>       void resume(long downloadId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Resumes a paused download operation that is specified by the <em>downloadId</em> parameter.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Resumes the paused download operation with the specified id.
 tizen.download.resume(downloadId);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID of the paused download operation to be resume.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any download operation in progress.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getState" id="::Download::DownloadManager::getState">
        <webidl>       <ref>DownloadState</ref> getState(long downloadId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the download state of an operation synchronously with the specified ID.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Gets the state of the download operation with the given id.
 var state = tizen.download.getState(downloadId);
 </Code>
        </descriptive>
        <Type name="DownloadState">
          <descriptive>
              <description><p>
 DownloadState The current download state of the specified ID.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID to get the current state of download operation.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match any download operation in progress.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getDownloadRequest" id="::Download::DownloadManager::getDownloadRequest">
        <webidl>       <ref>DownloadRequest</ref> getDownloadRequest(long downloadId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the DownloadRequest object from a given id.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Gets the download request information with the given id.
 var downloadRequest = tizen.download.getDownloadRequest(downloadId);
 </Code>
        </descriptive>
        <Type name="DownloadRequest">
          <descriptive>
              <description><p>
 DownloadRequest The download request information of the given id.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID to get the download request information.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match
any download operation in progress.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not
compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getMIMEType" id="::Download::DownloadManager::getMIMEType">
        <webidl>       DOMString getMIMEType(long downloadId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the MIME type of the downloaded file.
            </brief>
            <remark>
 This function will return a valid MIME type when the download operation has been started
and successfully retrieved the file header.
            </remark>
            <version>
 2.0
            </version>
            <Code> // Get the MIME type of the download operation with the given id.
 var MIMEtype = tizen.download.getMIMEType(downloadId);
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The MIME type of the downloaded file.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID to get the MIME type information.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match
any download operation in progress.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not
compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setListener" id="::Download::DownloadManager::setListener">
        <webidl>       void setListener(long downloadId, <ref>DownloadCallback</ref> downloadCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the download callback to the download operation of given id.
It's possible to change or register the listener of download operation using the saved id.
            </brief>
            <version>
 2.0
            </version>
            <Code> var listener = {
   onprogress: function(id, receivedSize, totalSize) {
     console.log('Received with id: ' + id + ', ' + receivedSize + '/' + totalSize);
   },
   onpaused: function(id) {
     console.log('Paused with id: ' + id);
   },
   oncanceled: function(id) {
     console.log('Canceled with id: ' + id);
   },
   oncompleted: function(id, fileName) {
     console.log('Completed with id: ' + id + ', file name: ' + fileName);
   },
   onfailed: function(id, error) {
     console.log('Failed with id: ' + id + ', error name: ' + error.name);
   }
 };

 // Start downloading the html file on the web with the corresponding callbacks.
 var downloadRequest = new tizen.DownloadRequest(&quot;http://download.tizen.org/tools/README.txt&quot;, &quot;documents&quot;);
 downloadId = tizen.download.start(downloadRequest);

 // Add the listener.
 tizen.download.setListener(downloadId, listener);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID to set the download callback.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
          <Argument name="downloadCallback">
            <descriptive>
                <description><p>
 The method to invoke when the download state changes or an error occurs.
                </p></description>
            </descriptive>
            <Type name="DownloadCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if the identifier does not match
any download operation in progress.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not
compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="DownloadCallback" id="::Download::DownloadCallback">
      <webidl>   [Callback, NoInterfaceObject] interface DownloadCallback {
       void onprogress(long downloadId, unsigned long long receivedSize, unsigned long long totalSize);

       void onpaused(long downloadId);

       void oncanceled(long downloadId);

       void oncompleted(long downloadId, DOMString fullPath);

       void onfailed(long downloadId, <ref>WebAPIError</ref> error);
   };</webidl>
      <descriptive>
          <brief>
 This interface defines notification callbacks for the download state change or progress.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onprogress" id="::Download::DownloadCallback::onprogress">
        <webidl>       void onprogress(long downloadId, unsigned long long receivedSize, unsigned long long totalSize);</webidl>
        <descriptive>
            <brief>
 Called when a download is successful and it called multiple times as the download progresses.
The interval between <em>onprogress()</em> callback is platform-dependent. When the download is started, the <em>receivedSize </em>can be <var>0</var>.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID of the corresponding download operation.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
          <Argument name="receivedSize">
            <descriptive>
                <description><p>
 The size of data received in bytes.
                </p></description>
            </descriptive>
            <Type type="unsigned long long"/>
          </Argument>
          <Argument name="totalSize">
            <descriptive>
                <description><p>
 The total size of data to receive in bytes.
                </p></description>
            </descriptive>
            <Type type="unsigned long long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onpaused" id="::Download::DownloadCallback::onpaused">
        <webidl>       void onpaused(long downloadId);</webidl>
        <descriptive>
            <brief>
 Called when the download operation is paused by the <em>pause() </em>method.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID of the corresponding download operation.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="oncanceled" id="::Download::DownloadCallback::oncanceled">
        <webidl>       void oncanceled(long downloadId);</webidl>
        <descriptive>
            <brief>
 Called when download is canceled by the <em>cancel() </em>method.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID of the corresponding download operation.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="oncompleted" id="::Download::DownloadCallback::oncompleted">
        <webidl>       void oncompleted(long downloadId, DOMString fullPath);</webidl>
        <descriptive>
            <brief>
 Called when the download operation is completed with the final full path.
If the same file name already exists in the destination, it is changed according to the platform policy and delivered in this callback.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID of the corresponding download operation.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
          <Argument name="fullPath">
            <descriptive>
                <description><p>
 The final full path for the downloaded file.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onfailed" id="::Download::DownloadCallback::onfailed">
        <webidl>       void onfailed(long downloadId, <ref>WebAPIError</ref> error);</webidl>
        <descriptive>
            <brief>
 Called when the download operation fails.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="downloadId">
            <descriptive>
                <description><p>
 The ID of the corresponding download operation.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
          <Argument name="error">
            <descriptive>
                <description><p>
 The reason for the download failure.
                </p></description>
            </descriptive>
            <Type name="WebAPIError"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Filesystem" id="::Filesystem">
    <webidl>module Filesystem {
  enum FileMode { &quot;r&quot;, &quot;rw&quot;, &quot;w&quot;, &quot;a&quot; };

  enum FileSystemStorageType { &quot;INTERNAL&quot;, &quot;EXTERNAL&quot; };

  enum FileSystemStorageState { &quot;MOUNTED&quot;, &quot;REMOVED&quot;, &quot;UNMOUNTABLE&quot; };

  [NoInterfaceObject] interface FileSystemManagerObject {
    readonly attribute <ref>FileSystemManager</ref> filesystem;
  };
  <ref>Tizen</ref> implements <ref>FileSystemManagerObject</ref>;

  [NoInterfaceObject] interface FileSystemManager {
    readonly attribute long maxPathLength;

    void resolve(DOMString location,
                 <ref>FileSuccessCallback</ref> onsuccess,
                 optional <ref>ErrorCallback</ref>? onerror,
                 optional <ref>FileMode</ref>? mode) raises(<ref>WebAPIException</ref>);

    void getStorage(DOMString label,
                    <ref>FileSystemStorageSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    void listStorages(<ref>FileSystemStorageArraySuccessCallback</ref> onsuccess,
                      optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    long addStorageStateChangeListener(<ref>FileSystemStorageSuccessCallback</ref> onsuccess,
                                       optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    void removeStorageStateChangeListener(long watchId) raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface FileSystemStorage {
    readonly attribute DOMString label;

    readonly attribute <ref>FileSystemStorageType</ref> type;

    readonly attribute <ref>FileSystemStorageState</ref> state;
  };

  [NoInterfaceObject] interface File {
    readonly attribute <ref>File</ref>? parent;

    readonly attribute boolean readOnly;

    readonly attribute boolean isFile;

    readonly attribute boolean isDirectory;

    readonly attribute Date? created;

    readonly attribute Date? modified;

    readonly attribute DOMString path;

    readonly attribute DOMString name;

    readonly attribute DOMString fullPath;

    readonly attribute unsigned long long fileSize;

    readonly attribute long length;

    DOMString toURI() raises(<ref>WebAPIException</ref>);

    void listFiles(<ref>FileArraySuccessCallback</ref> onsuccess,
                   optional <ref>ErrorCallback</ref>? onerror,
                   optional <ref>FileFilter</ref>? filter) raises(<ref>WebAPIException</ref>);

    void openStream(<ref>FileMode</ref> mode,
                    <ref>FileStreamSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror,
                    optional DOMString? encoding) raises(<ref>WebAPIException</ref>);

    void readAsText(<ref>FileStringSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror,
                    optional DOMString? encoding) raises(<ref>WebAPIException</ref>);

    void copyTo(DOMString originFilePath,
                DOMString destinationFilePath,
                boolean overwrite,
                optional <ref>SuccessCallback</ref>? onsuccess,
                optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    void moveTo(DOMString originFilePath,
                DOMString destinationFilePath,
                boolean overwrite,
                optional <ref>SuccessCallback</ref>? onsuccess,
                optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    <ref>File</ref> createDirectory(DOMString dirPath) raises(<ref>WebAPIException</ref>);

    <ref>File</ref> createFile(DOMString relativeFilePath) raises(<ref>WebAPIException</ref>);

    <ref>File</ref> resolve(DOMString filePath) raises(<ref>WebAPIException</ref>);

    void deleteDirectory(DOMString directoryPath,
                         boolean recursive,
                         optional <ref>SuccessCallback</ref>? onsuccess,
                         optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    void deleteFile(DOMString filePath,
                    optional <ref>SuccessCallback</ref>? onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);
  };


  dictionary FileFilter {
    DOMString name;

    Date startModified;

    Date endModified;

    Date startCreated;

    Date endCreated;
  };

  [NoInterfaceObject] interface FileStream {
    readonly attribute boolean eof;

    attribute long position setraises(<ref>WebAPIException</ref>);

    readonly attribute long bytesAvailable;

    void close();

    DOMString read(long charCount) raises(<ref>WebAPIException</ref>);

    octet[] readBytes(long byteCount) raises(<ref>WebAPIException</ref>);

    DOMString readBase64(long byteCount) raises(<ref>WebAPIException</ref>);

    void write(DOMString stringData) raises(<ref>WebAPIException</ref>);

    void writeBytes(octet[] byteData) raises(<ref>WebAPIException</ref>);

    void writeBase64(DOMString base64Data) raises(<ref>WebAPIException</ref>);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface FileSuccessCallback {
    void onsuccess(<ref>File</ref> file);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface FileSystemStorageArraySuccessCallback {
    void onsuccess(<ref>FileSystemStorage</ref>[] storages);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface FileSystemStorageSuccessCallback {
    void onsuccess(<ref>FileSystemStorage</ref> storage);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface FileStringSuccessCallback {
    void onsuccess(DOMString fileStr);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface FileStreamSuccessCallback {
    void onsuccess(<ref>FileStream</ref> filestream);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface FileArraySuccessCallback {
    void onsuccess(<ref>File</ref>[] files);
  };
};</webidl>
    <descriptive>
        <brief>
 This API provides access to a device's filesystem.
        </brief>
       <description>
        <p>
The filesystem is represented as an abstract collection of disjointed filesystem virtual
root locations, each corresponding to a specific location in the device
filesystem. The filesystem API exposes the hierarchies below these root
locations as a single virtual filesystem, but provides no access to other
parts of the device filesystem.
        </p>
        <p>
Each virtual root has a string name. Each file or directory within the virtual
filesystem is addressed using a fully-qualified path of the form:
<em>&#60;root name&#62;/&#60;path&#62;</em> where <em>&#60;rootname&#62;</em> is
the name of the virtual root and <em>&#60;path&#62;</em> is the path to the file or
directory relative to that root.
        </p>
        <p>
The following virtual roots MUST be supported:
        </p>
        <ul>
          <li>
images: the images location           </li>
          <li>
videos: the videos location           </li>
          <li>
music: the sounds location           </li>
          <li>
documents: the documents location           </li>
          <li>
downloads: the location for downloaded items           </li>
          <li>
ringtones: the location for ringtones (read-only location)           </li>
          <li>
wgt-package: the widget package location (read-only location)           </li>
          <li>
wgt-private: the widget private storage           </li>
          <li>
wgt-private-tmp: the widget private volatile storage area          </li>
        </ul>
        <p>
The file URI path is also supported. if you want to access other paths out of virtual root,
for example '/tmp/', 'file:///tmp' could be used as location parameter.
        </p>
        <p>
To access specific locations from those specified above, a file handle
must be retrieved using the filesystem.resolve call.
        </p>
        <p>
A file handle represents either a file or a directory. For a file, the
isFile attribute is <em>true</em>. For a directory, the isDirectory attribute
is <em>true</em>. A file can be opened for read and write operations, using a
FileStream handle. A list of files and sub-directories can be obtained from a
directory and a resolve method exists to resolve files or sub-directories
more conveniently than processing directory listings.
        </p>
        <p>
The implementation MUST support the use of the following
characters in file names:
        </p>
        <ul>
          <li>
Letters (azAZ)          </li>
          <li>
Numbers (0-9)          </li>
          <li>
Blank spaces          </li>
          <li>
Underscores (&quot;_&quot;)          </li>
          <li>
Hyphens (&quot;-&quot;)          </li>
          <li>
Periods (&quot;.&quot;)          </li>
        </ul>
        <p>
The implementation MAY support additional characters in file names,
depending on platform support.
        </p>
        <p>
The implementation MAY forbid the use of additional characters in file
names, depending on the platform. The use of the path separator &quot;/&quot;
in file names MUST NOT be allowed. The &quot;/&quot; character is used as the (path)
component separator.
        </p>
        <p>
Some other file name and path characteristics are platform-dependent,
for example, maximum path length, file name length, case sensitivity, additional
character support, etc. Therefore, it is recommended that you avoid any dependency
on aspects that cannot be supported across many platforms.
        </p>
        <p>
When a path is used to interact with the underlying filesystem,
the encoding used for the file path SHOULD be the platform default.
        </p>
        <p>
For more information on the Filesystem features, see <a href="../../org.tizen.web.appprogramming/html/guide/io_guide/filesystem.htm">File System Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
    </descriptive>
    <Enum name="FileMode" id="::Filesystem::FileMode">
      <webidl>  enum FileMode { &quot;r&quot;, &quot;rw&quot;, &quot;w&quot;, &quot;a&quot; };</webidl>
      <descriptive>
          <brief>
 The file mode provided when opening.
          </brief>
         <description>
          <p>
Value &quot;r&quot; to obtain read-only access, &quot;rw&quot; to obtain read and write
access, &quot;w&quot; to obtain write access and &quot;a&quot; for appending.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="r">
        <webidl> &quot;r</webidl>
      </EnumValue>
      <EnumValue stringvalue="rw">
        <webidl> &quot;rw</webidl>
      </EnumValue>
      <EnumValue stringvalue="w">
        <webidl> &quot;w</webidl>
      </EnumValue>
      <EnumValue stringvalue="a">
        <webidl> &quot;a</webidl>
      </EnumValue>
    </Enum>
    <Enum name="FileSystemStorageType" id="::Filesystem::FileSystemStorageType">
      <webidl>  enum FileSystemStorageType { &quot;INTERNAL&quot;, &quot;EXTERNAL&quot; };</webidl>
      <descriptive>
          <brief>
 The type of storage.
          </brief>
         <description>
          <ul>
            <li>
INTERNAL: Internal storage is storage that cannot be removed, such as a
flash memory.            </li>
            <li>
EXTERNAL: External storage is removable storage, such as a USB drive or
memory cards.            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="INTERNAL">
        <webidl> &quot;INTERNAL</webidl>
      </EnumValue>
      <EnumValue stringvalue="EXTERNAL">
        <webidl> &quot;EXTERNAL</webidl>
      </EnumValue>
    </Enum>
    <Enum name="FileSystemStorageState" id="::Filesystem::FileSystemStorageState">
      <webidl>  enum FileSystemStorageState { &quot;MOUNTED&quot;, &quot;REMOVED&quot;, &quot;UNMOUNTABLE&quot; };</webidl>
      <descriptive>
          <brief>
 The state of the storage.
          </brief>
         <description>
          <ul>
            <li>
MOUNTED: The device is mounted and can be browsed.            </li>
            <li>
REMOVED: The device was removed. This states only applies to external drives.            </li>
            <li>
UNMOUNTABLE: The device cannot be mounted due to an error.            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="MOUNTED">
        <webidl> &quot;MOUNTED</webidl>
      </EnumValue>
      <EnumValue stringvalue="REMOVED">
        <webidl> &quot;REMOVED</webidl>
      </EnumValue>
      <EnumValue stringvalue="UNMOUNTABLE">
        <webidl> &quot;UNMOUNTABLE</webidl>
      </EnumValue>
    </Enum>
    <Interface name="FileSystemManagerObject" id="::Filesystem::FileSystemManagerObject">
      <webidl>  [NoInterfaceObject] interface FileSystemManagerObject {
    readonly attribute <ref>FileSystemManager</ref> filesystem;
  };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated in the tizen object.
          </brief>
         <description>
          <p>
There will be a tizen.filesystem object that allows accessing the
functionality of the filesystem API.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="filesystem" id="::Filesystem::FileSystemManagerObject::filesystem">
        <webidl>    readonly attribute <ref>FileSystemManager</ref> filesystem;</webidl>
        <Type name="FileSystemManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="FileSystemManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>FileSystemManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="FileSystemManager" id="::Filesystem::FileSystemManager">
      <webidl>  [NoInterfaceObject] interface FileSystemManager {
    readonly attribute long maxPathLength;

    void resolve(DOMString location,
                 <ref>FileSuccessCallback</ref> onsuccess,
                 optional <ref>ErrorCallback</ref>? onerror,
                 optional <ref>FileMode</ref>? mode) raises(<ref>WebAPIException</ref>);

    void getStorage(DOMString label,
                    <ref>FileSystemStorageSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    void listStorages(<ref>FileSystemStorageArraySuccessCallback</ref> onsuccess,
                      optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    long addStorageStateChangeListener(<ref>FileSystemStorageSuccessCallback</ref> onsuccess,
                                       optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    void removeStorageStateChangeListener(long watchId) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The file system manager interface that provides access to the filesystem API.
          </brief>
         <description>
          <p>
This manager exposes the filesystem base API, and provides functionality, such as
determining root and default locations, resolving a given location
into a file handle, and registering filesystem listeners for
filesystem events.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> var documentsDir;
 function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     console.log(&quot;File Name is &quot; + files[i].name); // displays file name
   }

   var testFile = documentsDir.createFile(&quot;test.txt&quot;);

   if (testFile != null) {
     testFile.openStream(
       &quot;w&quot;,
       function(fs){
         fs.write(&quot;HelloWorld&quot;);
         fs.close();
       }, function(e){
         console.log(&quot;Error &quot; + e.message);
       }, &quot;UTF-8&quot;
     );
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message + &quot; occurred when listing the files in the selected folder&quot;);
 }

 tizen.filesystem.resolve(
   'documents',
   function(dir){
     documentsDir = dir;
     dir.listFiles(onsuccess, onerror);
   }, function(e){
     console.log(&quot;Error&quot; + e.message);
   }, &quot;rw&quot;
 );
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="maxPathLength" id="::Filesystem::FileSystemManager::maxPathLength">
        <webidl>    readonly attribute long maxPathLength;</webidl>
        <descriptive>
            <brief>
 Contains the platform-dependent maximum path length.
            </brief>
            <version>
 1.0
            </version>
            <Code> console.log(&quot;The maximum path length is &quot; + tizen.filesystem.maxPathLength);
 </Code>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Operation name="resolve" id="::Filesystem::FileSystemManager::resolve">
        <webidl>    void resolve(DOMString location,
                 <ref>FileSuccessCallback</ref> onsuccess,
                 optional <ref>ErrorCallback</ref>? onerror,
                 optional <ref>FileMode</ref>? mode) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Resolves a location to a file handle.
            </brief>
           <description>
            <p>
It validates and resolves the given location to a file handle.
If the operation completes successfully, the handle is returned
in the FileSuccessCallback.
A valid location is prefixed with a valid root or
default location and must address an existing,
accessible file or directory.
            </p>
            <p>
A location can contain virtual path like (<var>documents/some_file.txt</var>)
or it can be a file's URI (<var>file:///my_strange_path/some_file.png</var>).
            </p>
            <p>
The list of root locations that MUST be supported by a compliant
implementation are:
            </p>
            <ul>
              <li>
documents: Describes the default folder in which text documents
(such as pdf, doc...) are stored by default in the device. For example, in some
platforms it corresponds to the &quot;My Documents&quot; folder.              </li>
              <li>
images: Describes the default folder in which still images, like
pictures (such as jpg, gif, png, etc.), are stored in the
device by default. For example, in some platforms it corresponds to the &quot;My Images&quot;
folder.              </li>
              <li>
music: Describes the default folder in which sound clips (such as mp3,
aac, etc.) are stored in the device by default. For example, in some platforms it
corresponds to the &quot;My Music&quot; folder.              </li>
              <li>
videos: Describes the default folder in which video clips (such as
avi, mp4, etc.) are stored in the device by default. For example, in some platforms
it corresponds to the &quot;My Videos&quot; folder.              </li>
              <li>
downloads: Describes the default folder in which files downloaded
(such as by a browser, e-mail client, etc.) are stored by default in the
device. For example, in some platforms it corresponds to the &quot;Downloads&quot; folder.
              </li>
              <li>
ringtones: Describes the default folder in which ringtones (such as mp3, etc)
are stored by default in the device.               </li>
              <li>
wgt-package: Describes the read-only folder in which the content of
the widget file was extracted to.              </li>
              <li>
wgt-private: Describes a private folder in which a widget can
store information. This folder MUST be accessible only to the
widget. Other widgets or applications MUST NOT access the
information stored there.              </li>
              <li>
wgt-private-tmp: Describes a temporary, private folder in which a widget
can store data that is available during one widget execution
cycle. Content of this folder MAY be removed from this directory
when the widget is closed or the Web Runtime is restarted.
This folder MUST be accessible only to the widget. Other
widgets or applications MUST NOT have access to it.              </li>
            </ul>
            <p>
The mode parameter specifies whether the resulting File object
has read-only access (&quot;r&quot; access), read and write access (&quot;rw&quot; access),
append access (&quot;a&quot; access), or write access (&quot;w&quot; access)
to the root location containing directory tree.
Permission for the requested access is obtained from the security framework.
Once the resulting File object has access, access is inherited by
any other File objects derived from this instance without any
further reference to the security framework, as noted in
descriptions of certain methods of File.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.
For example, the mode is not valid (that is not &quot;r&quot;, &quot;rw&quot;, &quot;a&quot;, or &quot;w&quot;).              </li>
              <li>
NotFoundError: The location input argument does not correspond to a valid location.              </li>
              <li>
UnknownError: In any other error case.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> tizen.filesystem.resolve(
   'images',
   function(dir) {
     console.log(&quot;Mount point Name is &quot; +  dir.path);
   }, function(e) {
     console.log(&quot;Error: &quot; + e.message);
   }, &quot;r&quot;
 );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="location">
            <descriptive>
                <description><p>
 Location to resolve.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="onsuccess">
            <descriptive>
                <description><p>
 Called when the location has been.
successfully resolved, passing the newly created File object.
                </p></description>
            </descriptive>
            <Type name="FileSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="mode">
            <descriptive>
                <description><p>
 Optional string of value &quot;r&quot; to obtain read-only access,
&quot;rw&quot; to obtain read and write access, &quot;a&quot; to obtain append access,
or &quot;w&quot; to obtain write access to all files and
directories that can be reached from the File object passed
to onsuccess. Defaults to &quot;rw&quot; if absent or <em>null</em>.
                </p></description>
            </descriptive>
            <Type name="FileMode" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getStorage" id="::Filesystem::FileSystemManager::getStorage">
        <webidl>    void getStorage(DOMString label,
                    <ref>FileSystemStorageSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets information about a storage based on its label.
            </brief>
           <description>
            <p>
Get storage information based on its label (example: &quot;MyThumbDrive&quot;,
&quot;InternalFlash&quot;). The onsuccess will receive as input argument the data
structure containing additional information about the drive.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError: No drive was found with the given label.              </li>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError: In any other error case.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> function onStorage(storage) {
     // Do something
 }

 function onStorageError(e) {
 console.log(&quot;Storage not found!&quot; + e.message);
 }

 tizen.filesystem.getStorage(&quot;music&quot;, onStorage, onStorageError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="label">
            <descriptive>
                <description><p>
 Storage label.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="onsuccess">
            <descriptive>
                <description><p>
 Called when the list of storage is available,
passing the storage list to the callback.
                </p></description>
            </descriptive>
            <Type name="FileSystemStorageSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="listStorages" id="::Filesystem::FileSystemManager::listStorages">
        <webidl>    void listStorages(<ref>FileSystemStorageArraySuccessCallback</ref> onsuccess,
                      optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Lists the available storages on the device.
            </brief>
           <description>
            <p>
Get the list of available internal and external storage devices. The
onsuccess will receive as input argument a list of the data
structure containing additional information about each drive found.
Can get storages would have a label named as 'internal0', virtual roots (images, documents,...), 'removable1', 'removable2'.
'removable1' label would be used to resolve sdcard and 'removable2' label would be used to resolve usb host, if supported.
The vfat filesystem used widly as sdcard filesystem is not case-sensitive.
If you want to handle the file on sdcard, you need to consider case-sensitive filenames are regarded as same name.
            </p>
            <p>
Labels can be different, depends on platform implementation.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError: In any other error case.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> function alertForCorruptedRemovableDrives(storages) {
     for (var i = 0; i &#60; storages.length; i++) {
         if (storages[i].type != &quot;EXTERNAL&quot;)
             continue;
         if (storages[i].state == &quot;UNMOUNTABLE&quot;)
             console.log(&quot;External drive &quot; + storages[i].label + &quot; is corrupted.&quot;);
     }
 }

 tizen.filesystem.listStorages(alertForCorruptedRemovableDrives);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="onsuccess">
            <descriptive>
                <description><p>
 Called when the list of storage is available,
passing the storage list to the callback.
                </p></description>
            </descriptive>
            <Type name="FileSystemStorageArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addStorageStateChangeListener" id="::Filesystem::FileSystemManager::addStorageStateChangeListener">
        <webidl>    long addStorageStateChangeListener(<ref>FileSystemStorageSuccessCallback</ref> onsuccess,
                                       optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Subscribes to notifications when a storage state changes.
            </brief>
           <description>
            <p>
The most common usage for this method would be to watch notifications of
additions and removals of external storages.
            </p>
            <p>
When executed, the implementation MUST immediately return a subscription identifier that identifies
the watch operation. After returning the identifier, the watch operation is started
asynchronously. The onsuccess MUST be invoked every time
a storage state changes. If the attempt fails, the onerror (if present)
MUST be invoked with the relevant error type.
            </p>
            <p>
The watch operation MUST continue until the removeStorageStateChangeListener() method is
called with the corresponding subscription identifier.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var watchID;
 function onStorageStateChanged(storage) {
     if (storage.state == &quot;MOUNTED&quot;)
         console.log(&quot;Storage &quot; + storage.label + &quot; was added!&quot;);
 }

 watchID = tizen.filesystem.addStorageStateChangeListener(onStorageStateChanged);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The identifier used to clear the watch subscription.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="onsuccess">
            <descriptive>
                <description><p>
 To be invoked in every change on storage state.
                </p></description>
            </descriptive>
            <Type name="FileSystemStorageSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 To be invoked in case of error during the watch process.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeStorageStateChangeListener" id="::Filesystem::FileSystemManager::removeStorageStateChangeListener">
        <webidl>    void removeStorageStateChangeListener(long watchId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsubscribes a storage watch operation.
            </brief>
           <description>
            <p>
If the watchId argument is valid and corresponds to a subscription already in
place, the watch process MUST immediately stop and no further callbacks MUST be
invoked.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var watchID;
 function onStorageStateChanged(storage) {
     if (storage.state == &quot;MOUNTED&quot;)
         console.log(&quot;Storage &quot; + storage.label + &quot; was added!&quot;);
     tizen.filesystem.removeStorageStateChangeListener(watchID);
 }

 watchID = tizen.filesystem.addStorageStateChangeListener(onStorageStateChanged);


 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="watchId">
            <descriptive>
                <description><p>
 Subscription Identifier.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error case.
                </p></description>
                <description><p>
 with error type NotFoundError, if the watchId does not exist.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="FileSystemStorage" id="::Filesystem::FileSystemStorage">
      <webidl>  [NoInterfaceObject] interface FileSystemStorage {
    readonly attribute DOMString label;

    readonly attribute <ref>FileSystemStorageType</ref> type;

    readonly attribute <ref>FileSystemStorageState</ref> state;
  };</webidl>
      <descriptive>
          <brief>
 The FileSystemStorage interface.
          </brief>
         <description>
          <p>
This interface gives additional information about a storage, such as if the
device is mounted, if it's a removable drive or not, or the device's name.
To retrieve the mount point, the resolve() method should be used using
the label as argument.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="label" id="::Filesystem::FileSystemStorage::label">
        <webidl>    readonly attribute DOMString label;</webidl>
        <descriptive>
            <brief>
 The storage name.
            </brief>
           <description>
            <p>
Used as input for functions like getStorage() and also used as 'location' parameter for File.resolve() and FileSystemManager.resolve().
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::Filesystem::FileSystemStorage::type">
        <webidl>    readonly attribute <ref>FileSystemStorageType</ref> type;</webidl>
        <descriptive>
            <brief>
 The storage type.
            </brief>
           <description>
            <p>
Defines whether the storage is internal or external.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="FileSystemStorageType"/>
      </Attribute>
      <Attribute readonly="readonly" name="state" id="::Filesystem::FileSystemStorage::state">
        <webidl>    readonly attribute <ref>FileSystemStorageState</ref> state;</webidl>
        <descriptive>
            <brief>
 The storage state.
            </brief>
           <description>
            <p>
Defines whether the storage is mounted or not.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="FileSystemStorageState"/>
      </Attribute>
    </Interface>
    <Interface name="File" id="::Filesystem::File">
      <webidl>  [NoInterfaceObject] interface File {
    readonly attribute <ref>File</ref>? parent;

    readonly attribute boolean readOnly;

    readonly attribute boolean isFile;

    readonly attribute boolean isDirectory;

    readonly attribute Date? created;

    readonly attribute Date? modified;

    readonly attribute DOMString path;

    readonly attribute DOMString name;

    readonly attribute DOMString fullPath;

    readonly attribute unsigned long long fileSize;

    readonly attribute long length;

    DOMString toURI() raises(<ref>WebAPIException</ref>);

    void listFiles(<ref>FileArraySuccessCallback</ref> onsuccess,
                   optional <ref>ErrorCallback</ref>? onerror,
                   optional <ref>FileFilter</ref>? filter) raises(<ref>WebAPIException</ref>);

    void openStream(<ref>FileMode</ref> mode,
                    <ref>FileStreamSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror,
                    optional DOMString? encoding) raises(<ref>WebAPIException</ref>);

    void readAsText(<ref>FileStringSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror,
                    optional DOMString? encoding) raises(<ref>WebAPIException</ref>);

    void copyTo(DOMString originFilePath,
                DOMString destinationFilePath,
                boolean overwrite,
                optional <ref>SuccessCallback</ref>? onsuccess,
                optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    void moveTo(DOMString originFilePath,
                DOMString destinationFilePath,
                boolean overwrite,
                optional <ref>SuccessCallback</ref>? onsuccess,
                optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    <ref>File</ref> createDirectory(DOMString dirPath) raises(<ref>WebAPIException</ref>);

    <ref>File</ref> createFile(DOMString relativeFilePath) raises(<ref>WebAPIException</ref>);

    <ref>File</ref> resolve(DOMString filePath) raises(<ref>WebAPIException</ref>);

    void deleteDirectory(DOMString directoryPath,
                         boolean recursive,
                         optional <ref>SuccessCallback</ref>? onsuccess,
                         optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);

    void deleteFile(DOMString filePath,
                    optional <ref>SuccessCallback</ref>? onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The file interface.
          </brief>
         <description>
          <p>
This interface represents the file abstraction in use.
A file handle represents a file
if the isFile property is <em>true</em>, if the isFile property is <em>false</em>, the file
handle represents a directory.
If a file handle represents a directory, it can address files and directories.
          </p>
          <p>
The file object permissions for the file object location and tree rooted
at that location depends upon the mode defined in the resolve method.
When a File object creates a child File object,
the new File object inherits its access rights from
the parent object without any reference to the security framework, as
noted in certain methods of File.
          </p>
          <p>
A file handle representing a file can be opened for I/O operations,
such as reading and writing.
          </p>
          <p>
A file handle representing a directory can be used for listing all
files and directories rooted as the file handle location.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     // alerts each name of dir's contents
     console.log(files[i].name);
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message +
               &quot; occurred when listing the files in the selected folder&quot;);
 }

 // list directory contents
 dir.listFiles(onsuccess, onerror);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="parent" id="::Filesystem::File::parent">
        <webidl>    readonly attribute <ref>File</ref>? parent;</webidl>
        <descriptive>
            <brief>
 The parent directory handle.
            </brief>
           <description>
            <p>
<em>null</em> if there is no parent directory.
            </p>
            <p>
If there is no parent directory, this represents a root location.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // list directory contents
 dir.listFiles(onsuccess, onerror);

 function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     // prints the file parent, should contain the
     // same value for all the files in the loop
     console.log(&quot;All the files should have the same parent &quot; +
                 files[i].parent);
   }
 }

 function onerror(error){
   console.log(&quot;The error &quot; + error.message +
               &quot; occurred when listing the files in the selected folder&quot;);
 }
 </Code>
        </descriptive>
        <Type name="File" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="readOnly" id="::Filesystem::File::readOnly">
        <webidl>    readonly attribute boolean readOnly;</webidl>
        <descriptive>
            <brief>
 The file/directory access state in the filesystem.
            </brief>
           <description>
            <p>
<em>true</em> if object has read-only access at its location.
            </p>
            <p>
<em>false</em> if object has write access at its location.
            </p>
            <p>
This attribute represents the actual state of a
file or directory in the filesystem. Its value is not affected by
the mode used in FileSystemManager.resolve that was used to
create the File object from which this File object was obtained.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // list directory contents
 dir.listFiles(onsuccess, onerror);

 function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     if(files[i].readOnly)
       console.log(&quot;Cannot write to file &quot; + files[i].name);
     else
       console.log(&quot;Can write to file &quot; + files[i].name);
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message + &quot; occurred when listing the files in the selected folder&quot;);
 }
 </Code>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="isFile" id="::Filesystem::File::isFile">
        <webidl>    readonly attribute boolean isFile;</webidl>
        <descriptive>
            <brief>
 The file type.
            </brief>
           <description>
            <p>
<em>true</em> if this handle is a file.
<em>false</em> if this handle is a directory.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="isDirectory" id="::Filesystem::File::isDirectory">
        <webidl>    readonly attribute boolean isDirectory;</webidl>
        <descriptive>
            <brief>
 The file type.
            </brief>
           <description>
            <p>
<em>true</em> if this handle is a directory,
<em>false</em> if this handle is a file.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="created" id="::Filesystem::File::created">
        <webidl>    readonly attribute Date? created;</webidl>
        <descriptive>
            <brief>
 The creation timestamp of this file.
            </brief>
           <description>
            <p>
This is the timestamp when the file was first created in the filesystem.
Equivalent to the timestamp when a call to createFile() succeeds.
            </p>
            <p>
If the platform does not support this attribute, it MUST
be <em>null</em>.
            </p>
            <p>
It is unspecified and platform-dependent if the creation
timestamp changes when a file is moved.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="modified" id="::Filesystem::File::modified">
        <webidl>    readonly attribute Date? modified;</webidl>
        <descriptive>
            <brief>
 The modification timestamp.
            </brief>
           <description>
            <p>
The modification timestamp of this file. This is the timestamp
of the most recent modification to the file, usually when the last
write operation succeeded. Opening a file for reading does not change
the modification timestamp.
            </p>
            <p>
If the platform does not support this attribute, it MUST
be <em>null</em>.
            </p>
            <p>
It is unspecified and platform-dependent if the modified
timestamp changes when a file is moved.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> console.log(file.modified); // displays the modification timestamp
 </Code>
        </descriptive>
        <Type type="Date" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="path" id="::Filesystem::File::path">
        <webidl>    readonly attribute DOMString path;</webidl>
        <descriptive>
            <brief>
 The path of this file, excluding the file name.
            </brief>
           <description>
            <p>
This is the path of this file, beginning with the name of the root containing the file,
up to and including the directory containing the file, but excluding the file name.
            </p>
            <p>
Except in a special case of the File representing the root itself, the last
character is always the character '/'.
            </p>
            <p>
For example, if a file is located at music/ramones/volume1/RockawayBeach.mp3,
the path would be music/ramones/volume1/.
            </p>
            <p>
For example, if a directory is located at music/ramones/volume1, the path would be
music/ramones/.
            </p>
            <p>
For the virtual roots, the path is same as the name of the virtual root.
For example, if the root is music, then the path is music. If the root is documents, then the path is documents.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> console.log(file.path); // should be 'music/' if the file is music/foo.mp3
 </Code>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Filesystem::File::name">
        <webidl>    readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 The file name, excluding any path components.
            </brief>
           <description>
            <p>
This is the name of this file, excluding the root name and any other path components.
            </p>
            <p>
For example, if a file is located at
music/ramones/volume1/RockawayBeach.mp3, the name would be RockawayBeach.mp3.
            </p>
            <p>
For example, if a directory is located at music/ramones/volume1, the
name would be volume1.
            </p>
            <p>
For the special case of the root itself, the name is an empty string.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> console.log(file.name); // should be foo.mp3 if the file path is music/foo.mp3
 </Code>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="fullPath" id="::Filesystem::File::fullPath">
        <webidl>    readonly attribute DOMString fullPath;</webidl>
        <descriptive>
            <brief>
 The full path of this file.
            </brief>
           <description>
            <p>
The full path of this file, beginning with the name of the root containing the file,
and including the name of the file or directory itself.
            </p>
            <p>
For instance, for a file, if the file is located at
music/ramones/volume1/RockawayBeach.mp3, then the fullPath is
music/ramones/volume1/RockawayBeach.mp3.
            </p>
            <p>
For a directory, if the directory is located at music/ramones/volume1, then the
fullPath is music/ramones/volume1.
            </p>
            <p>
For the special case of the root itself, if the root is music, then the fullPath is
music.
            </p>
            <p>
The fullPath is always equal to path + name.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> console.log(file.fullPath); // should be music/track1.mp3 if the file is music/track1.mp3
 </Code>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="fileSize" id="::Filesystem::File::fileSize">
        <webidl>    readonly attribute unsigned long long fileSize;</webidl>
        <descriptive>
            <brief>
 The size of this file, in bytes.
            </brief>
           <description>
            <p>
If there's an attempt to read this attribute on a directory,
<em>undefined</em> is returned. To retrieve the
number of files and directories contained in the directory,
use the length attribute, instead.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> console.log(file.fileSize); // displays the file size
 </Code>
        </descriptive>
        <Type type="unsigned long long"/>
      </Attribute>
      <Attribute readonly="readonly" name="length" id="::Filesystem::File::length">
        <webidl>    readonly attribute long length;</webidl>
        <descriptive>
            <brief>
 The number of files and directories contained in this file handle.
            </brief>
           <description>
            <p>
If there's an attempt to read this attribute on a file,
<em>undefined</em> is returned. To retrieve the
size of a file, use the fileSize attribute instead.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> console.log(file.length); // '3' if the directory contains two files and one sub-directory
 </Code>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Operation name="toURI" id="::Filesystem::File::toURI">
        <webidl>    DOMString toURI() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns a URI for the file.
            </brief>
           <description>
            <p>
Returns a URI that can be used to identify this entry (such as using it
as the src attribute on an HTML img element). The URI has no specific
expiration, it should be valid at least as long as the file exists.
            </p>
            <p>
When this method is invoked, the implementation MUST generate a URI.
            </p>
            <p>
If that URI corresponds to any of the public virtual roots (that is
images, videos, music, documents, and downloads) the URI
MUST be globally unique and could be used by any widget.
            </p>
            <p>
If that URI corresponds to a file located in any of the widget private
areas (such as wgt-package, wgt-private, wgt-private-tmp). The generated
URI MUST be unique for that file and for the widget making the request
(such as including some derived from the widget id in the URI).
These URIs MUST NOT be accessible to other widgets,
apart from the one invoking this method.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> // 'file:///opt/usr/media/music/ramones/RockawayBeach.mp3' if the file is
 // music/ramones/RockawayBeach.mp3
 console.log(file.toURI());
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The URI that identifies the file or <em>null</em> if an error occurs.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error situation.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="listFiles" id="::Filesystem::File::listFiles">
        <webidl>    void listFiles(<ref>FileArraySuccessCallback</ref> onsuccess,
                   optional <ref>ErrorCallback</ref>? onerror,
                   optional <ref>FileFilter</ref>? filter) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns the list of all files in this directory.
            </brief>
           <description>
            <p>
The list of files will be passed as a File[] in the onsuccess
and contains directories and files. However, the directories &quot;.&quot; and &quot;..&quot;
MUST NOT be returned. Each File object part of the array MUST inherit
all the access rights (that is one of the values in FileMode) from the File object in which
this method was invoked.
            </p>
            <p>
If the filter is passed and contains valid values, only those directories
and files in the directory that match the filter criteria specified
in the FileFilter interface MUST be returned in the onsuccess.
If no filter is passed, the filter is <em>null</em> or undefined, or the filter contains invalid
values, the implementation MUST return the full list of files in the directory.
            </p>
            <p>
If the directory does not contain any files or directories, or
the filter criteria is unmatched to any files or directories, the onsuccess will be
invoked with an empty array.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
IOError: The operation is launched on a file (not a directory).              </li>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError: In any other error case.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> function onsuccess(files) {
   console.log(&quot;There are &quot; + files.length  + &quot; in the selected folder&quot;);
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message + &quot; occurred when listing the files in the selected folder&quot;);
 }

 tizen.filesystem.resolve(
     &quot;documents&quot;,
     function(dir){
       dir.listFiles(onsuccess, onerror);
     }, function(e){
       console.log(&quot;Error &quot; + e.message);
     }, &quot;r&quot;
 );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="onsuccess">
            <descriptive>
                <description><p>
 Called when the list operation has been successfully completed.
                </p></description>
            </descriptive>
            <Type name="FileArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 Used to restrict the listed files.
                </p></description>
            </descriptive>
            <Type name="FileFilter" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="openStream" id="::Filesystem::File::openStream">
        <webidl>    void openStream(<ref>FileMode</ref> mode,
                    <ref>FileStreamSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror,
                    optional DOMString? encoding) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Opens the file in the given mode supporting the given
encoding.
            </brief>
           <description>
            <p>
This operation is performed asynchronously. If the file is opened
successfully, the onsuccess is invoked with a FileStream
that can be used for reading and writing the file, depending on the
mode. The return FileStream instance includes a file pointer, which represents
the current position in the file. The filepointer will, by default, be at the start of the file,
except in the case of opening with append (&quot;a&quot;) mode, in which case
the filepointer points to the end of the file.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contains an invalid value.               </li>
              <li>
IOError: The operation is launched on a directory (not a file), the file is not
valid or it does not exist.              </li>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> var documentsDir;
 function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     console.log(&quot;File Name is &quot; + files[i].name); // displays file name
   }

   var testFile = documentsDir.createFile(&quot;test.txt&quot;);
   if (testFile != null) {
     testFile.openStream(
         &quot;w&quot;,
         function(fs){
           fs.write(&quot;HelloWorld&quot;);
           fs.close();
         }, function(e){
           console.log(&quot;Error &quot; + e.message);
         }, &quot;UTF-8&quot;
     );
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message + &quot; occurred when listing the files in the selected folder&quot;);
 }

 tizen.filesystem.resolve(
     'documents',
     function(dir){
       documentsDir = dir; dir.listFiles(onsuccess,onerror);
     }, function(e) {
       console.log(&quot;Error&quot; + e.message);
     }, &quot;rw&quot;
 );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="mode">
            <descriptive>
                <description><p>
 The mode for opening a file:
<b>&quot;r&quot;</b> for reading
<b>&quot;a&quot;</b> for appending
<b>&quot;w&quot;</b> for [over]writing
<b>&quot;rw&quot;</b> for reading and writing
                </p></description>
            </descriptive>
            <Type name="FileMode"/>
          </Argument>
          <Argument name="onsuccess">
            <descriptive>
                <description><p>
 Called when the file has been opened.
                </p></description>
            </descriptive>
            <Type name="FileStreamSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="encoding">
            <descriptive>
                <description><p>
 The encoding for read/write operations on the file,
at least the following encodings MUST be supported:
&quot;<a href="http://www.ietf.org/rfc/rfc2279.txt">UTF-8</a>&quot; default encoding,
&quot;<a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a>&quot; latin1 encoding.
If no encoding is passed by the developer, then the default platform encoding
MUST be used.
                </p></description>
            </descriptive>
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="readAsText" id="::Filesystem::File::readAsText">
        <webidl>    void readAsText(<ref>FileStringSuccessCallback</ref> onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror,
                    optional DOMString? encoding) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Reads the content of a file as a DOMString.
            </brief>
           <description>
            <p>
If the operation is successfully executed, the onsuccess is
invoked and a DOMString is passed as input parameter that represents
the file content in the format determined by the encoding parameter.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
IOError: The operation is launched on a directory (not a file), the file is not
valid, or the file does not exist.              </li>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     console.log(&quot;File Name is &quot; + files[i].name); // displays file name
     if (files[i].isDirectory == false)
       files[i].readAsText(
           function(str){
             console.log(&quot;The file content &quot; + str);
           }, function(e){
             console.log(&quot;Error &quot; + e.message);
           }, &quot;UTF-8&quot;
       );
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message + &quot; occurred when listing the files in the selected folder&quot;);
 }

 var documentsDir;
 tizen.filesystem.resolve(
     'documents',
     function(dir){
       documentsDir = dir;
       dir.listFiles(onsuccess,onerror);
     }, function(e) {
       console.log(&quot;Error&quot; + e.message);
     }, &quot;rw&quot;
 );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="onsuccess">
            <descriptive>
                <description><p>
 Called when the file has been successfully read.
                </p></description>
            </descriptive>
            <Type name="FileStringSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 If an error occurs while reading the file.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="encoding">
            <descriptive>
                <description><p>
 The encoding for read/write operations on the file,
at least the following encodings MUST be supported:
&quot;<a href="http://www.ietf.org/rfc/rfc2279.txt">UTF-8</a>&quot; default encoding,
&quot;<a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a>&quot; latin1 encoding.
If no encoding is passed by the developer, then the default platform
encoding MUST be used.
                </p></description>
            </descriptive>
            <Type type="DOMString" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="copyTo" id="::Filesystem::File::copyTo">
        <webidl>    void copyTo(DOMString originFilePath,
                DOMString destinationFilePath,
                boolean overwrite,
                optional <ref>SuccessCallback</ref>? onsuccess,
                optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Copies (and overwrites if possible and specified) a file or a
directory from a specified location to another specified location.
            </brief>
           <description>
            <p>
The copy of the file or directory identified by the originFilePath parameter
MUST be created in the path passed in the destinationFilePath parameter.
            </p>
            <p>
The file or directory to be copied MUST be under the Directory from which the method
is invoked, otherwise the operation MUST NOT be performed.
            </p>
            <p>
If the copy is performed successfully, the onsuccess is invoked.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
NotFoundError: originFilePath does not correspond to a valid file or destinationPath is not a valid path.              </li>
              <li>
IOError: The File in which the copyTo method is invoked is a file (not a directory),
originFilePath corresponds to a file or directory in use by another process,
overwrite parameter is <em>false</em> and destinationFilePath corresponds to an existing
file or directory.              </li>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var documentsDir;
 function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     if (files[i].isDirectory == false) {
       documentsDir.copyTo(files[i].fullPath,
                           &quot;images/backup/&quot; + files[i].name,
                           false,
                           function(){console.log(&quot;file copied&quot;);});
     }
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message +
               &quot; occurred when listing the files in the selected folder&quot;);
 }

 tizen.filesystem.resolve(
     'documents',
     function(dir){
       documentsDir = dir;
       dir.listFiles(onsuccess, onerror);
     }, function(e) {
       console.log(&quot;Error&quot; + e.message);
     }, &quot;rw&quot;
 );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="originFilePath">
            <descriptive>
                <description><p>
 The origin full virtual file or directory path, it must be under the current directory.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="destinationFilePath">
            <descriptive>
                <description><p>
 The new full virtual file path or directory path.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="overwrite">
            <descriptive>
                <description><p>
 <em>true</em> enforces overwriting an existing file.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="onsuccess">
            <descriptive>
                <description><p>
 Called when the file has been copied.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="moveTo" id="::Filesystem::File::moveTo">
        <webidl>    void moveTo(DOMString originFilePath,
                DOMString destinationFilePath,
                boolean overwrite,
                optional <ref>SuccessCallback</ref>? onsuccess,
                optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Moves a file or a directory from a specified location to another.
            </brief>
           <description>
            <p>
The file or directory will be moved (and will overwrite if possible and specified)
atomically to the given path. This operation is different from
instantiating copyTo and then deleting the original file, as on certain
platforms, this operation does not require extra disk space.
            </p>
            <p>
The file or directory identified by the originFilePath parameter
MUST be moved to the path passed in the destinationFilePath parameter.
            </p>
            <p>
The file to be moved MUST be under the Directory from which the method
is invoked, otherwise the operation MUST NOT be performed.
            </p>
            <p>
If the file or directory is moved successfully, the onsuccess is
invoked.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.               </li>
              <li>
NotFoundError: originFilePath does not correspond to a valid file or destinationPath is not a valid path.              </li>
              <li>
IOError: The File in which the moveTo method is invoked is a file (not a directory),
originFilePath corresponds to a file or directory in use by another process,
overwrite parameter is <em>false</em> and destinationFilePath corresponds to an existing
file or directory.              </li>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var documentsDir;
 function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     if (files[i].isDirectory == false) {
       documentsDir.moveTo(files[i].fullPath,
                           &quot;images/newFolder/&quot; + files[i].name,
                           false,
                           function(){console.log(&quot;file moved&quot;);});
     }
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message +
               &quot; occurred during listing the files in the selected folder&quot;);
 }

 tizen.filesystem.resolve(
     'documents',
     function(dir){
       documentsDir = dir;
       dir.listFiles(onsuccess, onerror);
     }, function(e) {
       console.log(&quot;Error&quot; + e.message);
     }, &quot;rw&quot;
 );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="originFilePath">
            <descriptive>
                <description><p>
 The origin full virtual file or directory path, it must be under the current directory.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="destinationFilePath">
            <descriptive>
                <description><p>
 The new full virtual file path or directory path.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="overwrite">
            <descriptive>
                <description><p>
 <em>true</em> enforces overwriting an existing file.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="onsuccess">
            <descriptive>
                <description><p>
 Called when the file has been moved.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="createDirectory" id="::Filesystem::File::createDirectory">
        <webidl>    <ref>File</ref> createDirectory(DOMString dirPath) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Creates a new directory.
            </brief>
           <description>
            <p>
A new directory will be created relative to the current
directory that this operation is performed on. The implementation will attempt to
create all necessary sub-directories specified in the dirPath, as well. The use of &quot;.&quot;
or &quot;..&quot; in path components is not supported.
            </p>
            <p>
This operation can only be performed on file handlers that
represent a directory (that is, <var>isDirectory == true</var>).
            </p>
            <p>
If the directory is successfully created, it will be returned.
            </p>
            <p>
In case the directory cannot be created, an error MUST be thrown
with the appropriate error type.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var dir; //Directory object obtained from filesystem API
 var newDir = dir.createDirectory(&quot;newDir&quot;);
 var anotherNewDir = dir.createDirectory(&quot;newDir1/subNewDir1&quot;);
 </Code>
        </descriptive>
        <Type name="File">
          <descriptive>
              <description><p>
 File The file handle of the new directory. The new File object
will have &quot;rw&quot; access rights, as it inherits this from
the File object on which the createDirectory() method is
called.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="dirPath">
            <descriptive>
                <description><p>
 The relative directory path, it should only contain
characters supported by the underlying filesystem.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type IOError, if the dirPath already exists.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the dirPath does not contain a valid path.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="createFile" id="::Filesystem::File::createFile">
        <webidl>    <ref>File</ref> createFile(DOMString relativeFilePath) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Creates a new empty file in a specified location.
            </brief>
           <description>
            <p>
A new empty file is created in the given path relative
to the directory indicated by current 'File' object's 'path' attribute.
The use of &quot;.&quot; or &quot;..&quot; in path components is not supported.
This operation can only be performed on file handlers that
represent a directory (that is, <var>isDirectory == true</var>).
            </p>
            <p>
If the file is successfully created, a file handler MUST
be returned by this method.
            </p>
            <p>
In case the file cannot be created, an error MUST be thrown
with the appropriate error type.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var newFile = dir.createFile(&quot;newFilePath&quot;);
 </Code>
        </descriptive>
        <Type name="File">
          <descriptive>
              <description><p>
 File The file handle of the new empty file. The new File object
will have &quot;rw&quot; access rights, as it inherits this from
the File object on which the createFile() method is
called.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="relativeFilePath">
            <descriptive>
                <description><p>
 The new file path, it should only contain characters supported by the underlying filesystem.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type IOError, if the filePath already exists.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the filePath contains an invalid value.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="resolve" id="::Filesystem::File::resolve">
        <webidl>    <ref>File</ref> resolve(DOMString filePath) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Resolves an existing file or directory relative to
the current directory this operation is performed on, and
returns a file handle for it.
            </brief>
           <description>
            <p>
The filePath is not allowed to contain the &quot;.&quot; or &quot;..&quot; directories.
            </p>
            <p>
The encoding of file paths is <a href="http://www.ietf.org/rfc/rfc2279.txt">UTF-8</a>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> var file;
 // Resolves helloWorld.doc file that is located in the
 // documents root location
 tizen.filesystem.resolve(
   'documents',
   function(dir){ file = dir.resolve(&quot;helloWorld.doc&quot;);},
   function(e){ console.log(&quot;Error&quot; + e.message);},
   &quot;rw&quot;);
 </Code>
        </descriptive>
        <Type name="File">
          <descriptive>
              <description><p>
 File The file handle of the file. The new File object will inherit its access
rights from the File object on which this resolve() method
is called.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="filePath">
            <descriptive>
                <description><p>
 The relative file/directory path/file URI to resolve.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the file path contains an
invalid value.
                </p></description>
                <description><p>
 with error type IOError, if the method is executed in a File object
that does not represent a directory (that is, isDirectory attribute is false).
                </p></description>
                <description><p>
 with error type NotFoundError, if a file does not exist for the passed
file path.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="deleteDirectory" id="::Filesystem::File::deleteDirectory">
        <webidl>    void deleteDirectory(DOMString directoryPath,
                         boolean recursive,
                         optional <ref>SuccessCallback</ref>? onsuccess,
                         optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Deletes a specified directory and directory tree if specified.
            </brief>
           <description>
            <p>
This function attempts to asynchronously delete a directory or directory tree under the current
directory.
            </p>
            <p>
If the recursive parameter is set to <em>true</em>, all the directories and files under the specified
directory MUST be deleted. If the recursive parameter is set to false, the directory will
only be deleted if it is empty, otherwise an IOError error type will be passed in onerror.
            </p>
            <p>
The directory to be deleted MUST be under the Directory that the method
is invoked from, otherwise the operation MUST NOT be performed.
If the deletion is performed successfully, the onsuccess is invoked.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.               </li>
              <li>
NotFoundError: The passed directory does not correspond to a valid directory.               </li>
              <li>
IOError: The File in which the delete method is invoked
is a file (not a directory), the directory is in use by another process
or the directory is not empty and recursive argument is <em>false</em>.
This code will be also used if a recursive deletion partially fails
and any data deleted so far cannot be recovered. This may occur
due to the lack of filesystem permissions or if any
directories or files are opened by other processes.              </li>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var documentsDir;
 function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     if (files[i].isDirectory) {
       documentsDir.deleteDirectory(
           files[i].fullPath,
           false,
           function(){
             console.log(&quot;Directory Deleted&quot;);
           }, function(e) {
             console.log(&quot;Error&quot; + e.message);
           });
     } else {
       documentsDir.deleteFile(
           files[i].fullPath,
           function(){
             console.log(&quot;File Deleted&quot;);
           }, function(e) {
             console.log(&quot;Error&quot; + e.message);
           });
     }
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message + &quot; occurred when listing the files in the selected folder&quot;);
 }

 tizen.filesystem.resolve(
     'documents',
     function(dir){
       documentsDir = dir;
       dir.listFiles(onsuccess,onerror);
     }, function(e) {
       console.log(&quot;Error&quot; + e.message);
     }, &quot;rw&quot;
 );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="directoryPath">
            <descriptive>
                <description><p>
 The full virtual path to the directory to be deleted (must be under the current one).
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="recursive">
            <descriptive>
                <description><p>
 <em>true</em> means a recursive deletion. This
will delete all data in all subdirectories. Use with caution.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="onsuccess">
            <descriptive>
                <description><p>
 Called if the directory is successfully deleted.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="deleteFile" id="::Filesystem::File::deleteFile">
        <webidl>    void deleteFile(DOMString filePath,
                    optional <ref>SuccessCallback</ref>? onsuccess,
                    optional <ref>ErrorCallback</ref>? onerror) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Deletes a specified file.
            </brief>
           <description>
            <p>
This function attempts to asynchronously delete a file under the current directory.
            </p>
            <p>
The file to be deleted MUST be under the Directory from which the method
is invoked, otherwise the operation MUST NOT be performed.
            </p>
            <p>
If the deletion is performed successfully, the onsuccess is invoked.
            </p>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError: If any of the input parameters contain an invalid value.               </li>
              <li>
NotFoundError: The file does not correspond to a valid file.               </li>
              <li>
IOError: The file in which the delete method is invoked
is a directory (not a file), the file is in use by another process,
or there is no permission in the file system.              </li>
              <li>
UnknownError: In any other error case.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> function onsuccess(files) {
   for(var i = 0; i &#60; files.length; i++) {
     if (files[i].isDirectory) {
       documentsDir.deleteDirectory(
           files[i].fullPath,
           false,
           function(){
             console.log(&quot;Directory Deleted&quot;);
           }, function(e) {
             console.log(&quot;Error&quot; + e.message);
           });
     } else {
       documentsDir.deleteFile(
           files[i].fullPath,
           function(){
             console.log(&quot;File Deleted&quot;);
           }, function(e) {
             console.log(&quot;Error&quot; + e.message);
           });
     }
   }
 }

 function onerror(error) {
   console.log(&quot;The error &quot; + error.message + &quot; occurred when listing the files in the selected folder&quot;);
 }

 var documentsDir;
 tizen.filesystem.resolve(
   'documents',
   function(dir){
     documentsDir = dir;
     dir.listFiles(onsuccess,onerror);
   }, function(e){
     console.log(&quot;Error&quot; + e.message);
   }, &quot;rw&quot;
 );
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="filePath">
            <descriptive>
                <description><p>
 The full virtual path to the file to be deleted (must be under the current directory).
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="onsuccess">
            <descriptive>
                <description><p>
 Called if the file is successfully deleted.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="onerror">
            <descriptive>
                <description><p>
 Called if an error occurred.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Dictionary name="FileFilter" id="::Filesystem::FileFilter">
      <webidl>  dictionary FileFilter {
    DOMString name;

    Date startModified;

    Date endModified;

    Date startCreated;

    Date endCreated;
  };</webidl>
      <descriptive>
          <brief>
 Dictionary created to filter the items returned by the listFiles method.
          </brief>
         <description>
          <p>
When this dictionary is passed in the listFiles method, the result-set of
the listFiles method MUST only contain the file items entries that match
the attribute values of the filter.
The result set of the listFiles method does not guarantee any sort order.
          </p>
          <p>
A file item only matches the FileFilter object if all the attributes of the file item match
all the attribute values of the filter which are defined (that is, only matching values other
than undefined or <em>null</em>). This is similar to an SQL &quot;AND&quot; operation.
          </p>
          <p>
An attribute of the file entry matches the FileFilter attribute value in accordance with the
following rules:
          </p>
          <ul>
            <li>
For FileFilter attributes of type DOMString, an entry matches this value only if its
corresponding attribute is an exact match. If the filter contains U+0025 'PERCENT SIGN' it is
interpreted as a wildcard character and '%' matches any string of any length, including no
length. If wildcards are used, the behavior is similar to the LIKE condition in SQL. To
specify that a 'PERCENT SIGN' character is to be considered literally instead of interpreting it
as a wildcard, developers may escape it with the backslash character (\).
The matching is not case sensitive, such as &quot;FOO&quot; matches a &quot;foo&quot; or an &quot;f%&quot; filter.
            </li>
            <li>
For File entry attributes of type Date, attributes start and end are included to allow
filtering of File entries between two supplied dates. If either or both of these attributes are
specified, the following rules apply:
A) If both start and end dates are specified (that is, other than <em>null</em>), a File entry matches the
filter if it's corresponding attribute is the same as either start or end or between the two
supplied dates (that is, after start and before end).
B) If only the start attribute contains a value (other than <em>null</em>), a File entry matches the
filter if its corresponding attribute is later than or equal to the start one.
C) If only the end date contains a value (other than <em>null</em>), a file matches the filter if its
corresponding attribute is earlier than or equal to the end date.
            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="name" id="::Filesystem::FileFilter::name">
        <webidl>    DOMString name;</webidl>
        <descriptive>
            <brief>
 Used for filtering the File name attribute.
            </brief>
           <description>
            <p>
Files which name corresponds with this attribute
(either exactly or with the specified wildcards) match
this filtering criteria.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="startModified" id="::Filesystem::FileFilter::startModified">
        <webidl>    Date startModified;</webidl>
        <descriptive>
            <brief>
 Used for filtering the File modified attribute.
            </brief>
           <description>
            <p>
Files with modified date later than this attribute or equal to it match
the filtering criteria.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </DictionaryMember>
      <DictionaryMember name="endModified" id="::Filesystem::FileFilter::endModified">
        <webidl>    Date endModified;</webidl>
        <descriptive>
            <brief>
 Used for filtering the File created attribute.
            </brief>
           <description>
            <p>
Files with modified date earlier than this attribute or equal to it
match the filtering criteria.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </DictionaryMember>
      <DictionaryMember name="startCreated" id="::Filesystem::FileFilter::startCreated">
        <webidl>    Date startCreated;</webidl>
        <descriptive>
            <brief>
 Used for filtering the File created attribute.
            </brief>
           <description>
            <p>
Files with created date later than this attribute or equal to it match
the filtering criteria.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </DictionaryMember>
      <DictionaryMember name="endCreated" id="::Filesystem::FileFilter::endCreated">
        <webidl>    Date endCreated;</webidl>
        <descriptive>
            <brief>
 Used for filtering the File created attribute.
            </brief>
           <description>
            <p>
Files with created date earlier than this attribute or equal to it
match the filtering criteria.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </DictionaryMember>
    </Dictionary>
    <Interface name="FileStream" id="::Filesystem::FileStream">
      <webidl>  [NoInterfaceObject] interface FileStream {
    readonly attribute boolean eof;

    attribute long position setraises(<ref>WebAPIException</ref>);

    readonly attribute long bytesAvailable;

    void close();

    DOMString read(long charCount) raises(<ref>WebAPIException</ref>);

    octet[] readBytes(long byteCount) raises(<ref>WebAPIException</ref>);

    DOMString readBase64(long byteCount) raises(<ref>WebAPIException</ref>);

    void write(DOMString stringData) raises(<ref>WebAPIException</ref>);

    void writeBytes(octet[] byteData) raises(<ref>WebAPIException</ref>);

    void writeBase64(DOMString base64Data) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 FileStream API.
          </brief>
         <description>
          <p>
A FileStream represents a handle to a File opened for read and/or
write operations. Read and write operations are performed relative
to a position attribute, which is a pointer that represents the current position in the file.
          </p>
          <p>
A series of read/write methods are available that permit both binary and
text to be processed.
          </p>
          <p>
Once a file stream is closed, any operation attempted on this stream
will result in a standard JavaScript error.
          </p>
          <p>
The read/write operations in this interface do not throw any security
exceptions as the access rights are expected to be granted through the initial
resolve() method or through the openStream() method of the File interface.
Therefore, all actions performed on a successfully resolved File and FileStream are
expected to succeed. This avoids successive asynchronous calls and may potentially increase
application for a user.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="eof" id="::Filesystem::FileStream::eof">
        <webidl>    readonly attribute boolean eof;</webidl>
        <descriptive>
            <brief>
 Indicates whether or not the current file pointer is at the end
of the file.
            </brief>
           <description>
            <p>
If <em>true</em>, this attribute indicates that the file pointer is at the end of the file.
            </p>
            <p>
If <em>false</em>, this attribute indicates that the file pointer is not at the end of the file
and may be anywhere within the file.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> if(stream.eof) {
   // file has been read completely
 }
 </Code>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="position" id="::Filesystem::FileStream::position">
        <webidl>    attribute long position setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets/sets stream position for reads/writes.
            </brief>
           <description>
            <p>
The stream position is an offset of bytes from the start of
the file stream. When invoking an operation that reads or
writes from the stream, the operation will take place from the
byte defined by this position attribute. If the read or write
operation is successful, the position of the stream is advanced
by the number of bytes read or written. If the read/write operation is not
successful, the position of the stream is unchanged.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> console.log(stream.position); // displays current stream position
 // alters current stream position to the begin of the file,
 // like seek() in C
 stream.position = 0;
 </Code>
        </descriptive>
        <Type type="long"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="bytesAvailable" id="::Filesystem::FileStream::bytesAvailable">
        <webidl>    readonly attribute long bytesAvailable;</webidl>
        <descriptive>
            <brief>
 Returns the number of bytes that are available for
reading from the stream.
            </brief>
           <description>
            <p>
The number of bytes available for reading is the maximum
amount of bytes that can be read in the next read operation.
It corresponds to the number of bytes available after the file pointer
denoted by the position attribute.
            </p>
            <p>
-1 if eof is <em>true</em>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> console.log(stream.bytesAvailable); // displays the available bytes to be read
 </Code>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Operation name="close" id="::Filesystem::FileStream::close">
        <webidl>    void close();</webidl>
        <descriptive>
            <brief>
 Closes this FileStream.
            </brief>
           <description>
            <p>
Flushes any pending buffered writes and closes the File. Always succeeds.
Note that pending writes might not succeed.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> stream.close(); // closes this stream, no subsequent access to stream allowed
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
      <Operation name="read" id="::Filesystem::FileStream::read">
        <webidl>    DOMString read(long charCount) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Reads the specified number of characters from this FileStream.
            </brief>
           <description>
            <p>
Reads the specified number of characters after the position file pointer and returns them as a string.
The resulting string length might be shorter than charCount if eof
is <em>true</em>.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> var text = stream.read(file.fileSize);
 stream.close();
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The result of read characters as a string.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="charCount">
            <descriptive>
                <description><p>
 Number of characters being read.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type IOError, if a read error occurs, such as the bytes in the stream
cannot be decoded with the encoding in use.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="readBytes" id="::Filesystem::FileStream::readBytes">
        <webidl>    octet[] readBytes(long byteCount) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Reads the specified number of bytes from this FileStream.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> // reads up to 256 bytes from the stream
 var raw = stream.readBytes(256);
 for(var i = 0; i &#60; raw.length; i++) {
   // raw[i] contains the i-th byte of the current data chunk
 }
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 octet[] The result of read bytes as a byte (or number) array.
              </p></description>
          </descriptive>
          <Type type="octet"/>
        </Type>
        <ArgumentList>
          <Argument name="byteCount">
            <descriptive>
                <description><p>
 Number of bytes being read.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type IOError, if a read error occurs.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="readBase64" id="::Filesystem::FileStream::readBase64">
        <webidl>    DOMString readBase64(long byteCount) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Reads the specified number of bytes from this FileStream, encoding
the result in base64.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.read
            </privilege>
            <Code> // reads up to 256 bytes from the stream
 var base64 = stream.readBase64(256);
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The result of read bytes as base64 encoding string.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="byteCount">
            <descriptive>
                <description><p>
 Number of bytes being read.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type IOError, if a read error occurs.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="write" id="::Filesystem::FileStream::write">
        <webidl>    void write(DOMString stringData) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Writes the specified DOMString to this FileStream.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var text = &quot;Hello world&quot;;
 stream.write(text);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="stringData">
            <descriptive>
                <description><p>
 The actual string to be written.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type IOError, if a write error occurs.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="writeBytes" id="::Filesystem::FileStream::writeBytes">
        <webidl>    void writeBytes(octet[] byteData) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Writes the specified bytes to this FileStream.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var bytes = in.readBytes(256);
 out.writeBytes(bytes); // writes the bytes read from in to out
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="byteData">
            <descriptive>
                <description><p>
 The byte data array being written.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="octet"/>
            </Type>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type IOError, if a write error occurs.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="writeBase64" id="::Filesystem::FileStream::writeBase64">
        <webidl>    void writeBase64(DOMString base64Data) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Converts the specified base64 DOMString to bytes and writes the
result to this FileStream.
            </brief>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/filesystem.write
            </privilege>
            <Code> var base64 = in.readBase64(256);
 out.writeBase64(base64); // writes the base64 data read from in to out
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="base64Data">
            <descriptive>
                <description><p>
 The base64 data being written.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type IOError, if an error occurs during writeBase64.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if the feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="FileSuccessCallback" id="::Filesystem::FileSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface FileSuccessCallback {
    void onsuccess(<ref>File</ref> file);
  };</webidl>
      <descriptive>
          <brief>
 The file system specific success callback.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback with
a File object as input argument. It is used in asynchronous
operations, such as FileSystemManager.resolve() and
copying, moving, and deleting files.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Filesystem::FileSuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>File</ref> file);</webidl>
        <descriptive>
            <brief>
 The method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="file">
            <descriptive>
                <description><p>
 The file resulting from the asynchronous call.
                </p></description>
            </descriptive>
            <Type name="File"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="FileSystemStorageArraySuccessCallback" id="::Filesystem::FileSystemStorageArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface FileSystemStorageArraySuccessCallback {
    void onsuccess(<ref>FileSystemStorage</ref>[] storages);
  };</webidl>
      <descriptive>
          <brief>
 The success callback to retrieve FileSystemStorage objects.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback with
an array of FileSystemStorage objects as input argument. It is used in asynchronous
operations, such as FileSystemManager.listStorages().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Filesystem::FileSystemStorageArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>FileSystemStorage</ref>[] storages);</webidl>
        <descriptive>
            <brief>
 The method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="storages">
            <descriptive>
                <description><p>
 List of available storage devices.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="FileSystemStorage"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="FileSystemStorageSuccessCallback" id="::Filesystem::FileSystemStorageSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface FileSystemStorageSuccessCallback {
    void onsuccess(<ref>FileSystemStorage</ref> storage);
  };</webidl>
      <descriptive>
          <brief>
 The success callback to retrieve a FileSystemStorage object.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback with
a FileSystmeStorage object as input argument. It is used in asynchronous
operations, such as FileSystemManager.getStorage() and
FileSystemManager.addStorageStateChangeListener().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Filesystem::FileSystemStorageSuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>FileSystemStorage</ref> storage);</webidl>
        <descriptive>
            <brief>
 The method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="storage">
            <descriptive>
                <description><p>
 The storage device structure.
                </p></description>
            </descriptive>
            <Type name="FileSystemStorage"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="FileStringSuccessCallback" id="::Filesystem::FileStringSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface FileStringSuccessCallback {
    void onsuccess(DOMString fileStr);
  };</webidl>
      <descriptive>
          <brief>
 The success callback to read the content of a file as a DOMString.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback with
a DOMString object as input argument. It is used in asynchronous
operations, such as File.readAsText().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Filesystem::FileStringSuccessCallback::onsuccess">
        <webidl>    void onsuccess(DOMString fileStr);</webidl>
        <descriptive>
            <brief>
 The method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="fileStr">
            <descriptive>
                <description><p>
 The file represented as a DOMString resulting from the asynchronous call.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="FileStreamSuccessCallback" id="::Filesystem::FileStreamSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface FileStreamSuccessCallback {
    void onsuccess(<ref>FileStream</ref> filestream);
  };</webidl>
      <descriptive>
          <brief>
 The success callback to open a file for raw access.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback with
a FileStream object as input argument. It is used by asynchronous
methods, such as File.openStream().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Filesystem::FileStreamSuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>FileStream</ref> filestream);</webidl>
        <descriptive>
            <brief>
 The method invoked when the File.openStream asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="filestream">
            <descriptive>
                <description><p>
 The filestream to access file content.
                </p></description>
            </descriptive>
            <Type name="FileStream"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="FileArraySuccessCallback" id="::Filesystem::FileArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface FileArraySuccessCallback {
    void onsuccess(<ref>File</ref>[] files);
  };</webidl>
      <descriptive>
          <brief>
 The file system specific success callback for listing methods.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback with a function
taking an array of File objects as input argument. It is used in asynchronous
methods, such as File.listFiles().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Filesystem::FileArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>File</ref>[] files);</webidl>
        <descriptive>
            <brief>
 The method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="files">
            <descriptive>
                <description><p>
 The files resulting from the asynchronous call.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="File"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="MessagePort" id="::MessagePort">
    <webidl>module MessagePort {

  [NoInterfaceObject] interface MessagePortManagerObject {
    readonly attribute <ref>MessagePortManager</ref> messageport;
  };
  <ref>Tizen</ref> implements <ref>MessagePortManagerObject</ref>;

  [NoInterfaceObject] interface MessagePortManager {

    <ref>LocalMessagePort</ref> requestLocalMessagePort(DOMString localMessagePortName) raises(<ref>WebAPIException</ref>);

    <ref>LocalMessagePort</ref> requestTrustedLocalMessagePort(DOMString localMessagePortName) raises(<ref>WebAPIException</ref>);

    <ref>RemoteMessagePort</ref> requestRemoteMessagePort(<ref>ApplicationId</ref> appId, DOMString remoteMessagePortName) raises(<ref>WebAPIException</ref>);

    <ref>RemoteMessagePort</ref> requestTrustedRemoteMessagePort(<ref>ApplicationId</ref> appId, DOMString remoteMessagePortName) raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface LocalMessagePort {

    readonly attribute DOMString messagePortName;

    readonly attribute boolean isTrusted;

    long addMessagePortListener(<ref>MessagePortCallback</ref> listener) raises(<ref>WebAPIException</ref>);

    void removeMessagePortListener(long watchId) raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface RemoteMessagePort {

    readonly attribute DOMString messagePortName;

    readonly attribute <ref>ApplicationId</ref> appId;

    readonly attribute boolean isTrusted;

    void sendMessage(<ref>MessagePortDataItem</ref>[] data, optional <ref>LocalMessagePort</ref>? localMessagePort) raises(<ref>WebAPIException</ref>);
  };

  dictionary MessagePortDataItem {
    DOMString key;
    DOMString value;
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface MessagePortCallback {
    void onreceived(<ref>MessagePortDataItem</ref>[] data, <ref>RemoteMessagePort</ref>? remoteMessagePort);
  };
};</webidl>
    <descriptive>
        <brief>
 This API provides the functionality for communicating with other applications.
        </brief>
        <version>
 2.1
        </version>
    </descriptive>
    <Interface name="MessagePortManagerObject" id="::MessagePort::MessagePortManagerObject">
      <webidl>  [NoInterfaceObject] interface MessagePortManagerObject {
    readonly attribute <ref>MessagePortManager</ref> messageport;
  };</webidl>
      <descriptive>
          <brief>
 The <em>MessagePortManagerObject</em> interface defines what is instantiated by the Tizen object from the Tizen Platform.
          </brief>
         <description>
          <p>
There is a <em>tizen.messageport</em> object that allows access to the functionality of the Message Port API.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="messageport" id="::MessagePort::MessagePortManagerObject::messageport">
        <webidl>    readonly attribute <ref>MessagePortManager</ref> messageport;</webidl>
        <Type name="MessagePortManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="MessagePortManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>MessagePortManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="MessagePortManager" id="::MessagePort::MessagePortManager">
      <webidl>  [NoInterfaceObject] interface MessagePortManager {

    <ref>LocalMessagePort</ref> requestLocalMessagePort(DOMString localMessagePortName) raises(<ref>WebAPIException</ref>);

    <ref>LocalMessagePort</ref> requestTrustedLocalMessagePort(DOMString localMessagePortName) raises(<ref>WebAPIException</ref>);

    <ref>RemoteMessagePort</ref> requestRemoteMessagePort(<ref>ApplicationId</ref> appId, DOMString remoteMessagePortName) raises(<ref>WebAPIException</ref>);

    <ref>RemoteMessagePort</ref> requestTrustedRemoteMessagePort(<ref>ApplicationId</ref> appId, DOMString remoteMessagePortName) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The <em>MessagePortManager</em> interface provides methods to request message port to communicate.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="requestLocalMessagePort" id="::MessagePort::MessagePortManager::requestLocalMessagePort">
        <webidl>    <ref>LocalMessagePort</ref> requestLocalMessagePort(DOMString localMessagePortName) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Requests a LocalMessage Port instance to start receiving message from another application.
            </brief>
            <version>
 2.1
            </version>
            <Code> // Requests the LocalMessagePort instance with the specified message port name
 var localMsgPort = tizen.messageport.requestLocalMessagePort('MessagePortA');
 </Code>
        </descriptive>
        <Type name="LocalMessagePort">
          <descriptive>
              <description><p>
 LocalMessagePort The LocalMessagePort instance.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="localMessagePortName">
            <descriptive>
                <description><p>
 The name of the local message port to retrieve.<br/>The LocalMessagePort instances are identical for the same message port name.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the input parameter contains an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="requestTrustedLocalMessagePort" id="::MessagePort::MessagePortManager::requestTrustedLocalMessagePort">
        <webidl>    <ref>LocalMessagePort</ref> requestTrustedLocalMessagePort(DOMString localMessagePortName) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Requests a trusted LocalMessagePort instance to receive message from another application.
            </brief>
           <description>
            <p>
Trusted local message port can communicate with applications that are signed with same certificate.
            </p>
           </description>
            <version>
 2.1
            </version>
            <Code> // Requests the LocalMessagePort instance with the specified message port name
 var localMsgPort = tizen.messageport.requestTrustedLocalMessagePort('MessagePortB');
 </Code>
        </descriptive>
        <Type name="LocalMessagePort">
          <descriptive>
              <description><p>
 LocalMessagePort The trusted LocalMessagePort instance.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="localMessagePortName">
            <descriptive>
                <description><p>
 The name of local message port.<br/>The LocalMessagePort instances are identical for the same message port name.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the input parameter contains an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="requestRemoteMessagePort" id="::MessagePort::MessagePortManager::requestRemoteMessagePort">
        <webidl>    <ref>RemoteMessagePort</ref> requestRemoteMessagePort(<ref>ApplicationId</ref> appId, DOMString remoteMessagePortName) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Requests a RemoteMessagePort instance to send message to another application.
            </brief>
           <description>
            <p>
If the message port name and application ID is the same, the platform returns the same RemoteMessagePort instance.
            </p>
           </description>
            <version>
 2.1
            </version>
            <Code> // Requests the RemoteMessagePort instance with the specified message port name
 var remoteMsgPort = tizen.messageport.requestRemoteMessagePort('6xaeuflskd.App1', 'MessagePortA');
 </Code>
        </descriptive>
        <Type name="RemoteMessagePort">
          <descriptive>
              <description><p>
 RemoteMessagePort The RemoteMessagePort instance.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="appId">
            <descriptive>
                <description><p>
 The ID of the application to send messages.
                </p></description>
            </descriptive>
            <Type name="ApplicationId"/>
          </Argument>
          <Argument name="remoteMessagePortName">
            <descriptive>
                <description><p>
 The name of remote message port.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if an input parameter contains an invalid value.
                </p></description>
                <description><p>
 with error type NotFoundError, if the port of the target application is not found.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="requestTrustedRemoteMessagePort" id="::MessagePort::MessagePortManager::requestTrustedRemoteMessagePort">
        <webidl>    <ref>RemoteMessagePort</ref> requestTrustedRemoteMessagePort(<ref>ApplicationId</ref> appId, DOMString remoteMessagePortName) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Requests a trusted RemoteMessagePort instance to receive message from another application.
            </brief>
           <description>
            <p>
If the message port name and application ID is the same, the platform returns the same RemoteMessagePort instance.
Trusted remote message port can communicate with applications that are signed with same certificate.
            </p>
           </description>
            <version>
 2.1
            </version>
            <Code> // Requests the RemoteMessagePort instance with the specified message port name.
 var remoteMsgPort = tizen.messageport.requestTrustedRemoteMessagePort('6xauflskd.App1', 'MessagePortB');
 </Code>
        </descriptive>
        <Type name="RemoteMessagePort">
          <descriptive>
              <description><p>
 RemoteMessagePort The trusted RemoteMessagePort instance.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="appId">
            <descriptive>
                <description><p>
 The ID of the application to send messages.
                </p></description>
            </descriptive>
            <Type name="ApplicationId"/>
          </Argument>
          <Argument name="remoteMessagePortName">
            <descriptive>
                <description><p>
 The name of remote message port.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if an input parameter contains an invalid value.
                </p></description>
                <description><p>
 with error type NotFoundError, if the port of the target application is not found.
                </p></description>
                <description><p>
 with error type InvalidAccessError, if the target application is not signed with the same certification.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="LocalMessagePort" id="::MessagePort::LocalMessagePort">
      <webidl>  [NoInterfaceObject] interface LocalMessagePort {

    readonly attribute DOMString messagePortName;

    readonly attribute boolean isTrusted;

    long addMessagePortListener(<ref>MessagePortCallback</ref> listener) raises(<ref>WebAPIException</ref>);

    void removeMessagePortListener(long watchId) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The <em>LocalMessagePort</em> interface provides methods to receive data.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="messagePortName" id="::MessagePort::LocalMessagePort::messagePortName">
        <webidl>    readonly attribute DOMString messagePortName;</webidl>
        <descriptive>
            <brief>
 An attribute that stores the name of the message port name.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="isTrusted" id="::MessagePort::LocalMessagePort::isTrusted">
        <webidl>    readonly attribute boolean isTrusted;</webidl>
        <descriptive>
            <brief>
 An attribute that determines whether the message port is trusted or not.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="addMessagePortListener" id="::MessagePort::LocalMessagePort::addMessagePortListener">
        <webidl>    long addMessagePortListener(<ref>MessagePortCallback</ref> listener) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a message port listener to receive messages from other applications.
            </brief>
            <version>
 2.1.
            </version>
            <Code> function onreceived(data, remoteMsgPort) {
   console.log('Received data to \'' + remoteMsgPort.messagePortName + '\'');
 }

 var localMsgPort = tizen.messageport.requestLocalMessagePort('MessagePortA');
 var watchId = localMsgPort.addMessagePortListener(onreceived);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long ID of the listener that is later used to remove the listener.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="listener">
            <descriptive>
                <description><p>
 The method to invoke when a message is received.
                </p></description>
            </descriptive>
            <Type name="MessagePortCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the input parameter contains an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeMessagePortListener" id="::MessagePort::LocalMessagePort::removeMessagePortListener">
        <webidl>    void removeMessagePortListener(long watchId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes the message port listener.
            </brief>
            <version>
 2.1.
            </version>
            <Code> var localMsgPort = tizen.messageport.requestLocalMessagePort('MessagePortA');
 var watchId = localMsgPort.addMessagePortListener(onreceived);
 // Communication routines of your app...
 localMsgPort.removeMessagePortListener(watchId);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="watchId">
            <descriptive>
                <description><p>
 ID to identify the listener.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the input parameter contains an invalid value.
                </p></description>
                <description><p>
 with error type NotFoundError, if the watch ID has not been found.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="RemoteMessagePort" id="::MessagePort::RemoteMessagePort">
      <webidl>  [NoInterfaceObject] interface RemoteMessagePort {

    readonly attribute DOMString messagePortName;

    readonly attribute <ref>ApplicationId</ref> appId;

    readonly attribute boolean isTrusted;

    void sendMessage(<ref>MessagePortDataItem</ref>[] data, optional <ref>LocalMessagePort</ref>? localMessagePort) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The <em>RemoteMessagePort</em> interface provides methods to send messages.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="messagePortName" id="::MessagePort::RemoteMessagePort::messagePortName">
        <webidl>    readonly attribute DOMString messagePortName;</webidl>
        <descriptive>
            <brief>
 An attribute to store the message port name.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="appId" id="::MessagePort::RemoteMessagePort::appId">
        <webidl>    readonly attribute <ref>ApplicationId</ref> appId;</webidl>
        <descriptive>
            <brief>
 An attribute that store the application ID to connect with.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="ApplicationId"/>
      </Attribute>
      <Attribute readonly="readonly" name="isTrusted" id="::MessagePort::RemoteMessagePort::isTrusted">
        <webidl>    readonly attribute boolean isTrusted;</webidl>
        <descriptive>
            <brief>
 An attribute that determines whether the message port is trusted or not.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="sendMessage" id="::MessagePort::RemoteMessagePort::sendMessage">
        <webidl>    void sendMessage(<ref>MessagePortDataItem</ref>[] data, optional <ref>LocalMessagePort</ref>? localMessagePort) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sends messages to the specified application.
            </brief>
           <description>
            <p>
The sent messages will be ignored without any notice, unless the target application added one or more listeners to the target local message port.
            </p>
           </description>
            <version>
 2.1
            </version>
            <Code> // Sends message
 var localMsgPort = tizen.messageport.requestLocalMessagePort('MessagePortA');
 var remoteMsgPort = tizen.messageport.requestRemoteMessagePort('6xaeuflskd.App1', 'MessagePortB');
 localMsgPort.addMessagePortListener(function(items, remoteport) {
   // ...
   if(remoteport !== null) {
     remoteport.sendMessage([{key:'RESULT', value:'OK'}]);
   }
 });
 remoteMsgPort.sendMessage(
   [
     { key:'CMD', value:'openWindow' },
     { key:'OPTION', value:'bx' }
   ]
   , localMsgPort);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="data">
            <descriptive>
                <description><p>
 Data array of data to send.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessagePortDataItem"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="localMessagePort">
            <descriptive>
                <description><p>
 <em>LocalMessagePort<em> object that gives local message port of the current application. It can be used to receive reply messages from the other end of the message port. The order of items in this array is not guaranteed to be preserved during data transfer, and values of <em>key</em> within this array must not be duplicated or empty.
</em></em>                </p></description>
            </descriptive>
            <Type name="LocalMessagePort" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if an input parameter contains an invalid value.
                </p></description>
                <description><p>
 with error type QuotaExceededError, if the size of message has exceeded the maximum limit.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Dictionary name="MessagePortDataItem" id="::MessagePort::MessagePortDataItem">
      <webidl>  dictionary MessagePortDataItem {
    DOMString key;
    DOMString value;
  };</webidl>
      <descriptive>
          <brief>
 A dictionary for specifying the data item that is transferred.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <DictionaryMember name="key" id="::MessagePort::MessagePortDataItem::key">
        <webidl>    DOMString key;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="value" id="::MessagePort::MessagePortDataItem::value">
        <webidl>    DOMString value;</webidl>
        <Type type="DOMString"/>
      </DictionaryMember>
    </Dictionary>
    <Interface name="MessagePortCallback" id="::MessagePort::MessagePortCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface MessagePortCallback {
    void onreceived(<ref>MessagePortDataItem</ref>[] data, <ref>RemoteMessagePort</ref>? remoteMessagePort);
  };</webidl>
      <descriptive>
          <brief>
 This interface defines notification callbacks for receiving data from other applications.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onreceived" id="::MessagePort::MessagePortCallback::onreceived">
        <webidl>    void onreceived(<ref>MessagePortDataItem</ref>[] data, <ref>RemoteMessagePort</ref>? remoteMessagePort);</webidl>
        <descriptive>
            <brief>
 Called when data is received from other applications via the specified message port name.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="data">
            <descriptive>
                <description><p>
 An array of data received from another application.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessagePortDataItem"/>
            </Type>
          </Argument>
          <Argument name="remoteMessagePort">
            <descriptive>
                <description><p>
 The RemoteMessagePort port that can be used to reply for the received message.
                </p></description>
            </descriptive>
            <Type name="RemoteMessagePort" nullable="nullable"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Messaging" id="::Messaging">
    <webidl>module Messaging {

  [NoInterfaceObject] interface MessageManagerObject {
    readonly attribute <ref>Messaging</ref> messaging;
  };
  <ref>Tizen</ref> implements <ref>MessageManagerObject</ref>;

  enum MessageServiceTag {&quot;messaging.sms&quot;, &quot;messaging.mms&quot;, &quot;messaging.email&quot; };

  typedef DOMString MessageId;

  typedef DOMString MessageAttachmentId;

  typedef DOMString MessageConvId;

  typedef DOMString MessageFolderId;

  [Constructor(<ref>MessageServiceTag</ref> type, optional <ref>MessageInit</ref>? messageInitDict)]
  interface Message {

    readonly attribute <ref>MessageId</ref>? id;

    readonly attribute <ref>MessageConvId</ref>? conversationId;

    readonly attribute <ref>MessageFolderId</ref>? folderId;

    readonly attribute <ref>MessageServiceTag</ref> type;

    readonly attribute Date? timestamp;

    readonly attribute DOMString? from;

    attribute DOMString[] to setraises(<ref>WebAPIException</ref>);

    attribute DOMString[] cc setraises(<ref>WebAPIException</ref>);

    attribute DOMString[] bcc setraises(<ref>WebAPIException</ref>);

    attribute <ref>MessageBody</ref> body setraises(<ref>WebAPIException</ref>);

    attribute boolean isRead setraises(<ref>WebAPIException</ref>);

    readonly attribute boolean hasAttachment;

    attribute boolean isHighPriority setraises(<ref>WebAPIException</ref>);

    attribute DOMString subject setraises(<ref>WebAPIException</ref>);

    readonly attribute <ref>MessageId</ref>? inResponseTo setraises(<ref>WebAPIException</ref>);

    readonly attribute DOMString messageStatus;

    attribute <ref>MessageAttachment</ref>[] attachments setraises(<ref>WebAPIException</ref>);
  };
  dictionary MessageInit
  {

    DOMString subject;

    DOMString[] to;

    DOMString[] cc;

    DOMString[] bcc;

    DOMString plainBody;

    DOMString htmlBody;

    boolean isHighPriority;
  };

  [NoInterfaceObject] interface MessageBody {

    readonly attribute <ref>MessageId</ref> messageId;

    readonly attribute boolean loaded;

    attribute DOMString plainBody setraises(<ref>WebAPIException</ref>);

    attribute DOMString htmlBody setraises(<ref>WebAPIException</ref>);

    attribute <ref>MessageAttachment</ref>[] inlineAttachments setraises(<ref>WebAPIException</ref>);
  };

  [Constructor(DOMString filePath, optional DOMString? mimeType)]
  interface MessageAttachment {

    readonly attribute <ref>MessageAttachmentId</ref>? id;

    readonly attribute <ref>MessageId</ref>? messageId;

    readonly attribute DOMString? mimeType;

    readonly attribute DOMString? filePath;
  };

  [NoInterfaceObject] interface Messaging {

    void getMessageServices(<ref>MessageServiceTag</ref> messageServiceType,
                            <ref>MessageServiceArraySuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface MessageServiceArraySuccessCallback {

    void onsuccess(<ref>MessageService</ref>[] services);

  };


  [NoInterfaceObject] interface MessageService {

    readonly attribute DOMString id;

    readonly attribute <ref>MessageServiceTag</ref> type;

    readonly attribute DOMString name;

    void sendMessage(<ref>Message</ref> message,
                     optional <ref>MessageRecipientsCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void loadMessageBody(<ref>Message</ref> message,
                         <ref>MessageBodySuccessCallback</ref> successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void loadMessageAttachment(<ref>MessageAttachment</ref> attachment,
                               <ref>MessageAttachmentSuccessCallback</ref> successCallback,
                               optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    long sync(optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional unsigned long? limit) raises(<ref>WebAPIException</ref>);

    long syncFolder(<ref>MessageFolder</ref> folder,
                    optional <ref>SuccessCallback</ref>? successCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback,
                    optional unsigned long? limit) raises(<ref>WebAPIException</ref>);

    void stopSync(long opId) raises(<ref>WebAPIException</ref>);

    readonly attribute <ref>MessageStorage</ref> messageStorage getraises(<ref>WebAPIException</ref>);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface MessageRecipientsCallback {

    void onsuccess(DOMString[] recipients);

   };

  [Callback=FunctionOnly, NoInterfaceObject] interface MessageBodySuccessCallback {

     void onsuccess(<ref>Message</ref> message);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface MessageAttachmentSuccessCallback {

     void onsuccess(<ref>MessageAttachment</ref> attachment);
   };

  [NoInterfaceObject] interface MessageStorage {

    void addDraftMessage(<ref>Message</ref> message,
                         optional <ref>SuccessCallback</ref>? successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void findMessages(<ref>AbstractFilter</ref> filter,
                      <ref>MessageArraySuccessCallback</ref> successCallback,
                      optional <ref>ErrorCallback</ref>? errorCallback,
                      optional <ref>SortMode</ref>? sort,
                      optional unsigned long? limit,
                      optional unsigned long? offset) raises(<ref>WebAPIException</ref>);

    void removeMessages(<ref>Message</ref>[] messages,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void updateMessages(<ref>Message</ref>[] messages,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void findConversations(<ref>AbstractFilter</ref> filter,
                           <ref>MessageConversationArraySuccessCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback,
                           optional <ref>SortMode</ref>? sort,
                           optional unsigned long? limit,
                           optional unsigned long? offset) raises(<ref>WebAPIException</ref>);

    void removeConversations(<ref>MessageConversation</ref>[] conversations,
                             optional <ref>SuccessCallback</ref>? successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);


    void findFolders(<ref>AbstractFilter</ref> filter,
                     <ref>MessageFolderArraySuccessCallback</ref> successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    long addMessagesChangeListener(<ref>MessagesChangeCallback</ref> messagesChangeCallback,
                                   optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);

    long addConversationsChangeListener(<ref>MessageConversationsChangeCallback</ref> conversationsChangeCallback,
                                        optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);

    long addFoldersChangeListener(<ref>MessageFoldersChangeCallback</ref> foldersChangeCallback,
                                  optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);

    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface MessageArraySuccessCallback {

    void onsuccess(<ref>Message</ref>[] messages);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface MessageConversationArraySuccessCallback {

    void onsuccess(<ref>MessageConversation</ref>[] conversations);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface MessageFolderArraySuccessCallback {

    void onsuccess(<ref>MessageFolder</ref>[] folders);
  };

  [Callback, NoInterfaceObject] interface MessagesChangeCallback {

    void messagesadded(<ref>Message</ref>[] addedMessages);

    void messagesupdated(<ref>Message</ref>[] updatedMessages);

    void messagesremoved(<ref>Message</ref>[] removedMessages);
  };

  [Callback, NoInterfaceObject] interface MessageConversationsChangeCallback {

    void conversationsadded(<ref>MessageConversation</ref>[] addedConversations);

    void conversationsupdated(<ref>MessageConversation</ref>[] updatedConversations);

    void conversationsremoved(<ref>MessageConversation</ref>[] removedConversations);
  };

  [Callback, NoInterfaceObject] interface MessageFoldersChangeCallback {

    void foldersadded(<ref>MessageFolder</ref>[] addedFolders);

    void foldersupdated(<ref>MessageFolder</ref>[] updatedFolders);

    void foldersremoved(<ref>MessageFolder</ref>[] removedFolders);
  };

  [NoInterfaceObject] interface MessageConversation {

    readonly attribute <ref>MessageConvId</ref> id;

    readonly attribute <ref>MessageServiceTag</ref> type;

    readonly attribute Date timestamp;

    readonly attribute unsigned long messageCount;

    readonly attribute unsigned long unreadMessages;

    readonly attribute DOMString preview;

    readonly attribute DOMString subject;

    readonly attribute boolean isRead;

    readonly attribute DOMString from;

    readonly attribute DOMString[] to;

    readonly attribute DOMString[] cc;

    readonly attribute DOMString[] bcc;

    readonly attribute <ref>MessageId</ref> lastMessageId;
  };

  [NoInterfaceObject] interface MessageFolder {

    readonly attribute <ref>MessageFolderId</ref> id;

    readonly attribute <ref>MessageFolderId</ref> parentId;

    readonly attribute DOMString serviceId;

    readonly attribute <ref>MessageServiceTag</ref> contentType;

    attribute DOMString name setraises(<ref>WebAPIException</ref>);

    readonly attribute DOMString path;

    readonly attribute DOMString type;

    attribute boolean synchronizable setraises(<ref>WebAPIException</ref>);
  };

};</webidl>
    <descriptive>
        <brief>
 This API provides interfaces and methods for managing SMS, MMS, and email messages.
        </brief>
       <description>
        <p>
The Messaging API provides access to these capabilities:
        </p>
        <ul>
          <li>
Sending messages through different technologies: SMS, MMS, and email messages.          </li>
          <li>
Retrieving available message services.          </li>
          <li>
Searching for messages.          </li>
          <li>
Managing messages: update, delete, and add.          </li>
          <li>
Subscribing to receive notifications of message storage modifications.          </li>
          <li>
Fetching conversations and subscribing to conversation updates.          </li>
        </ul>
        <p>
For more information on the Messaging features, see <a href="../../org.tizen.web.appprogramming/html/guide/communication_guide/messaging.htm">Messaging Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
        <def-api-feature identifier="http://tizen.org/feature/network.telephony">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with SMS feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
        <def-api-feature identifier="http://tizen.org/feature/network.telephony.mms">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with MMS feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
    </descriptive>
    <Interface name="MessageManagerObject" id="::Messaging::MessageManagerObject">
      <webidl>  [NoInterfaceObject] interface MessageManagerObject {
    readonly attribute <ref>Messaging</ref> messaging;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the Tizen object.
          </brief>
         <description>
          <p>
There is a <em>tizen.messaging </em>object that allows access to the Messaging API.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="messaging" id="::Messaging::MessageManagerObject::messaging">
        <webidl>    readonly attribute <ref>Messaging</ref> messaging;</webidl>
        <Type name="Messaging"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="MessageManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>MessageManagerObject</ref>;</webidl>
    </Implements>
    <Enum name="MessageServiceTag" id="::Messaging::MessageServiceTag">
      <webidl>  enum MessageServiceTag {&quot;messaging.sms&quot;, &quot;messaging.mms&quot;, &quot;messaging.email&quot; };</webidl>
      <descriptive>
          <brief>
 The supported Messaging service tags.
The following values are supported in this release:
          </brief>
         <description>
          <ul>
            <li>
messaging.sms, for SMS services            </li>
            <li>
messaging.mms, for MMS services            </li>
            <li>
messaging.email, for email services            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="messaging.sms">
        <webidl>&quot;messaging.sms</webidl>
      </EnumValue>
      <EnumValue stringvalue="messaging.mms">
        <webidl> &quot;messaging.mms</webidl>
      </EnumValue>
      <EnumValue stringvalue="messaging.email">
        <webidl> &quot;messaging.email</webidl>
      </EnumValue>
    </Enum>
    <Typedef name="MessageId" id="::Messaging::MessageId">
      <webidl>  typedef DOMString MessageId;</webidl>
      <descriptive>
          <brief>
 The Message identifier.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="MessageAttachmentId" id="::Messaging::MessageAttachmentId">
      <webidl>  typedef DOMString MessageAttachmentId;</webidl>
      <descriptive>
          <brief>
 The MessageAttachment identifier within a message.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="MessageConvId" id="::Messaging::MessageConvId">
      <webidl>  typedef DOMString MessageConvId;</webidl>
      <descriptive>
          <brief>
 The MessageConversation identifier.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Typedef name="MessageFolderId" id="::Messaging::MessageFolderId">
      <webidl>  typedef DOMString MessageFolderId;</webidl>
      <descriptive>
          <brief>
 The identifier of an email folder .
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Interface name="Message" id="::Messaging::Message">
      <webidl>  [Constructor(<ref>MessageServiceTag</ref> type, optional <ref>MessageInit</ref>? messageInitDict)]
  interface Message {

    readonly attribute <ref>MessageId</ref>? id;

    readonly attribute <ref>MessageConvId</ref>? conversationId;

    readonly attribute <ref>MessageFolderId</ref>? folderId;

    readonly attribute <ref>MessageServiceTag</ref> type;

    readonly attribute Date? timestamp;

    readonly attribute DOMString? from;

    attribute DOMString[] to setraises(<ref>WebAPIException</ref>);

    attribute DOMString[] cc setraises(<ref>WebAPIException</ref>);

    attribute DOMString[] bcc setraises(<ref>WebAPIException</ref>);

    attribute <ref>MessageBody</ref> body setraises(<ref>WebAPIException</ref>);

    attribute boolean isRead setraises(<ref>WebAPIException</ref>);

    readonly attribute boolean hasAttachment;

    attribute boolean isHighPriority setraises(<ref>WebAPIException</ref>);

    attribute DOMString subject setraises(<ref>WebAPIException</ref>);

    readonly attribute <ref>MessageId</ref>? inResponseTo setraises(<ref>WebAPIException</ref>);

    readonly attribute DOMString messageStatus;

    attribute <ref>MessageAttachment</ref>[] attachments setraises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 Defines the content and attributes of a message.
          </brief>
         <description>
          <p>
This interface allows a web application to define the set of properties
linked to a message.
          </p>
          <p>
It also allows an application to retrieve the content of a
message through <em>MessageStorage </em>methods. In these
cases, the implementation can return, in some situations, only the meta-information
of a message without the loaded body. In such situations, the method <em>MessageService.loadMessageBody() </em>should be used.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> // Define the success callback.
 var messageSentCallback = function(recipients) {
   console.log(&quot;Message sent successfully to &quot; + recipients.length + &quot; recipients.&quot;);
 }

 // Define the error callback.
 function errorCallback(err) {
   console.log(err.name + &quot; error: &quot; + err.message);
 }

 function serviceListCB(services) {
   if (services.length > 0) {
      var msg = new tizen.Message(&quot;messaging.sms&quot;, {plainBody: &quot;Tizen first SMS message.&quot;});
      services[0].sendMessage(msg, messageSentCallback, errorCallback);
   }
 }

 tizen.messaging.getMessageServices(&quot;messaging.sms&quot;,
                                    serviceListCB,
                                    errorCallback);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(<ref>MessageServiceTag</ref> type, optional <ref>MessageInit</ref>? messageInitDict)</webidl>
          <ArgumentList>
            <Argument name="type">
              <Type name="MessageServiceTag"/>
            </Argument>
            <Argument optional="optional" name="messageInitDict">
              <Type name="MessageInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Messaging::Message::id">
        <webidl>    readonly attribute <ref>MessageId</ref>? id;</webidl>
        <descriptive>
            <brief>
 The message identifier.
            </brief>
           <description>
            <p>
The ID is locally unique and persistent property, assigned by the device or the Web runtime (WRT).
For new messages created using the Message constructor, the ID is assigned on the first occasion when a message is processed by the underlying platform, such as a call to MessageService.send(). Before the ID is assigned, it is set to <var>null</var>.
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="conversationId" id="::Messaging::Message::conversationId">
        <webidl>    readonly attribute <ref>MessageConvId</ref>? conversationId;</webidl>
        <descriptive>
            <brief>
 The identifier of the conversation to which the message belongs.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageConvId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="folderId" id="::Messaging::Message::folderId">
        <webidl>    readonly attribute <ref>MessageFolderId</ref>? folderId;</webidl>
        <descriptive>
            <brief>
 The identifier of the folder to which the message belongs.
            </brief>
           <description>
            <p>
By default, this attribute is set to null.
            </p>
            <p>
For SMS and MMS, <em>folderId </em>can be one of these values:
            </p>
            <ul>
              <li>
INBOX = 1,              </li>
              <li>
OUTBOX = 2,              </li>
              <li>
DRAFTS = 3,              </li>
              <li>
SENTBOX = 4              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageFolderId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::Messaging::Message::type">
        <webidl>    readonly attribute <ref>MessageServiceTag</ref> type;</webidl>
        <descriptive>
            <brief>
 The type of a given message.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageServiceTag"/>
      </Attribute>
      <Attribute readonly="readonly" name="timestamp" id="::Messaging::Message::timestamp">
        <webidl>    readonly attribute Date? timestamp;</webidl>
        <descriptive>
            <brief>
 The timestamp of a message.
            </brief>
           <description>
            <p>
For a received message, the timestamps indicates the time at which a message is received.
For a sent message, the timestamp indicates the time at which a message is sent.
For a draft message, the timestamp indicates the time at which a message is added.
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="from" id="::Messaging::Message::from">
        <webidl>    readonly attribute DOMString? from;</webidl>
        <descriptive>
            <brief>
 The source address (or source phone number) of a message.
            </brief>
           <description>
            <p>
This property is set up by the device or the web runtime environment.
By default, this attribute is set to null.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="to" id="::Messaging::Message::to">
        <webidl>    attribute DOMString[] to setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The destination of a message.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="cc" id="::Messaging::Message::cc">
        <webidl>    attribute DOMString[] cc setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The carbon copy address of a message.
            </brief>
           <description>
            <p>
This property is used only for email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="bcc" id="::Messaging::Message::bcc">
        <webidl>    attribute DOMString[] bcc setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The blind carbon copy (bcc) address of a message.
            </brief>
           <description>
            <p>
This property is used only with email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="body" id="::Messaging::Message::body">
        <webidl>    attribute <ref>MessageBody</ref> body setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the body of a message.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageBody"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="isRead" id="::Messaging::Message::isRead">
        <webidl>    attribute boolean isRead setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the read state for a message.
            </brief>
           <description>
            <p>
This property is set to <var>true</var> if the message has been read. Else it is set to <var>false</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="hasAttachment" id="::Messaging::Message::hasAttachment">
        <webidl>    readonly attribute boolean hasAttachment;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate whether an attachment(s) exists or not.
            </brief>
           <description>
            <p>
It is set to <var>true</var> if a message has one or more attachments.
            </p>
            <p>
This property is used only with email and MMS messages.(It is valid when body is loaded)
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="isHighPriority" id="::Messaging::Message::isHighPriority">
        <webidl>    attribute boolean isHighPriority setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to indicate the priority of a message.
            </brief>
           <description>
            <p>
It is set to <var>true</var> if the message has a high priority. Else it is set to <var>false</var>, if the message has a normal or low priority.
            </p>
            <p>
This property is used only with email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="subject" id="::Messaging::Message::subject">
        <webidl>    attribute DOMString subject setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to store the subject of a message.
            </brief>
           <description>
            <p>
This property is used only with email and MMS messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="inResponseTo" id="::Messaging::Message::inResponseTo">
        <webidl>    readonly attribute <ref>MessageId</ref>? inResponseTo setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The identifier of the original message.
            </brief>
           <description>
            <p>
If the message was replied to or forwarded, this property contains the ID of the original message, otherwise it is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageId" nullable="nullable"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="messageStatus" id="::Messaging::Message::messageStatus">
        <webidl>    readonly attribute DOMString messageStatus;</webidl>
        <descriptive>
            <brief>
 The status of a given message.
            </brief>
           <description>
            <p>
It can be one of these values:
            </p>
            <ul>
              <li>
SENT              </li>
              <li>
SENDING              </li>
              <li>
FAILED              </li>
              <li>
DRAFT              </li>
            </ul>
            <p>
If the status of the current message does not correspond to any item from
the list, an empty value is returned.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="attachments" id="::Messaging::Message::attachments">
        <webidl>    attribute <ref>MessageAttachment</ref>[] attachments setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The list of the message attachments.
            </brief>
           <description>
            <p>
This array is empty if the message does not have attachments or the message body is not loaded and the attachment info is inaccessible (in this case, the <em>hasAttachment</em> attribute is checked after loading message body).
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // Define the success callback.
 function serviceListCB(services) {
     if (services.length > 0) {
         var msg = new tizen.Message(&quot;messaging.email&quot;);
         msg.attachments = [new tizen.MessageAttachment(&quot;images/myimage.png&quot;, &quot;image/png&quot;),
                            new tizen.MessageAttachment(&quot;documents/mydoc.pdf&quot;, &quot;text/pdf&quot;)];
     }
 }

 tizen.messaging.getMessageServices(&quot;messaging.email&quot;, serviceListCB);


</Code>
        </descriptive>
        <Type type="array">
          <Type name="MessageAttachment"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
    </Interface>
    <Dictionary name="MessageInit" id="::Messaging::MessageInit">
      <webidl>  dictionary MessageInit
  {

    DOMString subject;

    DOMString[] to;

    DOMString[] cc;

    DOMString[] bcc;

    DOMString plainBody;

    DOMString htmlBody;

    boolean isHighPriority;
  };</webidl>
      <descriptive>
          <brief>
 Provides specific message attributes upon message creation.
          </brief>
         <description>
          <p>
This interface is used to input parameters when messages are created using
the Message constructor.
          </p>
          <p>
All the attributes are optional and are <var>undefined </var>by default, unless otherwise stated in the parameter description.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="subject" id="::Messaging::MessageInit::subject">
        <webidl>    DOMString subject;</webidl>
        <descriptive>
            <brief>
 The subject of a message.
            </brief>
           <description>
            <p>
This property is used only with email and MMS messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="to" id="::Messaging::MessageInit::to">
        <webidl>    DOMString[] to;</webidl>
        <descriptive>
            <brief>
 The destination addresses (or phone numbers) of a message.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="cc" id="::Messaging::MessageInit::cc">
        <webidl>    DOMString[] cc;</webidl>
        <descriptive>
            <brief>
 The carbon copy addresses of a message.
            </brief>
           <description>
            <p>
This property is used only with email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="bcc" id="::Messaging::MessageInit::bcc">
        <webidl>    DOMString[] bcc;</webidl>
        <descriptive>
            <brief>
 The blind carbon copy addresses of a message.
            </brief>
           <description>
            <p>
This property is used only with email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="plainBody" id="::Messaging::MessageInit::plainBody">
        <webidl>    DOMString plainBody;</webidl>
        <descriptive>
            <brief>
 The plain text representation of a message body.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="htmlBody" id="::Messaging::MessageInit::htmlBody">
        <webidl>    DOMString htmlBody;</webidl>
        <descriptive>
            <brief>
 The HTML representation of a message body.
            </brief>
           <description>
            <p>
This property is used only with email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </DictionaryMember>
      <DictionaryMember name="isHighPriority" id="::Messaging::MessageInit::isHighPriority">
        <webidl>    boolean isHighPriority;</webidl>
        <descriptive>
            <brief>
 The priority of a message.
            </brief>
           <description>
            <p>
This property is set to <var>true</var> if the message has a high priority. Else it is set to <var>false</var> if the message has a normal or low priority.
            </p>
            <p>
This property is used only with email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </DictionaryMember>
    </Dictionary>
    <Interface name="MessageBody" id="::Messaging::MessageBody">
      <webidl>  [NoInterfaceObject] interface MessageBody {

    readonly attribute <ref>MessageId</ref> messageId;

    readonly attribute boolean loaded;

    attribute DOMString plainBody setraises(<ref>WebAPIException</ref>);

    attribute DOMString htmlBody setraises(<ref>WebAPIException</ref>);

    attribute <ref>MessageAttachment</ref>[] inlineAttachments setraises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface describes a message body.
          </brief>
         <description>
          <p>
Message body is comprised of a plain text, an HTML, and inline attachments.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="messageId" id="::Messaging::MessageBody::messageId">
        <webidl>    readonly attribute <ref>MessageId</ref> messageId;</webidl>
        <descriptive>
            <brief>
 The ID of a parent message.
            </brief>
           <description>
            <p>
It holds the ID of the message containing this body.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageId"/>
      </Attribute>
      <Attribute readonly="readonly" name="loaded" id="::Messaging::MessageBody::loaded">
        <webidl>    readonly attribute boolean loaded;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate whether the message body has been loaded or not.
            </brief>
           <description>
            <p>
It is set to <var>true </var>if the message body is loaded, else it is set to<var> false </var>if the object is not loaded.
The default value is <var>false</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="plainBody" id="::Messaging::MessageBody::plainBody">
        <webidl>    attribute DOMString plainBody setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The plain text representation of a message body.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="htmlBody" id="::Messaging::MessageBody::htmlBody">
        <webidl>    attribute DOMString htmlBody setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The HTML representation of a message body.
            </brief>
           <description>
            <p>
This attribute holds an empty string if the message does not have any HTML body content.
This property is used only with email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="inlineAttachments" id="::Messaging::MessageBody::inlineAttachments">
        <webidl>    attribute <ref>MessageAttachment</ref>[] inlineAttachments setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The list of the inline attachments.
            </brief>
           <description>
            <p>
This array is empty, if the message does not have inline attachment or the message body is not loaded and attachments info is inaccessible (in this case the <em>loaded</em> attribute is checked).
            </p>
            <p>
To indicate where to show an inline attachment within the HTML body, a link of the following format should be provided:
&quot;&lt;img src=&quot;The file name of a inline attachment&quot;>&quot;
This property is used only with email messages.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // Define the success callback.
 function serviceListCB(services) {
     if (services.length > 0) {
         var msg = new tizen.Message(&quot;messaging.email&quot;);
         msg.body.htmlBody = &quot;&lt;html>&lt;body>&lt;img src='myimage.png'>&lt;/body>&lt;/html>&quot;;
         msg.body.inlineAttachments = [new tizen.MessageAttachment(&quot;images/myimage.png&quot;)];
     }
 }

 tizen.messaging.getMessageServices(&quot;messaging.email&quot;, serviceListCB);

 </Code>
        </descriptive>
        <Type type="array">
          <Type name="MessageAttachment"/>
        </Type>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
    </Interface>
    <Interface name="MessageAttachment" id="::Messaging::MessageAttachment">
      <webidl>  [Constructor(DOMString filePath, optional DOMString? mimeType)]
  interface MessageAttachment {

    readonly attribute <ref>MessageAttachmentId</ref>? id;

    readonly attribute <ref>MessageId</ref>? messageId;

    readonly attribute DOMString? mimeType;

    readonly attribute DOMString? filePath;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the content and attributes of a message attachment.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString filePath, optional DOMString? mimeType)</webidl>
          <ArgumentList>
            <Argument name="filePath">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="mimeType">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Messaging::MessageAttachment::id">
        <webidl>    readonly attribute <ref>MessageAttachmentId</ref>? id;</webidl>
        <descriptive>
            <brief>
 The ID of an attachment.
            </brief>
           <description>
            <p>
It holds the identifier of the attachment within its parent message.
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageAttachmentId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="messageId" id="::Messaging::MessageAttachment::messageId">
        <webidl>    readonly attribute <ref>MessageId</ref>? messageId;</webidl>
        <descriptive>
            <brief>
 The ID of a parent message.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageId" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="mimeType" id="::Messaging::MessageAttachment::mimeType">
        <webidl>    readonly attribute DOMString? mimeType;</webidl>
        <descriptive>
            <brief>
 The attachment MIME type.
            </brief>
           <description>
            <p>
It describes the MIME type of an attachment, for example; &quot;text/html&quot;.
            </p>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute readonly="readonly" name="filePath" id="::Messaging::MessageAttachment::filePath">
        <webidl>    readonly attribute DOMString? filePath;</webidl>
        <descriptive>
            <brief>
 The location path to a loaded attachment file.
            </brief>
           <description>
            <p>
It holds the location path to a loaded attachment file, appropriate for the Filesystem API. It is set to <var>null</var> if the attachment is not loaded from the remote servaer.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="Messaging" id="::Messaging::Messaging">
      <webidl>  [NoInterfaceObject] interface Messaging {

    void getMessageServices(<ref>MessageServiceTag</ref> messageServiceType,
                            <ref>MessageServiceArraySuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface retrieves messaging services.
          </brief>
         <description>
          <p>
Fetches all existing messaging services by type or a messaging service of a given type
for concrete account.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> // Define the success callback.
 function serviceListCB(services) {
   if (services.length > 0) {
     var msg = new tizen.Message(&quot;messaging.sms&quot;);
   }
 }

 // Define error callback.
 function errorCallback(error) {
   console.log(&quot;Cannot get messaging service &quot; + error.message);
 }

 tizen.messaging.getMessageServices(&quot;messaging.sms&quot;, serviceListCB,
                                     errorCallback);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getMessageServices" id="::Messaging::Messaging::getMessageServices">
        <webidl>    void getMessageServices(<ref>MessageServiceTag</ref> messageServiceType,
                            <ref>MessageServiceArraySuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the messaging service of a given type for a given account, or all existing services supporting the given type, if <em>serviceId </em>is not given.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value, the encoding is not valid or onsuccess is null.
Please note that to allow developers to ignore errors, errorCallback accepts null as a valid value.              </li>
              <li>
UnknownError - In any other error case.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <Code> // Define the error callback.
 function errorCallback(error) {
   console.log(&quot;Cannot get messaging service &quot; + error.message);
 }

 // Define the success callback.
 function serviceListCB(services) {
   console.log(&quot;Found &quot; + services.length + &quot;email services&quot;);
 }

 tizen.messaging.getMessageServices(&quot;messaging.email&quot;, serviceListCB,
                                      errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="messageServiceType">
            <descriptive>
                <description><p>
 Type of the services to be retrieved.
                </p></description>
            </descriptive>
            <Type name="MessageServiceTag"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method invoked when the services are successfully retrieved.
                </p></description>
            </descriptive>
            <Type name="MessageServiceArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method invoked when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="MessageServiceArraySuccessCallback" id="::Messaging::MessageServiceArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface MessageServiceArraySuccessCallback {

    void onsuccess(<ref>MessageService</ref>[] services);

  };</webidl>
      <descriptive>
          <brief>
 Defines callback(s) for retrieving message services.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Messaging::MessageServiceArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>MessageService</ref>[] services);</webidl>
        <descriptive>
            <brief>
 Called when finding message services is successful.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="services">
            <descriptive>
                <description><p>
 Array of available <em>MessageService</em> objects on the device.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageService"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageService" id="::Messaging::MessageService">
      <webidl>  [NoInterfaceObject] interface MessageService {

    readonly attribute DOMString id;

    readonly attribute <ref>MessageServiceTag</ref> type;

    readonly attribute DOMString name;

    void sendMessage(<ref>Message</ref> message,
                     optional <ref>MessageRecipientsCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void loadMessageBody(<ref>Message</ref> message,
                         <ref>MessageBodySuccessCallback</ref> successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void loadMessageAttachment(<ref>MessageAttachment</ref> attachment,
                               <ref>MessageAttachmentSuccessCallback</ref> successCallback,
                               optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    long sync(optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional unsigned long? limit) raises(<ref>WebAPIException</ref>);

    long syncFolder(<ref>MessageFolder</ref> folder,
                    optional <ref>SuccessCallback</ref>? successCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback,
                    optional unsigned long? limit) raises(<ref>WebAPIException</ref>);

    void stopSync(long opId) raises(<ref>WebAPIException</ref>);

    readonly attribute <ref>MessageStorage</ref> messageStorage getraises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface allows a web application to manipulate and send messages and supports the message creating, sending, and fetching capabilities.
          </brief>
         <description>
          <p>
Messages created through this API are not persistent in device memory until the implementation attempts to send the message using the sendMessage() method. On performing the sendMessage() method, the message is available in the relevant folder (such as sent and drafts), depending on the result of the operation.
          </p>
          <p>
The interface allows fetching of messages for all folders belonging to one account, with synchronizable flag set, using the sync() method, or for a given folder using the syncFolder() method.
          </p>
          <p>
The interface allows fetching of the message body for a given message using loadMessageBody() method.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> // Define the success callback.
 function messageSent(recipients) {
   console.log(&quot;The SMS has been sent&quot;);
 }

 // Define the error callback.
 function messageFailed(error) {
   console.log(&quot;The SMS could not be sent &quot; + error.message);
 }

 // Define service error callback.
 function serviceErrorCB(error) {
   console.log(&quot;Cannot get messaging service &quot; + error.message);
 }

 // Define the success callback.
 function serviceListCB(services) {
   if (services.length > 0) {
     // SMS sending example
     var msg = new tizen.Message(&quot;messaging.sms&quot;, {plainBody:&quot;I will arrive in 10 minutes.&quot;,
                                  to:[&quot;+34666666666&quot;]});
     // Send request
     services[0].sendMessage(msg, messageSent, messageFailed);
   }
 }

 tizen.messaging.getMessageServices(&quot;messaging.sms&quot;,
                                    serviceListCB,
                                    serviceErrorCB);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Messaging::MessageService::id">
        <webidl>    readonly attribute DOMString id;</webidl>
        <descriptive>
            <brief>
 The unique identifier of this Messaging service.
            </brief>
            <version>
 1.0.
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::Messaging::MessageService::type">
        <webidl>    readonly attribute <ref>MessageServiceTag</ref> type;</webidl>
        <descriptive>
            <brief>
 The tag supported by this messaging service.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageServiceTag"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Messaging::MessageService::name">
        <webidl>    readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 The messaging service name taken from the messaging service
            </brief>
            <version>
 1.0.
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Operation name="sendMessage" id="::Messaging::MessageService::sendMessage">
        <webidl>    void sendMessage(<ref>Message</ref> message,
                     optional <ref>MessageRecipientsCallback</ref>? successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sends a specified message.
            </brief>
           <description>
            <p>
For messaging technologies in which the message is sent individually to every recipient(such as SMS), individual notification must be supported as follows:
            </p>
            <p>
For every individual recipient in the destination list, if the message cannot be sent to that recipient, the onerror() method of the errorCallback argument must be invoked with the corresponding error type as input parameter.
These error types may be passed, depending on the error conditions:
            </p>
            <ul>
              <li>
 NetworkError - If the network connection is not accessible.              </li>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
            <p>
The error message contains the name of the recipient who has failed to receive the sent message.
            </p>
            <p>
When the operation is fully completed (that is, the implementation has the
result of the send operation for all recipients), the onsuccess()
method of the successCallback will be invoked with an array of recipients who received
the sent message, as input parameter.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> // Define the success callback
 function messageSent(recipients) {
   for (var i = 0; i &#60; recipients.length; i++) {
     console.log(&quot;The SMS has been sent to &quot; + recipients[i]);
   }
 }

 // Define the error callback.
 function messageFailed(error) {
   console.log(&quot;The SMS could not be sent &quot; + error.message);
 }

 // Define the success callback.
 function serviceListCB(services) {
   if (services.length > 0) {
     // SMS sending example
     var msg = new tizen.Message(&quot;messaging.sms&quot;, {plainBody: &quot;I will arrive in 10 minutes.&quot;,
                                 to: [&quot;+34666666666&quot;, &quot;+34888888888&quot;]});
     // Send request
     services[0].sendMessage(msg, messageSent, messageFailed);
   }
 }
 tizen.messaging.getMessageServices(&quot;messaging.sms&quot;, serviceListCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="message">
            <descriptive>
                <description><p>
 The message to be sent.
                </p></description>
            </descriptive>
            <Type name="Message"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the message is successfully sent.
                </p></description>
            </descriptive>
            <Type name="MessageRecipientsCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the sending request has failed.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="loadMessageBody" id="::Messaging::MessageService::loadMessageBody">
        <webidl>    void loadMessageBody(<ref>Message</ref> message,
                         <ref>MessageBodySuccessCallback</ref> successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Loads the body for a specified message.
            </brief>
           <description>
            <p>
It is the back end's responsibility to detect which MIME parts of the message are related to the message body and should be loaded.
If the message body is already loaded, the onsuccess() method of the successCallback will be invoked immediately.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> // Assume messaging service is initialized.
 var service;
 // Define the success body loaded callback.
 function successCallback(message) {
   console.log (&quot;body for message: &quot; + message.subject + &quot;from: &quot; + message.from + &quot;loaded.&quot;);
 }
 // Define error callback.
 function errorCallback(error) {
   console.log(&quot;Cannot load message body&quot; + error.message);
 }

 function messageQueryCallback(messages) {
   for (var i = 0; i &#60; messages.length; i++) {
     var message = messages[i];
     if (!message.body.loaded) {
        service.loadMessageBody(message, successCallback, errorCallback);
     }
   }
 }

 service.messageStorage.findMessages(new tizen.AttributeFilter(&quot;type&quot;, &quot;EXACTLY&quot;, &quot;messaging.email&quot;), messageQueryCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="message">
            <descriptive>
                <description><p>
 Message with the body to be loaded.
                </p></description>
            </descriptive>
            <Type name="Message"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the message body is successfully loaded.
                </p></description>
            </descriptive>
            <Type name="MessageBodySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the loading request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="loadMessageAttachment" id="::Messaging::MessageService::loadMessageAttachment">
        <webidl>    void loadMessageAttachment(<ref>MessageAttachment</ref> attachment,
                               <ref>MessageAttachmentSuccessCallback</ref> successCallback,
                               optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Loads a specified message attachment.
            </brief>
           <description>
            <p>
This method is used only for email services. If the message attachment is already loaded, the onsuccess() method of the successCallback is invoked immediately.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> // Assume messaging service is initialized.
 var service;
 // Define success body loaded callback
 function successCallback(attachment) {
   console.log(&quot;attachment&quot; + attachment.id + &quot;is loaded to:&quot; + attachment.filePath);
 }
 // Define error callback
 function errorCallback(error) {
   console.log(&quot;Cannot load message attachment&quot; + error.message);
 }

 function messagesFoundCB(messages) {
   for (var i = 0; i &#60; messages.length; i++) {
     var message = messages[i];
     if (!message.attachments[0].loaded) {
        service.loadMessageAttachment(message.attachments[0], successCallback, errorCallback);
     }
   }
 }

 service.messageStorage.findMessages(new tizen.AttributeFilter(&quot;hasAttachment&quot;, &quot;EXACTLY&quot;, true), messagesFoundCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="attachment">
            <descriptive>
                <description><p>
 Message attachment to be loaded.
                </p></description>
            </descriptive>
            <Type name="MessageAttachment"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the message attachment is successfully loaded.
                </p></description>
            </descriptive>
            <Type name="MessageAttachmentSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the loading request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="sync" id="::Messaging::MessageService::sync">
        <webidl>    long sync(optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback,
              optional unsigned long? limit) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Synchronizes the service content with an external mail server.
            </brief>
           <description>
            <p>
This method is used only for email services. This method performs the same actions as syncFolder for every folder with Synchronizable flag set within the current Messaging service.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 AbortError - If the operation has been stopped.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> // Define the success callback.
 function serviceSynced() {
   console.log(&quot;New messages are fetched!&quot;);
 }

 // Define the success callback.
 function servicesListSuccessCB(services) {
   services[0].sync(serviceSynced, null, 30);
   // Subscribe to MessageStorage notification
 }
 tizen.messaging.getMessageServices(&quot;messaging.email&quot;, servicesListSuccessCB);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The identifier which can be used to stop this service operation.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when all the actions are completed successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="limit">
            <descriptive>
                <description><p>
 The maximum amount of messages retrieved within each folder.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="syncFolder" id="::Messaging::MessageService::syncFolder">
        <webidl>    long syncFolder(<ref>MessageFolder</ref> folder,
                    optional <ref>SuccessCallback</ref>? successCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback,
                    optional unsigned long? limit) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Synchronizes the folder content with an external mail server.
            </brief>
           <description>
            <p>
This method is used only for email services. This method performs the following actions:
            </p>
            <ul>
              <li>
Exports local changes within a given folder from device to server.              </li>
              <li>
Retrieves the list of available messages from within the given folder.              </li>
            </ul>
            <p>
Messages that are retrieved from a given folder, even if synchronizable flag for this folder is not set.
The backend is responsible in deciding which data is retrieved for every message. It can be:
            </p>
            <ul>
              <li>
Message header details              </li>
              <li>
Whole message body              </li>
            </ul>
            <p>
The limit of latest messages for the given folder must be retrieved and put into <em>MessageStorage</em>. If the limit is not set, the entire folder must be retrieved.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 AbortError - If the operation is stopped.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> var emailService; // Assume email service is initialized
  // Define the error callback.
 function errorCallback(err) {
   console.log(err.name + &quot; error: &quot; + err.message);
 }
 function serviceCallback(services) {
   emailService = services[0];
   var filter = new tizen.AttributeFilter(&quot;serviceId&quot;, &quot;EXACTLY&quot;, emailService.id);

   emailService.messageStorage.findFolders(filter, folderQueryCallback);
 }

 // Define the success callback.
 function folderSynced() {
   console.log(&quot;New messages are fetched!&quot;);
 }
 function folderQueryCallback(folders) {
   console.log(folders.length + &quot; folders(s) found!&quot;);
   for (var i = 0; i &#60; folders.length; i++) {
     emailService.syncFolder (folders[i], folderSynced, null, 30);
   }
 }

 tizen.messaging.getMessageServices(&quot;messaging.email&quot;, serviceCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The identifier which can be used to stop this service operation.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="folder">
            <descriptive>
                <description><p>
 The folder to be synchronized.
                </p></description>
            </descriptive>
            <Type name="MessageFolder"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when all actions are completed successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="limit">
            <descriptive>
                <description><p>
 The maximum amount of messages retrieved within a given folder.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="stopSync" id="::Messaging::MessageService::stopSync">
        <webidl>    void stopSync(long opId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Stops sync() and syncFoler() operation.
            </brief>
           <description>
            <p>
If the <em>operationId </em>argument is valid and corresponds to a service operation already in progress, the operation must be stopped and its error callback must be invoked with error type AbortError.
            </p>
            <p>
If the <em>operationId </em>argument is not valid or does not correspond to a valid service operation, the method will return without any further action.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="opId">
            <descriptive>
                <description><p>
  A service operation identifier.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contains an invalid value.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Attribute readonly="readonly" name="messageStorage" id="::Messaging::MessageService::messageStorage">
        <webidl>    readonly attribute <ref>MessageStorage</ref> messageStorage getraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to access <em>MessageStorage </em>for this messaging service.
            </brief>
           <description>
            <p>
If the backend does not support <em>MessageStorage </em>for this messaging service, a WebAPIException is raised with error type NotSupportedError.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageStorage"/>
        <GetRaises>
          <RaiseException name="WebAPIException"/>
        </GetRaises>
      </Attribute>
    </Interface>
    <Interface name="MessageRecipientsCallback" id="::Messaging::MessageRecipientsCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface MessageRecipientsCallback {

    void onsuccess(DOMString[] recipients);

   };</webidl>
      <descriptive>
          <brief>
 This interface specifies the methods to be called for the sendMessage() operation.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Messaging::MessageRecipientsCallback::onsuccess">
        <webidl>    void onsuccess(DOMString[] recipients);</webidl>
        <descriptive>
            <brief>
 Called when the message sending is finished.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="recipients">
            <descriptive>
                <description><p>
 The recipients of the message.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="DOMString"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageBodySuccessCallback" id="::Messaging::MessageBodySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface MessageBodySuccessCallback {

     void onsuccess(<ref>Message</ref> message);
  };</webidl>
      <descriptive>
          <brief>
 This interface specifies a success callback function that takes a message as the input argument.
It is used in the loadMessageBody() asynchronous operation.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Messaging::MessageBodySuccessCallback::onsuccess">
        <webidl>     void onsuccess(<ref>Message</ref> message);</webidl>
        <descriptive>
            <brief>
 Called when the asynchronous query completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="message">
            <descriptive>
                <description><p>
 The message containing the loaded body.
                </p></description>
            </descriptive>
            <Type name="Message"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageAttachmentSuccessCallback" id="::Messaging::MessageAttachmentSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface MessageAttachmentSuccessCallback {

     void onsuccess(<ref>MessageAttachment</ref> attachment);
   };</webidl>
      <descriptive>
          <brief>
 This callback interface specifies a success callback function that takes the loaded attachment as the input argument.
It is used in the loadMessageAttachment() asynchronous operation.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Messaging::MessageAttachmentSuccessCallback::onsuccess">
        <webidl>     void onsuccess(<ref>MessageAttachment</ref> attachment);</webidl>
        <descriptive>
            <brief>
 Called when the asynchronous query completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="attachment">
            <descriptive>
                <description><p>
 The loaded attachment.
                </p></description>
            </descriptive>
            <Type name="MessageAttachment"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageStorage" id="::Messaging::MessageStorage">
      <webidl>  [NoInterfaceObject] interface MessageStorage {

    void addDraftMessage(<ref>Message</ref> message,
                         optional <ref>SuccessCallback</ref>? successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void findMessages(<ref>AbstractFilter</ref> filter,
                      <ref>MessageArraySuccessCallback</ref> successCallback,
                      optional <ref>ErrorCallback</ref>? errorCallback,
                      optional <ref>SortMode</ref>? sort,
                      optional unsigned long? limit,
                      optional unsigned long? offset) raises(<ref>WebAPIException</ref>);

    void removeMessages(<ref>Message</ref>[] messages,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void updateMessages(<ref>Message</ref>[] messages,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void findConversations(<ref>AbstractFilter</ref> filter,
                           <ref>MessageConversationArraySuccessCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback,
                           optional <ref>SortMode</ref>? sort,
                           optional unsigned long? limit,
                           optional unsigned long? offset) raises(<ref>WebAPIException</ref>);

    void removeConversations(<ref>MessageConversation</ref>[] conversations,
                             optional <ref>SuccessCallback</ref>? successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);


    void findFolders(<ref>AbstractFilter</ref> filter,
                     <ref>MessageFolderArraySuccessCallback</ref> successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    long addMessagesChangeListener(<ref>MessagesChangeCallback</ref> messagesChangeCallback,
                                   optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);

    long addConversationsChangeListener(<ref>MessageConversationsChangeCallback</ref> conversationsChangeCallback,
                                        optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);

    long addFoldersChangeListener(<ref>MessageFoldersChangeCallback</ref> foldersChangeCallback,
                                  optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);

    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface allows management capabilities using a web application to query, update, and delete messages, and subscribe to <em>MessageStorage </em>changes. In addition to simple message queries, the <em>MessageStorage </em>interface provides functionality to find conversations and folders.
          </brief>
         <description>
          <p>
The conversation object represents a group of messages combined by the set of message fields. Email conversations are grouped by subject, while chat messages are grouped by sender and recipient fields.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="addDraftMessage" id="::Messaging::MessageStorage::addDraftMessage">
        <webidl>    void addDraftMessage(<ref>Message</ref> message,
                         optional <ref>SuccessCallback</ref>? successCallback,
                         optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a draft message to <em>MessageStorage</em> and these messages are stored in the Drafts folder.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> // Define success callback
 function successCallback() {
   console.log(&quot;Draft message added&quot;);
 }

 // Define error callback
 function errorCallback(error) {
   console.log(&quot;Cannot add draft message &quot; + error.message);
 }

 // Define service query success callback.
 function serviceListCB(services) {
   if (services.length > 0) {
     var msg = new tizen.Message(&quot;messaging.sms&quot;, {plainBody: &quot;Tizen draft SMS message.&quot;});
     services[0].messageStorage.addDraftMessage(msg,
                                                successCallback,
                                                errorCallback);
   }
 }
 tizen.messaging.getMessageServices(&quot;messaging.sms&quot;, serviceListCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="message">
            <descriptive>
                <description><p>
 The draft message to add to the storage.
                </p></description>
            </descriptive>
            <Type name="Message"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method called when draft messages successfully added.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method called when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter or if the method is invoked for an incoming message.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="findMessages" id="::Messaging::MessageStorage::findMessages">
        <webidl>    void findMessages(<ref>AbstractFilter</ref> filter,
                      <ref>MessageArraySuccessCallback</ref> successCallback,
                      optional <ref>ErrorCallback</ref>? errorCallback,
                      optional <ref>SortMode</ref>? sort,
                      optional unsigned long? limit,
                      optional unsigned long? offset) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Finds messages from <em>MessageStorage</em>.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.read
            </privilege>
            <Code> var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 function messageArrayCB(messages) {
   console.log(messages.length + &quot; message(s) fetched!&quot;);
   for (var i = 0; i &#60; messages.length; i++) {
     console.log(i + &quot;. message from &quot; + messages[i].from);
   }
 }

 // Define error callback
 function errorCallback(error) {
   console.log(&quot;Cannot query messages&quot; + error.message);
 }

 var filter = new tizen.AttributeFilter(&quot;from&quot;, &quot;CONTAINS&quot;, &quot;2593&quot;);
 messageStorage.findMessages(filter, messageArrayCB, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="filter">
            <descriptive>
                <description><p>
 The criteria to be used when filtering.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method called when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="MessageArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method called when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="sort">
            <descriptive>
                <description><p>
 The sorting mode for the query.
                </p></description>
            </descriptive>
            <Type name="SortMode" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="limit">
            <descriptive>
                <description><p>
 The maximum limit the query result is set to as specified by the parameter (It is the same meaning as SQL LIMIT).
If <var>0</var>, there is no limit set.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="offset">
            <descriptive>
                <description><p>
 The offset in the result set, from where the results are listed (It is the same semantics as SQL OFFSET).<br/>The number of results listed is maximum the specified <em>limit</em> parameter. Defaults to<var> 0</var>, meaning no offset.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeMessages" id="::Messaging::MessageStorage::removeMessages">
        <webidl>    void removeMessages(<ref>Message</ref>[] messages,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes messages from <em>MessageStorage</em>.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> // Define success callback
 var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 function successCallback() {
   console.log(&quot;Messages were deleted&quot;);
 }

 // Define error callback
 function errorCallback(error) {
   console.log(&quot;Cannot delete messages &quot; + error.message);
 }

 function messageArrayCB(messages) {
   if (messages.length > 0) {
     messageStorage.removeMessages(messages, successCallback, errorCallback);
   } else {
     console.log(&quot;No messages found&quot;);
   }
 }

 var filter = new tizen.AttributeFilter(&quot;from&quot;, &quot;CONTAINS&quot;, &quot;2593&quot;);
 messageStorage.findMessages(filter, messageArrayCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="messages">
            <descriptive>
                <description><p>
 An array of messages to delete.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Message"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method called when messages are successfully deleted.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method called when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="updateMessages" id="::Messaging::MessageStorage::updateMessages">
        <webidl>    void updateMessages(<ref>Message</ref>[] messages,
                        optional <ref>SuccessCallback</ref>? successCallback,
                        optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates messages in <em>MessageStorage</em>.
            </brief>
           <description>
            <p>
The backend must check whether the required updates can be applied and invoke the errorCallback method, if they cannot be checked.
Depending on the backend synchronization settings, the local changes in <em>MessageStorage</em> can be rewritten as a result of invoking the sync() or syncFolder() methods of the related message service.
            </p>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;

 // Define success callback
 function successCallback() {
   console.log(&quot;Messages were updated&quot;);
 }

 // Define error callback
 function errorCallback(error) {
   console.log(&quot;Cannot update messages &quot; + error.message);
 }

 function messageArrayCB(messages) {
   if (messages.length > 0) {
     messages[0].isRead = true;
     messageStorage.updateMessages([messages[0]], successCallback, errorCallback);
   } else {
     console.log(&quot;No messages found&quot;);
   }
 }

 var filter = new tizen.AttributeFilter('isRead', 'EXACTLY', false);
 messageStorage.findMessages(filter, messageArrayCB);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="messages">
            <descriptive>
                <description><p>
 An array to update
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Message"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method called when messages are successfully updated.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method called when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="findConversations" id="::Messaging::MessageStorage::findConversations">
        <webidl>    void findConversations(<ref>AbstractFilter</ref> filter,
                           <ref>MessageConversationArraySuccessCallback</ref> successCallback,
                           optional <ref>ErrorCallback</ref>? errorCallback,
                           optional <ref>SortMode</ref>? sort,
                           optional unsigned long? limit,
                           optional unsigned long? offset) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Finds conversations from <em>MessageStorage</em>.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.read
            </privilege>
            <Code> var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 function conversationsArrayCB(conversations) {
   console.log(conversations.length + &quot; conversation(s) found!&quot;);
   for (var i = 0; i &#60; conversations.length; i++) {
     console.log(i + &quot;. conversation preview &quot; + conversations[i].preview);
   }
 }

 // Define error callback.
 function errorCallback(error) {
   console.log(&quot;Cannot query conversations&quot; + error.message);
 }

 var filter = new tizen.AttributeFilter('from', 'CONTAINS', '2593');
 messageStorage.findConversations(filter, conversationsArrayCB, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="filter">
            <descriptive>
                <description><p>
 The criteria to be used when filtering.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method called when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="MessageConversationArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method called when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="sort">
            <descriptive>
                <description><p>
 The sorting rules for the query.
                </p></description>
            </descriptive>
            <Type name="SortMode" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="limit">
            <descriptive>
                <description><p>
 The maximum limit the query result is set to as specified by the parameter (It is the same meaning as SQL LIMIT).
If set to <var>0</var>, there is no limit set.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="offset">
            <descriptive>
                <description><p>
 The offset in the result set, from where the results are listed (It is the same semantics as SQL OFFSET).<br/>The number of results listed is maximum the specified <em>limit</em> parameter. Defaults to<var> 0</var>, meaning no offset.
                </p></description>
            </descriptive>
            <Type type="unsigned long" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeConversations" id="::Messaging::MessageStorage::removeConversations">
        <webidl>    void removeConversations(<ref>MessageConversation</ref>[] conversations,
                             optional <ref>SuccessCallback</ref>? successCallback,
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes conversations from <em>MessageStorage</em>.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.write
            </privilege>
            <Code> var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 // Define success callback.
 function successCallback() {
   console.log(&quot;Conversations deleted&quot;);
 }

 // Define error callback.
 function errorCallback(error) {
   console.log(&quot;Cannot delete conversations &quot; + error.message);
 }

 function conversationsArrayCB(conversations) {
   if (conversations.length > 0) {
     messageStorage.removeConversations(conversations, successCallback,
                                                       errorCallback);
   } else {
     console.log(&quot;No conversations found&quot;);
   }
   console.log(&quot;Deleted &quot; + conversations.length + &quot; conversation(s)&quot;);
 }

 // Define error callback.
 function queryErrorCB(error) {
   console.log(&quot;Cannot query conversations&quot; + error.message);
 }

 var filter = new tizen.AttributeFilter('from', 'CONTAINS', '2593');
 messageStorage.findConversations(filter, conversationsArrayCB,
                                          queryErrorCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="conversations">
            <descriptive>
                <description><p>
 An array of conversations to delete.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageConversation"/>
            </Type>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method called when conversations are successfully deleted.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method called when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="findFolders" id="::Messaging::MessageStorage::findFolders">
        <webidl>    void findFolders(<ref>AbstractFilter</ref> filter,
                     <ref>MessageFolderArraySuccessCallback</ref> successCallback,
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Queries folders from MessageStorage.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError: If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError: In any other error case.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.read
            </privilege>
            <Code> var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 function folderArrayCB(folders) {
   console.log(folders.length + &quot; folders(s) found!&quot;);
   for (var i = 0; i &#60; folders.length; i++) {
     console.log(i + &quot;, folder: &quot; + folders[i].name);
   }
 }
 var filter = new tizen.AttributeFilter(&quot;serviceId&quot;, &quot;EXACTLY&quot;, service.id);
 messageStorage.findFolders(filter, folderArrayCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="filter">
            <descriptive>
                <description><p>
 The criteria used when filtering.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method called when the invocation ends successfully.
                </p></description>
            </descriptive>
            <Type name="MessageFolderArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method called when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addMessagesChangeListener" id="::Messaging::MessageStorage::addMessagesChangeListener">
        <webidl>    long addMessagesChangeListener(<ref>MessagesChangeCallback</ref> messagesChangeCallback,
                                   optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a listener to subscribe to notification for MessageStorage changes.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.read
            </privilege>
            <Code> var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 var messageChangeCallback = {
       messagesupdated: function(messages) {
         console.log(messages.length + &quot; message(s) updated&quot;);},
       messagesadded: function(messages) {
         console.log(messages.length + &quot; message(s) added&quot;);},
       messagesremoved: function(messages) {
         console.log(messages.length + &quot; message(s) removed&quot;);}
 };

 messageStorage.addMessagesChangeListener(messageChangeCallback);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The subscription identifier.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="messagesChangeCallback">
            <descriptive>
                <description><p>
 Callback that is called when the MessageStorage is changed.
                </p></description>
            </descriptive>
            <Type name="MessagesChangeCallback"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 The criteria to be used when filtering.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addConversationsChangeListener" id="::Messaging::MessageStorage::addConversationsChangeListener">
        <webidl>    long addConversationsChangeListener(<ref>MessageConversationsChangeCallback</ref> conversationsChangeCallback,
                                        optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a listener to subscribe to notifications for MessageConversation changes.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.read
            </privilege>
            <Code> var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 var conversationChangeCB = {
       conversationsupdated: function(conversations) {
         console.log(conversations.length + &quot; conversations(s) updated&quot;);},
       conversationsadded: function(conversations) {
         console.log(conversations.length + &quot; conversations(s) added&quot;);},
       conversationsremoved: function(conversations) {
         console.log(conversations.length + &quot; conversations(s) removed&quot;);}
 };

 messageStorage.addConversationsChangeListener(conversationChangeCB);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The subscription identifier.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="conversationsChangeCallback">
            <descriptive>
                <description><p>
 Callback that is called when the MessageStorage is changed.
                </p></description>
            </descriptive>
            <Type name="MessageConversationsChangeCallback"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 The criteria to be used when filtering.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addFoldersChangeListener" id="::Messaging::MessageStorage::addFoldersChangeListener">
        <webidl>    long addFoldersChangeListener(<ref>MessageFoldersChangeCallback</ref> foldersChangeCallback,
                                  optional <ref>AbstractFilter</ref>? filter) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a listener to subscribe to notifications for MessageFolder changes.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.read
            </privilege>
            <Code> var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 var folderChangeCB = {
       foldersupdated: function(folders) {
         console.log(folders.length + &quot; folders(s) updated&quot;);},
       foldersadded: function(folders) {
         console.log(folders.length + &quot; folders(s) added&quot;);},
       foldersremoved: function(folders) {
         console.log(folders.length + &quot; folders(s) removed&quot;);}
 };

 messageStorage.addFoldersChangeListener(folderChangeCB);
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The subscription identifier.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="foldersChangeCallback">
            <descriptive>
                <description><p>
 Callback that is called when the MessageStorage is changed.
                </p></description>
            </descriptive>
            <Type name="MessageFoldersChangeCallback"/>
          </Argument>
          <Argument optional="optional" name="filter">
            <descriptive>
                <description><p>
 The criteria to be used when filtering.
                </p></description>
            </descriptive>
            <Type name="AbstractFilter" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeChangeListener" id="::Messaging::MessageStorage::removeChangeListener">
        <webidl>    void removeChangeListener(long watchId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a listener to unsubscribe from receiving message notifications.
            </brief>
           <description>
            <p>
The errorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contains an invalid value.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
            <p>
If the <em>subscriptionId </em>argument is valid and corresponds to a subscription already in place, the subscription process must stop immediately and further <em>MessagingStorage </em>change notifications must not be invoked.
If the <em>subscriptionId argument does not correspond to a valid subscription, the method will return without any further action.
</em>            </p>
           </description>
            <version>
 1.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/messaging.read
            </privilege>
            <Code> var watchId;
 var service; // Assume messaging service is initialized
 var messageStorage = service.messageStorage;
 var folderChangeCB = {
       foldersupdated: function(folders) {
         console.log(folders.length + &quot; folders(s) updated. Cancel watching.&quot;);
         messageStorage.removeChangeListener(watchId); },
       foldersadded: function(folders) {
         console.log(folders.length + &quot; folders(s) added. Cancel watching.&quot;);
         messageStorage.removeChangeListener(watchId); },
       foldersremoved: function(folders) {
         console.log(folders.length + &quot; folders(s) removed. Cancel watching.&quot;);
         messageStorage.removeChangeListener(watchId);}
 };

 watchId = messageStorage.addFoldersChangeListener(folderChangeCB);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="watchId">
            <descriptive>
                <description><p>
 An identifier of the subscription returned by addMessagesChangeListener, addConversationsChangeListener or
addFoldersChangeListener methods.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="MessageArraySuccessCallback" id="::Messaging::MessageArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface MessageArraySuccessCallback {

    void onsuccess(<ref>Message</ref>[] messages);
  };</webidl>
      <descriptive>
          <brief>
 findMessages specific success callback.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback function,
taking a list of messages that satisfy the filtering criteria as the input argument.
It is used in the findMessages asynchronous operation.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Messaging::MessageArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>Message</ref>[] messages);</webidl>
        <descriptive>
            <brief>
 Method invoked when an asynchronous query completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="messages">
            <descriptive>
                <description><p>
 Array of messages that satisfy the query.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Message"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageConversationArraySuccessCallback" id="::Messaging::MessageConversationArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface MessageConversationArraySuccessCallback {

    void onsuccess(<ref>MessageConversation</ref>[] conversations);
  };</webidl>
      <descriptive>
          <brief>
 findConversations specific success callback.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback function,
taking a list of conversations that satisfy the filtering criteria as the input argument.
It is used in the findConversations asynchronous operation.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Messaging::MessageConversationArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>MessageConversation</ref>[] conversations);</webidl>
        <descriptive>
            <brief>
 Method invoked when an asynchronous query completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="conversations">
            <descriptive>
                <description><p>
 Array of conversations that satisfy the query.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageConversation"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageFolderArraySuccessCallback" id="::Messaging::MessageFolderArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface MessageFolderArraySuccessCallback {

    void onsuccess(<ref>MessageFolder</ref>[] folders);
  };</webidl>
      <descriptive>
          <brief>
 findFolders specific success callback.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback function,
taking a list of folders that satisfy the filtering criteria as the input argument.
It is used in the findFolders asynchronous operation.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Messaging::MessageFolderArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>MessageFolder</ref>[] folders);</webidl>
        <descriptive>
            <brief>
 Method invoked when an asynchronous query completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="folders">
            <descriptive>
                <description><p>
 Array of folders that satisfy the query.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageFolder"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessagesChangeCallback" id="::Messaging::MessagesChangeCallback">
      <webidl>  [Callback, NoInterfaceObject] interface MessagesChangeCallback {

    void messagesadded(<ref>Message</ref>[] addedMessages);

    void messagesupdated(<ref>Message</ref>[] updatedMessages);

    void messagesremoved(<ref>Message</ref>[] removedMessages);
  };</webidl>
      <descriptive>
          <brief>
 watchMessagesChanges callback.
          </brief>
         <description>
          <p>
This callback interface specifies a callback as a set of functions that will be
invoked when messages from MessageStorage change. Each function takes a list of messages as the input argument.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="messagesadded" id="::Messaging::MessagesChangeCallback::messagesadded">
        <webidl>    void messagesadded(<ref>Message</ref>[] addedMessages);</webidl>
        <descriptive>
            <brief>
 Method invoked when messages are added to the MessageStorage.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="addedMessages">
            <descriptive>
                <description><p>
 Array of added messages.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Message"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="messagesupdated" id="::Messaging::MessagesChangeCallback::messagesupdated">
        <webidl>    void messagesupdated(<ref>Message</ref>[] updatedMessages);</webidl>
        <descriptive>
            <brief>
 Method invoked when messages are updated in MessageStorage.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="updatedMessages">
            <descriptive>
                <description><p>
 Array of updated messages.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Message"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="messagesremoved" id="::Messaging::MessagesChangeCallback::messagesremoved">
        <webidl>    void messagesremoved(<ref>Message</ref>[] removedMessages);</webidl>
        <descriptive>
            <brief>
 Method invoked when messages are removed from MessageStorage.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="removedMessages">
            <descriptive>
                <description><p>
 Array of removed messages. It contains only MessageId attribute.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Message"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageConversationsChangeCallback" id="::Messaging::MessageConversationsChangeCallback">
      <webidl>  [Callback, NoInterfaceObject] interface MessageConversationsChangeCallback {

    void conversationsadded(<ref>MessageConversation</ref>[] addedConversations);

    void conversationsupdated(<ref>MessageConversation</ref>[] updatedConversations);

    void conversationsremoved(<ref>MessageConversation</ref>[] removedConversations);
  };</webidl>
      <descriptive>
          <brief>
 watchConversationsChanges callback.
          </brief>
         <description>
          <p>
This callback interface specifies a callback as a set of functions that will be
invoked when conversations from MessageStorage change. Each function takes a list of conversations as the input argument.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="conversationsadded" id="::Messaging::MessageConversationsChangeCallback::conversationsadded">
        <webidl>    void conversationsadded(<ref>MessageConversation</ref>[] addedConversations);</webidl>
        <descriptive>
            <brief>
 Method invoked when conversations are added to MessageStorage.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="addedConversations">
            <descriptive>
                <description><p>
 Array of added conversations.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageConversation"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="conversationsupdated" id="::Messaging::MessageConversationsChangeCallback::conversationsupdated">
        <webidl>    void conversationsupdated(<ref>MessageConversation</ref>[] updatedConversations);</webidl>
        <descriptive>
            <brief>
 Method invoked when conversations are updated in MessageStorage.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="updatedConversations">
            <descriptive>
                <description><p>
 Array of updated conversations.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageConversation"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="conversationsremoved" id="::Messaging::MessageConversationsChangeCallback::conversationsremoved">
        <webidl>    void conversationsremoved(<ref>MessageConversation</ref>[] removedConversations);</webidl>
        <descriptive>
            <brief>
 Method invoked when conversations are removed from MessageStorage.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="removedConversations">
            <descriptive>
                <description><p>
 Array of removed conversations. It contains only MessageConvId attribute.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageConversation"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageFoldersChangeCallback" id="::Messaging::MessageFoldersChangeCallback">
      <webidl>  [Callback, NoInterfaceObject] interface MessageFoldersChangeCallback {

    void foldersadded(<ref>MessageFolder</ref>[] addedFolders);

    void foldersupdated(<ref>MessageFolder</ref>[] updatedFolders);

    void foldersremoved(<ref>MessageFolder</ref>[] removedFolders);
  };</webidl>
      <descriptive>
          <brief>
 This callback interface specifies a callback as a set of functions that are invoked when message folders from <em>MessageStorage </em>change. Each function takes a list of folders as the input argument.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="foldersadded" id="::Messaging::MessageFoldersChangeCallback::foldersadded">
        <webidl>    void foldersadded(<ref>MessageFolder</ref>[] addedFolders);</webidl>
        <descriptive>
            <brief>
 Called when folders are added to <em>MessageStorage</em>.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="addedFolders">
            <descriptive>
                <description><p>
 An array of added folders.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageFolder"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="foldersupdated" id="::Messaging::MessageFoldersChangeCallback::foldersupdated">
        <webidl>    void foldersupdated(<ref>MessageFolder</ref>[] updatedFolders);</webidl>
        <descriptive>
            <brief>
 Called when folders are updated in <em>MessageStorage</em>.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="updatedFolders">
            <descriptive>
                <description><p>
 An array of updated folders.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageFolder"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="foldersremoved" id="::Messaging::MessageFoldersChangeCallback::foldersremoved">
        <webidl>    void foldersremoved(<ref>MessageFolder</ref>[] removedFolders);</webidl>
        <descriptive>
            <brief>
 Called when folders are removed from <em>MessageStorage</em>.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="removedFolders">
            <descriptive>
                <description><p>
 Array of removed folders. It contains only MessageFolderId attribute.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="MessageFolder"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="MessageConversation" id="::Messaging::MessageConversation">
      <webidl>  [NoInterfaceObject] interface MessageConversation {

    readonly attribute <ref>MessageConvId</ref> id;

    readonly attribute <ref>MessageServiceTag</ref> type;

    readonly attribute Date timestamp;

    readonly attribute unsigned long messageCount;

    readonly attribute unsigned long unreadMessages;

    readonly attribute DOMString preview;

    readonly attribute DOMString subject;

    readonly attribute boolean isRead;

    readonly attribute DOMString from;

    readonly attribute DOMString[] to;

    readonly attribute DOMString[] cc;

    readonly attribute DOMString[] bcc;

    readonly attribute <ref>MessageId</ref> lastMessageId;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the message conversation (also known as the thread of messages).
          </brief>
         <description>
          <p>
This interface allows a web application to get the set of properties linked to a conversation.
This interface provides only read-only attributes.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Messaging::MessageConversation::id">
        <webidl>    readonly attribute <ref>MessageConvId</ref> id;</webidl>
        <descriptive>
            <brief>
 The conversation identifier.
            </brief>
           <description>
            <p>
The ID is locally unique and persistent property, assigned by the device or the Web runtime (WRT).
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageConvId"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::Messaging::MessageConversation::type">
        <webidl>    readonly attribute <ref>MessageServiceTag</ref> type;</webidl>
        <descriptive>
            <brief>
 The type of a given conversation.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageServiceTag"/>
      </Attribute>
      <Attribute readonly="readonly" name="timestamp" id="::Messaging::MessageConversation::timestamp">
        <webidl>    readonly attribute Date timestamp;</webidl>
        <descriptive>
            <brief>
 The timestamp of the latest message in a conversation.
            </brief>
           <description>
            <p>
This property is set up by the device or the Web runtime environment.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
      <Attribute readonly="readonly" name="messageCount" id="::Messaging::MessageConversation::messageCount">
        <webidl>    readonly attribute unsigned long messageCount;</webidl>
        <descriptive>
            <brief>
 The count of messages in a conversation.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="unreadMessages" id="::Messaging::MessageConversation::unreadMessages">
        <webidl>    readonly attribute unsigned long unreadMessages;</webidl>
        <descriptive>
            <brief>
 The count of unread messages in a conversation.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="preview" id="::Messaging::MessageConversation::preview">
        <webidl>    readonly attribute DOMString preview;</webidl>
        <descriptive>
            <brief>
 A preview of the latest message in a conversation.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="subject" id="::Messaging::MessageConversation::subject">
        <webidl>    readonly attribute DOMString subject;</webidl>
        <descriptive>
            <brief>
 The subject of a conversation (applicable for group chats, MMS, email).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="isRead" id="::Messaging::MessageConversation::isRead">
        <webidl>    readonly attribute boolean isRead;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate whether the latest message in a conversation has been read or not.
            </brief>
           <description>
            <p>
This property is set to <var>true</var> if the message has been read, else it is set to <var>false</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="from" id="::Messaging::MessageConversation::from">
        <webidl>    readonly attribute DOMString from;</webidl>
        <descriptive>
            <brief>
 The source address (or source phone number) of the latest message in the conversation.
            </brief>
           <description>
            <p>
This property is set up by the device or the Web runtime environment.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="to" id="::Messaging::MessageConversation::to">
        <webidl>    readonly attribute DOMString[] to;</webidl>
        <descriptive>
            <brief>
 The destination of the latest message in a conversation.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="cc" id="::Messaging::MessageConversation::cc">
        <webidl>    readonly attribute DOMString[] cc;</webidl>
        <descriptive>
            <brief>
 The carbon copy (cc) address of the latest message in a conversation.
            </brief>
           <description>
            <p>
This property is used only for email.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="bcc" id="::Messaging::MessageConversation::bcc">
        <webidl>    readonly attribute DOMString[] bcc;</webidl>
        <descriptive>
            <brief>
 The blind carbon copy (bcc) address of the latest message in a conversation.
            </brief>
           <description>
            <p>
This property is used only for email.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="lastMessageId" id="::Messaging::MessageConversation::lastMessageId">
        <webidl>    readonly attribute <ref>MessageId</ref> lastMessageId;</webidl>
        <descriptive>
            <brief>
 The identifier of a latest message in a conversation.
            </brief>
           <description>
            <p>
This property is set up by the device or the Web runtime environment.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageId"/>
      </Attribute>
    </Interface>
    <Interface name="MessageFolder" id="::Messaging::MessageFolder">
      <webidl>  [NoInterfaceObject] interface MessageFolder {

    readonly attribute <ref>MessageFolderId</ref> id;

    readonly attribute <ref>MessageFolderId</ref> parentId;

    readonly attribute DOMString serviceId;

    readonly attribute <ref>MessageServiceTag</ref> contentType;

    attribute DOMString name setraises(<ref>WebAPIException</ref>);

    readonly attribute DOMString path;

    readonly attribute DOMString type;

    attribute boolean synchronizable setraises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface defines the email folder.
          </brief>
         <description>
          <p>
This interface allows a web application to get the set of properties that are linked to an email folder.
          </p>
          <p>
The concept of folders is present in several email protocols, such as IMAP, Mail For Exchange.
          </p>
          <p>
If the Messaging service does not represent email or an email protocol supporting the concept of folders on a server, this service has one folder which is the standard INBOX folder.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Messaging::MessageFolder::id">
        <webidl>    readonly attribute <ref>MessageFolderId</ref> id;</webidl>
        <descriptive>
            <brief>
 The folder identifier.
The ID is locally unique and persistent property, assigned by the device or the Web runtime (WRT).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageFolderId"/>
      </Attribute>
      <Attribute readonly="readonly" name="parentId" id="::Messaging::MessageFolder::parentId">
        <webidl>    readonly attribute <ref>MessageFolderId</ref> parentId;</webidl>
        <descriptive>
            <brief>
 The identifier for the parent folder of  a specified folder.
            </brief>
           <description>
            <p>
If this folder is a root folder, the parent folder ID is <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageFolderId"/>
      </Attribute>
      <Attribute readonly="readonly" name="serviceId" id="::Messaging::MessageFolder::serviceId">
        <webidl>    readonly attribute DOMString serviceId;</webidl>
        <descriptive>
            <brief>
 The identifier of the service to which a specified folder belongs.
            </brief>
            <version>
 1.0.
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="contentType" id="::Messaging::MessageFolder::contentType">
        <webidl>    readonly attribute <ref>MessageServiceTag</ref> contentType;</webidl>
        <descriptive>
            <brief>
 The type of the messages contained within a folder.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="MessageServiceTag"/>
      </Attribute>
      <Attribute name="name" id="::Messaging::MessageFolder::name">
        <webidl>    attribute DOMString name setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The visible name of a folder.
            </brief>
           <description>
            <p>
Can be modified. By default, it contains the folder name from the server.
            </p>
            <p>
In case the current Messaging service does not support remote folders on the server (and this folder is the only one that the current service has), this attribute contains the service name, by default.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute readonly="readonly" name="path" id="::Messaging::MessageFolder::path">
        <webidl>    readonly attribute DOMString path;</webidl>
        <descriptive>
            <brief>
 The whole path of a remote folder on the server.
            </brief>
           <description>
            <p>
If the current Messaging service does not support remote folders on the server,
this attribute will be empty.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::Messaging::MessageFolder::type">
        <webidl>    readonly attribute DOMString type;</webidl>
        <descriptive>
            <brief>
 The standard type of a folder.
            </brief>
           <description>
            <p>
It can be one of the following values:
            </p>
            <ul>
              <li>
INBOX              </li>
              <li>
OUTBOX              </li>
              <li>
DRAFTS              </li>
              <li>
SENTBOX              </li>
            </ul>
            <p>
If this folder is not a standard folder, an empty value must be returned.
            </p>
            <p>
This property is unique for each type within one Messaging service.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="synchronizable" id="::Messaging::MessageFolder::synchronizable">
        <webidl>    attribute boolean synchronizable setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 An attribute to show whether this folder should be synchronized or not.
            </brief>
           <description>
            <p>
This attribute affects the behavior of the MessageService.sync() method.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
    </Interface>
  </Module>
  <Module name="NetworkBearerSelection" id="::NetworkBearerSelection">
    <webidl>module NetworkBearerSelection {

  enum NetworkType { &quot;CELLULAR&quot;, &quot;UNKNOWN&quot; };

  [NoInterfaceObject] interface NetworkBearerSelectionObject {
    readonly attribute <ref>NetworkBearerSelection</ref> networkbearerselection;
  };
  <ref>Tizen</ref> implements <ref>NetworkBearerSelectionObject</ref>;

  [NoInterfaceObject] interface NetworkBearerSelection {

    void requestRouteToHost(<ref>NetworkType</ref> networkType,
                            DOMString domainName,
                            <ref>NetworkSuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void releaseRouteToHost(<ref>NetworkType</ref> networkType,
                            DOMString domainName,
                            <ref>SuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
  };

  [Callback, NoInterfaceObject] interface NetworkSuccessCallback {
    void onsuccess();

    void ondisconnected();
  };
};</webidl>
    <descriptive>
        <brief>
 This specification defines interfaces and methods providing Web applications to access the devices.
        </brief>
       <description>
        <p>
This API provides interfaces and methods for users to set network bearer selection.
        </p>
       </description>
        <version>
 2.1
        </version>
        <def-api-feature identifier="http://tizen.org/feature/network.telephony">
          <descriptive>
           <description>
            <p>

To guarantee this application running on a device with telephony feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
    </descriptive>
    <Enum name="NetworkType" id="::NetworkBearerSelection::NetworkType">
      <webidl>  enum NetworkType { &quot;CELLULAR&quot;, &quot;UNKNOWN&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that defines the type of a network.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="CELLULAR">
        <webidl> &quot;CELLULAR</webidl>
      </EnumValue>
      <EnumValue stringvalue="UNKNOWN">
        <webidl> &quot;UNKNOWN</webidl>
      </EnumValue>
    </Enum>
    <Interface name="NetworkBearerSelectionObject" id="::NetworkBearerSelection::NetworkBearerSelectionObject">
      <webidl>  [NoInterfaceObject] interface NetworkBearerSelectionObject {
    readonly attribute <ref>NetworkBearerSelection</ref> networkbearerselection;
  };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated the Tizen object from the Tizen Platform.
          </brief>
         <description>
          <p>
There is a <em>tizen.networkbearerselection </em>object that allows accessing the functionality of the Networkbearerselection API.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="networkbearerselection" id="::NetworkBearerSelection::NetworkBearerSelectionObject::networkbearerselection">
        <webidl>    readonly attribute <ref>NetworkBearerSelection</ref> networkbearerselection;</webidl>
        <Type name="NetworkBearerSelection"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="NetworkBearerSelectionObject">
      <webidl>  <ref>Tizen</ref> implements <ref>NetworkBearerSelectionObject</ref>;</webidl>
    </Implements>
    <Interface name="NetworkBearerSelection" id="::NetworkBearerSelection::NetworkBearerSelection">
      <webidl>  [NoInterfaceObject] interface NetworkBearerSelection {

    void requestRouteToHost(<ref>NetworkType</ref> networkType,
                            DOMString domainName,
                            <ref>NetworkSuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void releaseRouteToHost(<ref>NetworkType</ref> networkType,
                            DOMString domainName,
                            <ref>SuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This entry interface provides methods to query the network bearer selection.
          </brief>
         <description>
          <p>
This API offers methods for network bearer selection.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="requestRouteToHost" id="::NetworkBearerSelection::NetworkBearerSelection::requestRouteToHost">
        <webidl>    void requestRouteToHost(<ref>NetworkType</ref> networkType,
                            DOMString domainName,
                            <ref>NetworkSuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Requests a specific network connection.
            </brief>
           <description>
            <p>
The function must asynchronously acquire success or fail.
            </p>
            <p>
When called, it starts a request process defined with these set of steps:
            </p>
            <ul>
              <li>
1. Open &quot;networkType&quot; network connection.              </li>
              <li>
2. Resolve &quot;domainName&quot; to IP.              </li>
              <li>
3. Change the routing path bound to domainName's IP to use the specific network type.              </li>
              <li>
4. If previous steps have been successfully accomplished, call onsuccess() callback function.<br/>If previous steps have failed, call ondisconnected() callback function.<br/>If network is disconnected, the routing path will be deleted and ondisconnected() is called.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <Code> var statuscb = {
   onsuccess: function() { console.log(&quot;onsuccess func is called&quot;); },
   ondisconnected: function() { console.log(&quot;ondisconnected func is called&quot;); }
 };
 function ecb(e) { console.log(&quot;error callback is called : &quot; + e.message + &quot; : &quot; + e.code); }
 tizen.networkbearerselection.requestRouteToHost(&quot;CELLULAR&quot;, &quot;www.tizen.org&quot;, statuscb, ecb);

</Code>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/networkbearerselection
            </privilege>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="networkType">
            <descriptive>
                <description><p>
 The network type.
                </p></description>
            </descriptive>
            <Type name="NetworkType"/>
          </Argument>
          <Argument name="domainName">
            <descriptive>
                <description><p>
 The domain name.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 To be invoked if data network connection is connected or not.
                </p></description>
            </descriptive>
            <Type name="NetworkSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 To be invoked if the request is failed.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="releaseRouteToHost" id="::NetworkBearerSelection::NetworkBearerSelection::releaseRouteToHost">
        <webidl>    void releaseRouteToHost(<ref>NetworkType</ref> networkType,
                            DOMString domainName,
                            <ref>SuccessCallback</ref> successCallback,
                            optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Releases a specific network connection.
            </brief>
           <description>
            <p>
The function must asynchronously acquire success or fail.
            </p>
            <p>
When called, it closes a network connection.
            </p>
           </description>
            <version>
 2.1
            </version>
            <Code> function scb() { console.log(&quot;success callback is called&quot;); }
 function ecb(e) { console.log(&quot;error callback is called : &quot; + e.message + &quot; : &quot; + e.code); }
 var statuscb = {
   onsuccess: function() {
     console.log(&quot;onsuccess func is called&quot;);
     tizen.networkbearerselection.releaseRouteToHost(&quot;CELLULAR&quot;, &quot;www.google.com&quot;, scb, ecb);
   },
   ondisconnected: function() { console.log(&quot;ondisconnected func is called&quot;); }
 };
 tizen.networkbearerselection.requestRouteToHost(&quot;CELLULAR&quot;, &quot;www.google.com&quot;, statuscb, ecb);

</Code>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/networkbearerselection
            </privilege>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="networkType">
            <descriptive>
                <description><p>
 The network type.
                </p></description>
            </descriptive>
            <Type name="NetworkType"/>
          </Argument>
          <Argument name="domainName">
            <descriptive>
                <description><p>
 The domain name.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 To be invoked if data network connection is released.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 To be invoked if the release is failed.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="NetworkSuccessCallback" id="::NetworkBearerSelection::NetworkSuccessCallback">
      <webidl>  [Callback, NoInterfaceObject] interface NetworkSuccessCallback {
    void onsuccess();

    void ondisconnected();
  };</webidl>
      <descriptive>
          <brief>
 This interface provides a success callback specific to NetworkBearerSelection.
          </brief>
         <description>
          <p>
It is used in asynchronous operations with requestRouteToHost().
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::NetworkBearerSelection::NetworkSuccessCallback::onsuccess">
        <webidl>    void onsuccess();</webidl>
        <descriptive>
            <brief>
 Called when a network is connected successfully.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
      <Operation name="ondisconnected" id="::NetworkBearerSelection::NetworkSuccessCallback::ondisconnected">
        <webidl>    void ondisconnected();</webidl>
        <descriptive>
            <brief>
 Called when a network is disconnected.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
    </Interface>
  </Module>
  <Module name="NFC" id="::NFC">
    <webidl>module NFC {
  enum NDEFRecordTextEncoding { &quot;UTF8&quot;, &quot;UTF16&quot; };

  enum NFCTagType { &quot;GENERIC_TARGET&quot;, &quot;ISO14443_A&quot;, &quot;ISO14443_4A&quot;, &quot;ISO14443_3A&quot;,
  &quot;MIFARE_MINI&quot;, &quot;MIFARE_1K&quot;, &quot;MIFARE_4K&quot;, &quot;MIFARE_ULTRA&quot;, &quot;MIFARE_DESFIRE&quot;,
  &quot;ISO14443_B&quot;, &quot;ISO14443_4B&quot;, &quot;ISO14443_BPRIME&quot;, &quot;FELICA&quot;, &quot;JEWEL&quot;, &quot;ISO15693&quot;,
  &quot;UNKNOWN_TARGET&quot; };

  [NoInterfaceObject] interface NFCManagerObject {
    readonly attribute <ref>NFCManager</ref> nfc;
  };
  <ref>Tizen</ref> implements <ref>NFCManagerObject</ref>;

  [NoInterfaceObject] interface NFCManager {
    const short NFC_RECORD_TNF_EMPTY = 0;
    const short NFC_RECORD_TNF_WELL_KNOWN = 1;
    const short NFC_RECORD_TNF_MIME_MEDIA = 2;
    const short NFC_RECORD_TNF_URI = 3;
    const short NFC_RECORD_TNF_EXTERNAL_RTD = 4;
    const short NFC_RECORD_TNF_UNKNOWN = 5;
    const short NFC_RECORD_TNF_UNCHANGED = 6;

    <ref>NFCAdapter</ref> getDefaultAdapter() raises(<ref>WebAPIException</ref>);

    void setExclusiveMode(boolean mode) raises(<ref>WebAPIException</ref>);
  };


  [NoInterfaceObject] interface NFCAdapter {
    readonly attribute boolean powered ;


    void setPowered(boolean state,
                    optional <ref>SuccessCallback</ref>? successCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);


    void setTagListener(<ref>NFCTagDetectCallback</ref> detectCallback,
                        optional <ref>NFCTagType</ref>[]? tagFilter) raises(<ref>WebAPIException</ref>);

    void setPeerListener(<ref>NFCPeerDetectCallback</ref> detectCallback) raises(<ref>WebAPIException</ref>);

    void unsetTagListener() raises(<ref>WebAPIException</ref>);

    void unsetPeerListener() raises(<ref>WebAPIException</ref>);

    <ref>NDEFMessage</ref>? getCachedMessage() raises(<ref>WebAPIException</ref>);

  };


  [NoInterfaceObject] interface NFCTag {
    readonly attribute <ref>NFCTagType</ref> type;

    readonly attribute boolean isSupportedNDEF;

    readonly attribute long ndefSize;

    readonly attribute object properties;

    readonly attribute boolean isConnected;


     void readNDEF(<ref>NDEFMessageReadCallback</ref> readCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void writeNDEF(<ref>NDEFMessage</ref> ndefMessage,
                   optional <ref>SuccessCallback</ref>? successCallback,
                   optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void transceive(byte[] data,
                    <ref>ByteArraySuccessCallback</ref> dataCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
  };


  [NoInterfaceObject] interface NFCPeer {
    readonly attribute boolean isConnected;

    void setReceiveNDEFListener(<ref>NDEFMessageReadCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);

    void unsetReceiveNDEFListener() raises(<ref>WebAPIException</ref>);

    void sendNDEF(<ref>NDEFMessage</ref> ndefMessage,
                  optional <ref>SuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

  };

  [Constructor(),
   Constructor(<ref>NDEFRecord</ref>[] ndefRecords),
   Constructor(byte[] rawData)]
  interface NDEFMessage {
    readonly attribute long recordCount;

    attribute <ref>NDEFRecord</ref>[] records;

    byte[] toByte() raises(<ref>WebAPIException</ref>);
  };

  [Constructor(short tnf, byte[] type, byte[] payload, optional byte[]? id),
   Constructor(byte[] raw_data)]
  interface NDEFRecord {
    readonly attribute short tnf;

    readonly attribute byte[] type;

    readonly attribute byte[] id;

    readonly attribute byte[] payload;
  };

  [Constructor(DOMString text, DOMString languageCode, optional DOMString? encoding)]
  interface NDEFRecordText : <ref>NDEFRecord</ref> {
    readonly attribute DOMString text;

    readonly attribute DOMString languageCode;

    readonly attribute <ref>NDEFRecordTextEncoding</ref> encoding;
  };

  [Constructor(DOMString uri)]
  interface NDEFRecordURI : <ref>NDEFRecord</ref> {
    readonly attribute DOMString uri;
  };
  [Constructor(DOMString mimeType, byte[] data)]
  interface NDEFRecordMedia : <ref>NDEFRecord</ref> {
    readonly attribute DOMString mimeType;
  };


  [Callback, NoInterfaceObject] interface NFCTagDetectCallback {
    void onattach(<ref>NFCTag</ref> nfcTag);
    void ondetach();
  };

  [Callback, NoInterfaceObject] interface NFCPeerDetectCallback {
    void onattach(<ref>NFCPeer</ref> nfcPeer);
    void ondetach();
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface NDEFMessageReadCallback {
    void onsuccess(<ref>NDEFMessage</ref> ndefMessage);
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface ByteArraySuccessCallback {
    void onsuccess(byte[] data);
  };

};</webidl>
    <descriptive>
        <brief>
  This interface specifies a protocol for simple wireless interconnection of
closely coupled devices operating at 13.56 MHz using Near Field Communication (NFC),
which is an international standard (ISO/IEC 18092).
To know more, see <a href="http://www.nfc-forum.org/specs/spec_list/">Technical Specifications</a>.
        </brief>
       <description>
        <p>
There are three groups of application scenarios for NFC:
        </p>
        <ul>
          <li>
Exchanging some digital information or data by holding a device close to a wireless tag.          </li>
          <li>
Exchanging some information or data between two devices by holding them close to each other.          </li>
          <li>
Making payments by holding mobile phones close to point of sales terminals instead of swiping smart cards.          </li>
        </ul>
        <p>
For more information on the NFC features, see <a href="../../org.tizen.web.appprogramming/html/guide/communication_guide/nfc.htm">NFC Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
        <def-api-feature identifier="http://tizen.org/feature/network.nfc">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with NFC feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
    </descriptive>
    <Enum name="NDEFRecordTextEncoding" id="::NFC::NDEFRecordTextEncoding">
      <webidl>  enum NDEFRecordTextEncoding { &quot;UTF8&quot;, &quot;UTF16&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that defines an encoding format for an NDEF record text.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="UTF8">
        <webidl> &quot;UTF8</webidl>
      </EnumValue>
      <EnumValue stringvalue="UTF16">
        <webidl> &quot;UTF16</webidl>
      </EnumValue>
    </Enum>
    <Enum name="NFCTagType" id="::NFC::NFCTagType">
      <webidl>  enum NFCTagType { &quot;GENERIC_TARGET&quot;, &quot;ISO14443_A&quot;, &quot;ISO14443_4A&quot;, &quot;ISO14443_3A&quot;,
  &quot;MIFARE_MINI&quot;, &quot;MIFARE_1K&quot;, &quot;MIFARE_4K&quot;, &quot;MIFARE_ULTRA&quot;, &quot;MIFARE_DESFIRE&quot;,
  &quot;ISO14443_B&quot;, &quot;ISO14443_4B&quot;, &quot;ISO14443_BPRIME&quot;, &quot;FELICA&quot;, &quot;JEWEL&quot;, &quot;ISO15693&quot;,
  &quot;UNKNOWN_TARGET&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that defines the type of NFC tag.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
GENERIC_TARGET            </li>
            <li>
ISO14443_A            </li>
            <li>
ISO14443_4A            </li>
            <li>
ISO14443_3A            </li>
            <li>
MIFARE_MINI            </li>
            <li>
MIFARE_1K            </li>
            <li>
MIFARE_4K            </li>
            <li>
MIFARE_ULTRA            </li>
            <li>
MIFARE_DESFIRE            </li>
            <li>
ISO14443_B            </li>
            <li>
ISO14443_4B            </li>
            <li>
ISO14443_BPRIME            </li>
            <li>
FELICA            </li>
            <li>
JEWEL            </li>
            <li>
ISO15693            </li>
            <li>
UNKNOWN_TARGET            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="GENERIC_TARGET">
        <webidl> &quot;GENERIC_TARGET</webidl>
      </EnumValue>
      <EnumValue stringvalue="ISO14443_A">
        <webidl> &quot;ISO14443_A</webidl>
      </EnumValue>
      <EnumValue stringvalue="ISO14443_4A">
        <webidl> &quot;ISO14443_4A</webidl>
      </EnumValue>
      <EnumValue stringvalue="ISO14443_3A">
        <webidl> &quot;ISO14443_3A</webidl>
      </EnumValue>
      <EnumValue stringvalue="MIFARE_MINI">
        <webidl>  &quot;MIFARE_MINI</webidl>
      </EnumValue>
      <EnumValue stringvalue="MIFARE_1K">
        <webidl> &quot;MIFARE_1K</webidl>
      </EnumValue>
      <EnumValue stringvalue="MIFARE_4K">
        <webidl> &quot;MIFARE_4K</webidl>
      </EnumValue>
      <EnumValue stringvalue="MIFARE_ULTRA">
        <webidl> &quot;MIFARE_ULTRA</webidl>
      </EnumValue>
      <EnumValue stringvalue="MIFARE_DESFIRE">
        <webidl> &quot;MIFARE_DESFIRE</webidl>
      </EnumValue>
      <EnumValue stringvalue="ISO14443_B">
        <webidl>  &quot;ISO14443_B</webidl>
      </EnumValue>
      <EnumValue stringvalue="ISO14443_4B">
        <webidl> &quot;ISO14443_4B</webidl>
      </EnumValue>
      <EnumValue stringvalue="ISO14443_BPRIME">
        <webidl> &quot;ISO14443_BPRIME</webidl>
      </EnumValue>
      <EnumValue stringvalue="FELICA">
        <webidl> &quot;FELICA</webidl>
      </EnumValue>
      <EnumValue stringvalue="JEWEL">
        <webidl> &quot;JEWEL</webidl>
      </EnumValue>
      <EnumValue stringvalue="ISO15693">
        <webidl> &quot;ISO15693</webidl>
      </EnumValue>
      <EnumValue stringvalue="UNKNOWN_TARGET">
        <webidl>  &quot;UNKNOWN_TARGET</webidl>
      </EnumValue>
    </Enum>
    <Interface name="NFCManagerObject" id="::NFC::NFCManagerObject">
      <webidl>  [NoInterfaceObject] interface NFCManagerObject {
    readonly attribute <ref>NFCManager</ref> nfc;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen</em> object from the Tizen Platform.
There will be a <em>tizen.nfc </em>object that allows access to the functionality of the NFC API.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="nfc" id="::NFC::NFCManagerObject::nfc">
        <webidl>    readonly attribute <ref>NFCManager</ref> nfc;</webidl>
        <Type name="NFCManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="NFCManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>NFCManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="NFCManager" id="::NFC::NFCManager">
      <webidl>  [NoInterfaceObject] interface NFCManager {
    const short NFC_RECORD_TNF_EMPTY = 0;
    const short NFC_RECORD_TNF_WELL_KNOWN = 1;
    const short NFC_RECORD_TNF_MIME_MEDIA = 2;
    const short NFC_RECORD_TNF_URI = 3;
    const short NFC_RECORD_TNF_EXTERNAL_RTD = 4;
    const short NFC_RECORD_TNF_UNKNOWN = 5;
    const short NFC_RECORD_TNF_UNCHANGED = 6;

    <ref>NFCAdapter</ref> getDefaultAdapter() raises(<ref>WebAPIException</ref>);

    void setExclusiveMode(boolean mode) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 Accesses to the NFC tag/target.
          </brief>
         <description>
          <p>
It provides access to the API functionalities through the tizen.nfc interface.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Const name="NFC_RECORD_TNF_EMPTY" value="0" id="::NFC::NFCManager::NFC_RECORD_TNF_EMPTY">
        <webidl>    const short NFC_RECORD_TNF_EMPTY = 0;</webidl>
        <descriptive>
            <brief>
 A constant to indicate empty format of NDEF record's type field.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="short"/>
      </Const>
      <Const name="NFC_RECORD_TNF_WELL_KNOWN" value="1" id="::NFC::NFCManager::NFC_RECORD_TNF_WELL_KNOWN">
        <webidl>    const short NFC_RECORD_TNF_WELL_KNOWN = 1;</webidl>
        <descriptive>
            <brief>
 A constant to indicate Record Type Definition (RTD) format of NDEF record's type field.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="short"/>
      </Const>
      <Const name="NFC_RECORD_TNF_MIME_MEDIA" value="2" id="::NFC::NFCManager::NFC_RECORD_TNF_MIME_MEDIA">
        <webidl>    const short NFC_RECORD_TNF_MIME_MEDIA = 2;</webidl>
        <descriptive>
            <brief>
 A constant to indicate MIME media types format in RFC 2046 [RFC 2046] of NDEF record's type field.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="short"/>
      </Const>
      <Const name="NFC_RECORD_TNF_URI" value="3" id="::NFC::NFCManager::NFC_RECORD_TNF_URI">
        <webidl>    const short NFC_RECORD_TNF_URI = 3;</webidl>
        <descriptive>
            <brief>
 A constant to indicate absolute URI, as defined in RFC 3986 [RFC 3986] format in RFC 2046 [RFC 2046] of NDEF record's type field.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="short"/>
      </Const>
      <Const name="NFC_RECORD_TNF_EXTERNAL_RTD" value="4" id="::NFC::NFCManager::NFC_RECORD_TNF_EXTERNAL_RTD">
        <webidl>    const short NFC_RECORD_TNF_EXTERNAL_RTD = 4;</webidl>
        <descriptive>
            <brief>
 A constant to indicate NFC forum external type [NFC RTD] format in RFC 2046 [RFC 2046] of NDEF record's type field.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="short"/>
      </Const>
      <Const name="NFC_RECORD_TNF_UNKNOWN" value="5" id="::NFC::NFCManager::NFC_RECORD_TNF_UNKNOWN">
        <webidl>    const short NFC_RECORD_TNF_UNKNOWN = 5;</webidl>
        <descriptive>
            <brief>
 A constant to indicate unknown type format in RFC 2046 [RFC 2046] of NDEF record's type field.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="short"/>
      </Const>
      <Const name="NFC_RECORD_TNF_UNCHANGED" value="6" id="::NFC::NFCManager::NFC_RECORD_TNF_UNCHANGED">
        <webidl>    const short NFC_RECORD_TNF_UNCHANGED = 6;</webidl>
        <descriptive>
            <brief>
 A constant to indicate whether the payload is an intermediate or final chunk of a chunked NDEF record.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="short"/>
      </Const>
      <Operation name="getDefaultAdapter" id="::NFC::NFCManager::getDefaultAdapter">
        <webidl>    <ref>NFCAdapter</ref> getDefaultAdapter() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the default NFC adapter of the device.
            </brief>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.common
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
  var adapter = tizen.nfc.getDefaultAdapter() ;
 } catch (err) {
  console.log (err.name +&quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type name="NFCAdapter">
          <descriptive>
              <description><p>
 NFCAdapter The default NFCAdapter object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setExclusiveMode" id="::NFC::NFCManager::setExclusiveMode">
        <webidl>    void setExclusiveMode(boolean mode) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gives priority to the current application for NFC operations over other applications when it is in the foreground.
            </brief>
           <description>
            <p>
If the current application has the priority and is on the foreground, the system stops sending
application control requests that are used to pick an application to handle a request about NFC.
Such a request is usually sent, for example, when detecting an NFC tag or receiving an NDEF message
from a connected NFC peer-to-peer target.
            </p>
            <p>
When the current application moves to the background, it loses the priority.
            </p>
            <p>
The exclusive mode can only be set when NFC is on. If NFC is off, the mode is ignored.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.common
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
   tizen.nfc.setExclusiveMode(true) ;
 } catch (err) {
   console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="mode">
            <descriptive>
                <description><p>
 The value of exclusive mode.
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="NFCAdapter" id="::NFC::NFCAdapter">
      <webidl>  [NoInterfaceObject] interface NFCAdapter {
    readonly attribute boolean powered ;


    void setPowered(boolean state,
                    optional <ref>SuccessCallback</ref>? successCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);


    void setTagListener(<ref>NFCTagDetectCallback</ref> detectCallback,
                        optional <ref>NFCTagType</ref>[]? tagFilter) raises(<ref>WebAPIException</ref>);

    void setPeerListener(<ref>NFCPeerDetectCallback</ref> detectCallback) raises(<ref>WebAPIException</ref>);

    void unsetTagListener() raises(<ref>WebAPIException</ref>);

    void unsetPeerListener() raises(<ref>WebAPIException</ref>);

    <ref>NDEFMessage</ref>? getCachedMessage() raises(<ref>WebAPIException</ref>);

  };</webidl>
      <descriptive>
          <brief>
 This interface provides access to control the adapter by offering methods to control local NFC behaviors, such as turning on/off an adapter.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="powered" id="::NFC::NFCAdapter::powered">
        <webidl>    readonly attribute boolean powered ;</webidl>
        <descriptive>
            <brief>
 The state of the NFC adapter.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="setPowered" id="::NFC::NFCAdapter::setPowered">
        <webidl>    void setPowered(boolean state,
                    optional <ref>SuccessCallback</ref>? successCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the power of an NFC adapter to either a on state or a off state.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If the NFC device is busy.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.admin
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var gNfcAdapter;
 var onPowerOn = function(){ // Called when NFC adapter is powered on
   try {
     console.log(&quot;Power on succeed&quot;);
     // Implement NFC communication routines ...
     gNfcAdapter.setPowered(
         false, // Disable NFC adapter
         function () {console.log(&quot;Power off succeed&quot;); }, // Handle success
         function () {console.log(&quot;Power off failed&quot;); }); // Handle failure
   } catch (err) {
     console.log (err.name + &quot;: &quot; + err.message);
   }
 };
 try {
   gNfcAdapter = tizen.nfc.getDefaultAdapter();
   if (!gNfcAdapter.powered) {
     gNfcAdapter.setPowered(
         true, // Enable NFC adapter
         onPowerOn,                                     // Handle succes
         function () {console.log(&quot;Power on failed&quot;)}); // Handle failure
   } else {
     onPowerOn();
   }
 } catch (err) {
   console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="state">
            <descriptive>
                <description><p>
 The state of NFC adapter, <var>true</var> means on, <var>false</var> means off
                </p></description>
            </descriptive>
            <Type type="boolean"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to call when NFC adapter is
enabled or disabled successfully.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setTagListener" id="::NFC::NFCAdapter::setTagListener">
        <webidl>    void setTagListener(<ref>NFCTagDetectCallback</ref> detectCallback,
                        optional <ref>NFCTagType</ref>[]? tagFilter) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Registers a callback function to invoke when an NFC tag is detected.
            </brief>
           <description>
            <p>
If the registration completes successfully, the detectCallback must be
invoked when NFC tag is detected.
            </p>
            <p>
If no tagFilter is passed, it shall consider the default tagFilter, that is to set all tag types.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.tag
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var adapter = tizen.nfc.getDefaultAdapter();
 var onSuccessCB = {onattach : function(nfcTag) {
     console.log(&quot;NFC Tag's type is &quot; + nfcTag.type);
   }, ondetach : function() {
     console.log(&quot;NFC Tag is detached&quot;);
   }};
 adapter.setTagListener(onSuccessCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="detectCallback">
            <descriptive>
                <description><p>
 The method to invoke when a NFC tag is successfully detected.
                </p></description>
            </descriptive>
            <Type name="NFCTagDetectCallback"/>
          </Argument>
          <Argument optional="optional" name="tagFilter">
            <descriptive>
                <description><p>
 A filter to be used when specific NFC tag is detected.
                </p></description>
            </descriptive>
            <Type type="array" nullable="nullable">
              <Type name="NFCTagType"/>
            </Type>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type ServiceNotAvailableError, if the NFC service is not available.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setPeerListener" id="::NFC::NFCAdapter::setPeerListener">
        <webidl>    void setPeerListener(<ref>NFCPeerDetectCallback</ref> detectCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Registers a callback function to be invoked when NFC peer-to-peer target is detected.
            </brief>
           <description>
            <p>
If the registration completes successfully, the detectCallback must be
invoked when NFC peer-to-peer target is detected.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.p2p
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var adapter = tizen.nfc.getDefaultAdapter();
 var onSuccessCB = {onattach : function(nfcPeer) {
     console.log(&quot;NFC Target is detected&quot;);
   }, ondetach : function() {
     console.log(&quot;NFC Target is detached&quot;);
   }};
 adapter.setPeerListener(onSuccessCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="detectCallback">
            <descriptive>
                <description><p>
 The method to invoke when a NFC peer-to-peer target is successfully detected.
                </p></description>
            </descriptive>
            <Type name="NFCPeerDetectCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type ServiceNotAvailableError, if the NFC service is not available.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unsetTagListener" id="::NFC::NFCAdapter::unsetTagListener">
        <webidl>    void unsetTagListener() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unregisters the listener for detecting an NFC tag.
            </brief>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.tag
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var adapter = tizen.nfc.getDefaultAdapter();

 // Receives NFCTag
 var onSuccessCB = {onattach : function(nfcTag) {
     console.log(&quot;NFC Tag's type is &quot; + nfcTag.type);
   }, ondetach : function() {
     console.log(&quot;NFC Tag is detached&quot;);
   }};

 // Unregister the listener
 function unsetListen() {
   adapter.unsetTagListener();
 }

 // Registers to be notified when NFC tag is detected.
 adapter.setTagListener(onSuccessCB)
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type ServiceNotAvailableError, if the NFC service is not available.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unsetPeerListener" id="::NFC::NFCAdapter::unsetPeerListener">
        <webidl>    void unsetPeerListener() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unregisters the listener for detecting an NFC peer-to-peer target.
            </brief>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.p2p
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var adapter = tizen.nfc.getDefaultAdapter();

 // Receives an NFC peer.
 var onSuccessCB = {onattach : function(nfcPeer) {
     console.log(&quot;NFC Target is detected&quot;);
   }, ondetach : function() {
     console.log(&quot;NFC Target is detached&quot;);
   }};

 // Unregisters the listener.
 function unsetListen() {
   adapter.unsetPeerListener();
 }

 // Registers to be notified when NFC peer-to-peer target is detected.
 adapter.setPeerListener(onSuccessCB)
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type ServiceNotAvailableError, if the NFC service is not available.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getCachedMessage" id="::NFC::NFCAdapter::getCachedMessage">
        <webidl>    <ref>NDEFMessage</ref>? getCachedMessage() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the NDEF message cached when the tag is detected.
            </brief>
           <description>
            <p>
If the operation completes successfully, the NDEF Message that was last read
should be returned.
            </p>
           </description>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.common
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> // Gets the cached message
 var cachedMessage = tizen.nfc.getDefaultAdapter().getCachedMessage();
 </Code>
        </descriptive>
        <Type name="NDEFMessage" nullable="nullable">
          <descriptive>
              <description><p>
 The NDEF Message that was last read.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="NFCTag" id="::NFC::NFCTag">
      <webidl>  [NoInterfaceObject] interface NFCTag {
    readonly attribute <ref>NFCTagType</ref> type;

    readonly attribute boolean isSupportedNDEF;

    readonly attribute long ndefSize;

    readonly attribute object properties;

    readonly attribute boolean isConnected;


     void readNDEF(<ref>NDEFMessageReadCallback</ref> readCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void writeNDEF(<ref>NDEFMessage</ref> ndefMessage,
                   optional <ref>SuccessCallback</ref>? successCallback,
                   optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    void transceive(byte[] data,
                    <ref>ByteArraySuccessCallback</ref> dataCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This interface provides accesses to the NFC tag.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="type" id="::NFC::NFCTag::type">
        <webidl>    readonly attribute <ref>NFCTagType</ref> type;</webidl>
        <descriptive>
            <brief>
 The type of the NFC tag.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="NFCTagType"/>
      </Attribute>
      <Attribute readonly="readonly" name="isSupportedNDEF" id="::NFC::NFCTag::isSupportedNDEF">
        <webidl>    readonly attribute boolean isSupportedNDEF;</webidl>
        <descriptive>
            <brief>
 An attribute to check if the NFC Tag supports NDEF format.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="ndefSize" id="::NFC::NFCTag::ndefSize">
        <webidl>    readonly attribute long ndefSize;</webidl>
        <descriptive>
            <brief>
 The size of NDEF message stored in the tag.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="properties" id="::NFC::NFCTag::properties">
        <webidl>    readonly attribute object properties;</webidl>
        <descriptive>
            <brief>
 The value is all tag information.
            </brief>
           <description>
            <p>
It is pairs of key and value.
The array's index is the pair's key and value is its value.
            </p>
           </description>
            <Code> var adapter = tizen.nfc.getDefaultAdapter();
 var onSuccessCB = {onattach : function(nfcTag) {
     console.log(&quot;NFC Tag's type is &quot; + nfcTag.type);
     for(var i in nfcTag.properties) {
       console.log(&quot;key:&quot; + i + &quot; value:&quot; + nfcTag.properties[i]);
     }
   }, ondetach : function() {
     console.log(&quot;NFC Tag is detached&quot;);
   }};
 adapter.setTagListener(onSuccessCB);

 </Code>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="object"/>
      </Attribute>
      <Attribute readonly="readonly" name="isConnected" id="::NFC::NFCTag::isConnected">
        <webidl>    readonly attribute boolean isConnected;</webidl>
        <descriptive>
            <brief>
 The value is necessary to check if this tag is connected.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="readNDEF" id="::NFC::NFCTag::readNDEF">
        <webidl>     void readNDEF(<ref>NDEFMessageReadCallback</ref> readCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Reads the NDEF data from the NFC tag.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 ServiceNotAvailableError - If the NFC service is not available.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.tag
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="readCallback">
            <descriptive>
                <description><p>
 The method invoked in case of successfully reading the NDEF Data.
                </p></description>
            </descriptive>
            <Type name="NDEFMessageReadCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method invoked in case of any error during reading the NDEF Data.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if current Tag doesn't support NDEF format.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="writeNDEF" id="::NFC::NFCTag::writeNDEF">
        <webidl>    void writeNDEF(<ref>NDEFMessage</ref> ndefMessage,
                   optional <ref>SuccessCallback</ref>? successCallback,
                   optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Writes the NDEF data to the NFC tag.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
 ServiceNotAvailableError: If the NFC service is not available.               </li>
              <li>
 UnknownError: In any other error case.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.tag
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="ndefMessage">
            <descriptive>
                <description><p>
 The NDEF message to write to NFC tag.
                </p></description>
            </descriptive>
            <Type name="NDEFMessage"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method invoked in case of successfully writing the NDEF Data.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method invoked in case of any error during writing the NDEF Data.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if current Tag doesn't support NDEF format.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="transceive" id="::NFC::NFCTag::transceive">
        <webidl>    void transceive(byte[] data,
                    <ref>ByteArraySuccessCallback</ref> dataCallback,
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Access the raw format card. The transceive function is the only way to access the raw format card (not formatted).
Each tag type requires its own command to access tags.
This API provides low level access of tag operation. (Note that you must know each tag technology.)
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
 ServiceNotAvailableError - If the NFC service is not available.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.tag
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="data">
            <descriptive>
                <description><p>
 The raw data to transceive with the NFC tag.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
          <Argument name="dataCallback">
            <descriptive>
                <description><p>
 Invoked in case of successfully transceiving the raw data.
                </p></description>
            </descriptive>
            <Type name="ByteArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 Invoked in case of any error during transceiving the NDEF Data.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="NFCPeer" id="::NFC::NFCPeer">
      <webidl>  [NoInterfaceObject] interface NFCPeer {
    readonly attribute boolean isConnected;

    void setReceiveNDEFListener(<ref>NDEFMessageReadCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);

    void unsetReceiveNDEFListener() raises(<ref>WebAPIException</ref>);

    void sendNDEF(<ref>NDEFMessage</ref> ndefMessage,
                  optional <ref>SuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

  };</webidl>
      <descriptive>
          <brief>
 An interface that provides access to the NFC peer-to-peer target.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="isConnected" id="::NFC::NFCPeer::isConnected">
        <webidl>    readonly attribute boolean isConnected;</webidl>
        <descriptive>
            <brief>
 The value is necessary to check if this NFC peer-to-peer target is connected.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="setReceiveNDEFListener" id="::NFC::NFCPeer::setReceiveNDEFListener">
        <webidl>    void setReceiveNDEFListener(<ref>NDEFMessageReadCallback</ref> successCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Registers a callback function to be invoked when an NDEF message is received from the connected NFC peer-to-peer target.
            </brief>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.p2p
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var adapter = tizen.nfc.getDefaultAdapter();

 // Receives NFCPeer
 var onSuccessCB = {onattach : function(nfcPeer) {
     console.log(&quot;NFC Target is detected&quot;);
     nfcPeer.setReceiveNDEFListener(
         function(message){
            console.log(&quot;Receive message&quot;);
         });
   }, ondetach : function() {
     console.log(&quot;NFC Target is detached&quot;);
   }};

 adapter.setPeerListener(onSuccessCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 Invoked in case of successful receiving the message.
                </p></description>
            </descriptive>
            <Type name="NDEFMessageReadCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type ServiceNotAvailableError, if the NFC service is not available.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unsetReceiveNDEFListener" id="::NFC::NFCPeer::unsetReceiveNDEFListener">
        <webidl>    void unsetReceiveNDEFListener() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unregisters the listener for receiving NDEF messages from the NFC peer-to-peer target connected.
            </brief>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.p2p
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var adapter = tizen.nfc.getDefaultAdapter();
 var onSuccessCB = {onattach : function(nfcPeer) {
     console.log(&quot;NFC Target is detected&quot;);
     nfcPeer.setReceiveNDEFListener(
         function(message){
            console.log(&quot;Receive message&quot;);
            nfcPeer.unsetReceiveNDEFListener();
         });
   }, ondetach : function() {
     console.log(&quot;NFC Target is detached&quot;);
   }};
 }

 adapter.setPeerListener(onSuccessCB);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type ServiceNotAvailableError, if the NFC service is not available.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="sendNDEF" id="::NFC::NFCPeer::sendNDEF">
        <webidl>    void sendNDEF(<ref>NDEFMessage</ref> ndefMessage,
                  optional <ref>SuccessCallback</ref>? successCallback,
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sends data to the NFC peer-to-peer target.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError: If any of the input parameters contain an invalid value.              </li>
              <li>
 ServiceNotAvailableError: If the NFC service is not available.               </li>
              <li>
 UnknownError: In any other error case.               </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <privilege>
 http://tizen.org/privilege/nfc.p2p
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="ndefMessage">
            <descriptive>
                <description><p>
 The NDEF message to send to NFC peer-to-peer target.
                </p></description>
            </descriptive>
            <Type name="NDEFMessage"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 Invoked in case of successfully sending data to NFC peer-to-peer target.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 Invoked in case of any error during sending.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="NDEFMessage" id="::NFC::NDEFMessage">
      <webidl>  [Constructor(),
   Constructor(<ref>NDEFRecord</ref>[] ndefRecords),
   Constructor(byte[] rawData)]
  interface NDEFMessage {
    readonly attribute long recordCount;

    attribute <ref>NDEFRecord</ref>[] records;

    byte[] toByte() raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The NDEFMessage interface. An NDEFmessage is composed of multiple NDEFRecords.
The NDEFMessage must have at least one NDEFRecord.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor()</webidl>
          <ArgumentList/>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>   Constructor(<ref>NDEFRecord</ref>[] ndefRecords)</webidl>
          <ArgumentList>
            <Argument name="ndefRecords">
              <Type type="array">
                <Type name="NDEFRecord"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>   Constructor(byte[] rawData)</webidl>
          <ArgumentList>
            <Argument name="rawData">
              <Type type="array">
                <Type type="byte"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="recordCount" id="::NFC::NDEFMessage::recordCount">
        <webidl>    readonly attribute long recordCount;</webidl>
        <descriptive>
            <brief>
 The number of records in the NDEFMessage.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Attribute name="records" id="::NFC::NDEFMessage::records">
        <webidl>    attribute <ref>NDEFRecord</ref>[] records;</webidl>
        <descriptive>
            <brief>
 The array of NDEFRecord objects in the NDEFMessage.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="NDEFRecord"/>
        </Type>
      </Attribute>
      <Operation name="toByte" id="::NFC::NDEFMessage::toByte">
        <webidl>    byte[] toByte() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the serial byte array of the NDEF message.
            </brief>
           <description>
            <p>
If the operation completes successfully, it returns the serial byte array of the NDEF message.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // Gets the cached message.
 var cachedMessage = tizen.nfc.getDefaultAdapter().getCachedMessage();
 var raw = cachedMessage.toByte();
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 byte[] The raw data in the NDEFMessage.
              </p></description>
          </descriptive>
          <Type type="byte"/>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the records whose type is not NDEFRecord are included in the NDEFMessage.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="NDEFRecord" id="::NFC::NDEFRecord">
      <webidl>  [Constructor(short tnf, byte[] type, byte[] payload, optional byte[]? id),
   Constructor(byte[] raw_data)]
  interface NDEFRecord {
    readonly attribute short tnf;

    readonly attribute byte[] type;

    readonly attribute byte[] id;

    readonly attribute byte[] payload;
  };</webidl>
      <descriptive>
          <brief>
 The NDEFRecord interface.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(short tnf, byte[] type, byte[] payload, optional byte[]? id)</webidl>
          <ArgumentList>
            <Argument name="tnf">
              <Type type="short"/>
            </Argument>
            <Argument name="type">
              <Type type="array">
                <Type type="byte"/>
              </Type>
            </Argument>
            <Argument name="payload">
              <Type type="array">
                <Type type="byte"/>
              </Type>
            </Argument>
            <Argument optional="optional" name="id">
              <Type type="array" nullable="nullable">
                <Type type="byte"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>   Constructor(byte[] raw_data)</webidl>
          <ArgumentList>
            <Argument name="raw_data">
              <Type type="array">
                <Type type="byte"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="tnf" id="::NFC::NDEFRecord::tnf">
        <webidl>    readonly attribute short tnf;</webidl>
        <descriptive>
            <brief>
 The value of the record type (TNF value).
            </brief>
           <description>
            <p>
At least the following values must be supported:
            </p>
            <ul>
              <li>
NFC_RECORD_TNF_EMPTY - The record type is empty              </li>
              <li>
NFC_RECORD_TNF_WELL_KNOWN - Record Type Definition (RTD) format [NFC RTD]              </li>
              <li>
NFC_RECORD_TNF_MIME_MEDIA - MIME media types in RFC 2046 [RFC 2046]              </li>
              <li>
NFC_RECORD_TNF_URI - Absolute URI as defined in RFC 3986 [RFC 3986]              </li>
              <li>
NFC_RECORD_TNF_EXTERNAL_RTD - NFC forum external type [NFC RTD]              </li>
              <li>
NFC_RECORD_TNF_UNKNOWN - The payload type is unknown              </li>
              <li>
NFC_RECORD_TNF_UNCHANGED - It means the payload is an intermediate or final chunk of a chunked NDEF record              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="short"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::NFC::NDEFRecord::type">
        <webidl>    readonly attribute byte[] type;</webidl>
        <descriptive>
            <brief>
 The specified type in byte array.
            </brief>
           <description>
            <p>
The byte array contains <var>0</var> to <var>255</var> bytes.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="byte"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="id" id="::NFC::NDEFRecord::id">
        <webidl>    readonly attribute byte[] id;</webidl>
        <descriptive>
            <brief>
 The record ID.
            </brief>
           <description>
            <p>
The byte array contains <var>0</var> to <var>255</var> bytes.
            </p>
            <p>
By default, this attribute is set to an empty array.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type type="byte"/>
        </Type>
      </Attribute>
      <Attribute readonly="readonly" name="payload" id="::NFC::NDEFRecord::payload">
        <webidl>    readonly attribute byte[] payload;</webidl>
        <descriptive>
            <brief>
 The record payload.
            </brief>
           <description>
            <p>
The byte array contains <var>0</var> to <var>(2 ** 32 - 1)</var> bytes.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // Creates a new NDEF record.
 var newRecord = new tizen.NDEFRecordURI(&quot;https://www.tizen.org/&quot;);
 var payload = newRecord.payload;
 </Code>
        </descriptive>
        <Type type="array">
          <Type type="byte"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="NDEFRecordText" id="::NFC::NDEFRecordText">
      <webidl>  [Constructor(DOMString text, DOMString languageCode, optional DOMString? encoding)]
  interface NDEFRecordText : <ref>NDEFRecord</ref> {
    readonly attribute DOMString text;

    readonly attribute DOMString languageCode;

    readonly attribute <ref>NDEFRecordTextEncoding</ref> encoding;
  };</webidl>
      <descriptive>
          <brief>
 The NDEFRecord that has the text type payload.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString text, DOMString languageCode, optional DOMString? encoding)</webidl>
          <ArgumentList>
            <Argument name="text">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="languageCode">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="encoding">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="NDEFRecord"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="text" id="::NFC::NDEFRecordText::text">
        <webidl>    readonly attribute DOMString text;</webidl>
        <descriptive>
            <brief>
 The encoded text.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="languageCode" id="::NFC::NDEFRecordText::languageCode">
        <webidl>    readonly attribute DOMString languageCode;</webidl>
        <descriptive>
            <brief>
 The language code string value, followed by IANA[RFC 3066] (for example, en-US, ko-KR).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="encoding" id="::NFC::NDEFRecordText::encoding">
        <webidl>    readonly attribute <ref>NDEFRecordTextEncoding</ref> encoding;</webidl>
        <descriptive>
            <brief>
 The encoding type. By default, this attribute is set to UTF8.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="NDEFRecordTextEncoding"/>
      </Attribute>
    </Interface>
    <Interface name="NDEFRecordURI" id="::NFC::NDEFRecordURI">
      <webidl>  [Constructor(DOMString uri)]
  interface NDEFRecordURI : <ref>NDEFRecord</ref> {
    readonly attribute DOMString uri;
  };</webidl>
      <descriptive>
          <brief>
 The NDEFRecord that has URI type payload.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString uri)</webidl>
          <ArgumentList>
            <Argument name="uri">
              <Type type="DOMString"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="NDEFRecord"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="uri" id="::NFC::NDEFRecordURI::uri">
        <webidl>    readonly attribute DOMString uri;</webidl>
        <descriptive>
            <brief>
 The URI string that is stored in the payload.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="NDEFRecordMedia" id="::NFC::NDEFRecordMedia">
      <webidl>  [Constructor(DOMString mimeType, byte[] data)]
  interface NDEFRecordMedia : <ref>NDEFRecord</ref> {
    readonly attribute DOMString mimeType;
  };</webidl>
      <descriptive>
          <brief>
 The NDEFRecord that has mime type payload.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString mimeType, byte[] data)</webidl>
          <descriptive>
             <description>
              <ul>
                <li>
<b>data</b> : Mime type payload. The byte array contains <var>0</var> to <var>(2 ** 32 - 1)</var> bytes.                </li>
              </ul>
             </description>
          </descriptive>
          <ArgumentList>
            <Argument name="mimeType">
              <Type type="DOMString"/>
            </Argument>
            <Argument name="data">
              <Type type="array">
                <Type type="byte"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="NDEFRecord"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="mimeType" id="::NFC::NDEFRecordMedia::mimeType">
        <webidl>    readonly attribute DOMString mimeType;</webidl>
        <descriptive>
            <brief>
 The mime type [RFC 2046] (for example, text/plain, image/jpeg ).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="NFCTagDetectCallback" id="::NFC::NFCTagDetectCallback">
      <webidl>  [Callback, NoInterfaceObject] interface NFCTagDetectCallback {
    void onattach(<ref>NFCTag</ref> nfcTag);
    void ondetach();
  };</webidl>
      <descriptive>
          <brief>
 The success callback to be invoked when an NFC tag is detected or lost.
          </brief>
         <description>
          <p>
This callback interface specifies two methods:
          </p>
          <ul>
            <li>
 onattach: invoked when an NFC tag is detected            </li>
            <li>
 ondetach: invoked when the NFC tag is lost            </li>
          </ul>
          <p>
It is used in NFCAdapter.setTagListener().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onattach" id="::NFC::NFCTagDetectCallback::onattach">
        <webidl>    void onattach(<ref>NFCTag</ref> nfcTag);</webidl>
        <descriptive>
            <brief>
 The method invoked when a tag is attached.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="nfcTag">
            <descriptive>
                <description><p>
 The attached NFC tag.
                </p></description>
            </descriptive>
            <Type name="NFCTag"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="ondetach" id="::NFC::NFCTagDetectCallback::ondetach">
        <webidl>    void ondetach();</webidl>
        <descriptive>
            <brief>
 The method invoked when the connected tag is detached.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Interface name="NFCPeerDetectCallback" id="::NFC::NFCPeerDetectCallback">
      <webidl>  [Callback, NoInterfaceObject] interface NFCPeerDetectCallback {
    void onattach(<ref>NFCPeer</ref> nfcPeer);
    void ondetach();
  };</webidl>
      <descriptive>
          <brief>
 The success callback to be invoked when an NFC peer-to-peer target is detected or lost.
          </brief>
         <description>
          <p>
This callback interface specifies two methods:
          </p>
          <ul>
            <li>
 onattach: invoked when an NFC peer-to-peer target is detected            </li>
            <li>
 ondetach: invoked when the NFC peer-to-peer target is lost            </li>
          </ul>
          <p>
It is used in NFCAdapter.setPeerListener().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onattach" id="::NFC::NFCPeerDetectCallback::onattach">
        <webidl>    void onattach(<ref>NFCPeer</ref> nfcPeer);</webidl>
        <descriptive>
            <brief>
 The method invoked when the NFC peer-to-peer target is attached.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="nfcPeer">
            <descriptive>
                <description><p>
 The attached NFC peer-to-peer target.
                </p></description>
            </descriptive>
            <Type name="NFCPeer"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="ondetach" id="::NFC::NFCPeerDetectCallback::ondetach">
        <webidl>    void ondetach();</webidl>
        <descriptive>
            <brief>
 The method invoked when the NFC peer-to-peer target connected is detached.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Interface name="NDEFMessageReadCallback" id="::NFC::NDEFMessageReadCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface NDEFMessageReadCallback {
    void onsuccess(<ref>NDEFMessage</ref> ndefMessage);
  };</webidl>
      <descriptive>
          <brief>
 The success callback to be invoked when data has been read successfully from the NFC tag or target.
          </brief>
         <description>
          <p>
This callback interface specifies a success method with
an NDEF message as an input parameter.
It is used in asynchronous
operations, such as NFCTag.readNDEF() or NFCPeer.setReceiveNDEFListener().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::NFC::NDEFMessageReadCallback::onsuccess">
        <webidl>    void onsuccess(<ref>NDEFMessage</ref> ndefMessage);</webidl>
        <descriptive>
            <brief>
 The method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="ndefMessage">
            <descriptive>
                <description><p>
 NDEF message that is read from the NFC tag or target.
                </p></description>
            </descriptive>
            <Type name="NDEFMessage"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ByteArraySuccessCallback" id="::NFC::ByteArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ByteArraySuccessCallback {
    void onsuccess(byte[] data);
  };</webidl>
      <descriptive>
          <brief>
 The success callback to be invoked when NFCTag.transceive() completes successfully.
          </brief>
         <description>
          <p>
This callback interface specifies a success method, with
a raw data as an input parameter. It is used in NFCTag.transceive().
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::NFC::ByteArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(byte[] data);</webidl>
        <descriptive>
            <brief>
 The method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="data">
            <descriptive>
                <description><p>
 The raw data that is read from NFC tag or response of transceive operation.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Notification" id="::Notification">
    <webidl>module Notification {

    typedef DOMString NotificationId;

    enum NotificationType { &quot;STATUS&quot; };

    enum StatusNotificationType { &quot;SIMPLE&quot;, &quot;THUMBNAIL&quot;, &quot;ONGOING&quot;, &quot;PROGRESS&quot; };

    enum NotificationProgressType { &quot;PERCENTAGE&quot;,  &quot;BYTE&quot; };


    [NoInterfaceObject] interface NotificationObject {
        readonly attribute <ref>NotificationManager</ref> notification;
    };
    <ref>Tizen</ref> implements <ref>NotificationObject</ref>;

    [NoInterfaceObject] interface NotificationManager {

    void post(<ref>Notification</ref> notification) raises(<ref>WebAPIException</ref>);

    void update(<ref>Notification</ref> notification) raises(<ref>WebAPIException</ref>);

    void remove(<ref>NotificationId</ref> id) raises(<ref>WebAPIException</ref>);

    void removeAll() raises(<ref>WebAPIException</ref>);

    <ref>Notification</ref> get(<ref>NotificationId</ref> id) raises(<ref>WebAPIException</ref>);

    <ref>Notification</ref>[] getAll() raises(<ref>WebAPIException</ref>);

    };


    [NoInterfaceObject] interface Notification {


    readonly attribute <ref>NotificationId</ref> id;

    readonly attribute <ref>NotificationType</ref> type;

    readonly attribute Date postedTime;

    attribute DOMString title;

    attribute DOMString? content;

    };


    dictionary StatusNotificationInit {
        DOMString? content;
        DOMString? iconPath;
        DOMString? soundPath;
        boolean? vibration;
        <ref>ApplicationControl</ref>? appControl;
        <ref>ApplicationId</ref>? appId;
        <ref>NotificationProgressType</ref>? progressType;
        unsigned long? progressValue;
        long? number;
        DOMString? subIconPath;
        <ref>NotificationDetailInfo</ref>[]? detailInfo;
        DOMString? ledColor;
        unsigned long ledOnPeriod;
        unsigned long ledOffPeriod;
        DOMString? backgroundImagePath;
        DOMString[]? thumbnails;
    };

   [Constructor(<ref>StatusNotificationType</ref> statusType, DOMString title, optional <ref>StatusNotificationInit</ref>? notificationInitDict)]


    interface StatusNotification : <ref>Notification</ref> {

    readonly attribute <ref>StatusNotificationType</ref> statusType;

    attribute DOMString? iconPath;

    attribute DOMString? subIconPath;

    attribute long? number;

    attribute <ref>NotificationDetailInfo</ref>[]? detailInfo;

    attribute DOMString? ledColor;

    attribute unsigned long ledOnPeriod;

    attribute unsigned long ledOffPeriod;

     attribute DOMString? backgroundImagePath;

     attribute DOMString[]? thumbnails;

     attribute DOMString? soundPath;

     attribute boolean vibration;

     attribute <ref>ApplicationControl</ref>? appControl;

     attribute <ref>ApplicationId</ref>? appId;

     attribute <ref>NotificationProgressType</ref> progressType;

     attribute unsigned long? progressValue;
    };


[Constructor(DOMString mainText, optional DOMString? subText)]
    interface NotificationDetailInfo {
    attribute DOMString mainText;

    attribute DOMString? subText;
    };

};</webidl>
    <descriptive>
        <brief>
 The Notification API provides a way to notify users of events that happen in an application.
        </brief>
       <description>
        <p>
For more information on the Notification features, see <a href="../../org.tizen.web.appprogramming/html/guide/ui_guide/notification.htm">Notification Guide</a>.
        </p>
       </description>
        <version>
 2.0
        </version>
    </descriptive>
    <Typedef name="NotificationId" id="::Notification::NotificationId">
      <webidl>    typedef DOMString NotificationId;</webidl>
      <descriptive>
          <brief>
 A notification ID.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Enum name="NotificationType" id="::Notification::NotificationType">
      <webidl>    enum NotificationType { &quot;STATUS&quot; };</webidl>
      <descriptive>
          <brief>
 A notification type.
          </brief>
         <description>
          <p>
The following notification type is supported:
          </p>
          <ul>
            <li>
STATUS - The posted status notification is displayed in status bar and the notification tray.
The status notification consists of icon, title, content, and time. The status notification can have application control to launch the specific application when selected by the user.            </li>
          </ul>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="STATUS">
        <webidl> &quot;STATUS</webidl>
      </EnumValue>
    </Enum>
    <Enum name="StatusNotificationType" id="::Notification::StatusNotificationType">
      <webidl>    enum StatusNotificationType { &quot;SIMPLE&quot;, &quot;THUMBNAIL&quot;, &quot;ONGOING&quot;, &quot;PROGRESS&quot; };</webidl>
      <descriptive>
          <brief>
 A status notification type.
          </brief>
         <description>
          <p>
The following status notification types are supported:
          </p>
          <ul>
            <li>
SIMPLE - A basic status notification type that is removed automatically when selected by the user. All simple status notifications can be removed by user interaction.            </li>
            <li>
THUMBNAIL - The thumbnail status notification posts a thumbnail-format notification which includes several thumbnail image paths.
The thumbnail status notification is also removed by a user selection.
            </li>
            <li>
ONGOING - A status notification type that informs the user about an application is running or not. However, an ongoing status notification should be removed by the application that posted the notification.            </li>
            <li>
PROGRESS - A status notification that displays the information on the progress of a job. However, this status notification should be removed by the application that posted the notification.            </li>
          </ul>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="SIMPLE">
        <webidl> &quot;SIMPLE</webidl>
      </EnumValue>
      <EnumValue stringvalue="THUMBNAIL">
        <webidl> &quot;THUMBNAIL</webidl>
      </EnumValue>
      <EnumValue stringvalue="ONGOING">
        <webidl> &quot;ONGOING</webidl>
      </EnumValue>
      <EnumValue stringvalue="PROGRESS">
        <webidl> &quot;PROGRESS</webidl>
      </EnumValue>
    </Enum>
    <Enum name="NotificationProgressType" id="::Notification::NotificationProgressType">
      <webidl>    enum NotificationProgressType { &quot;PERCENTAGE&quot;,  &quot;BYTE&quot; };</webidl>
      <descriptive>
          <brief>
 A notification progress type.
          </brief>
         <description>
          <p>
Supporting notification progress types are:
          </p>
          <ul>
            <li>
 &quot;BYTE&quot; - The progress is indicated in bytes.            </li>
            <li>
 &quot;PERCENTAGE&quot; -The progress is indicated in percentage.            </li>
          </ul>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="PERCENTAGE">
        <webidl> &quot;PERCENTAGE</webidl>
      </EnumValue>
      <EnumValue stringvalue="BYTE">
        <webidl>  &quot;BYTE</webidl>
      </EnumValue>
    </Enum>
    <Interface name="NotificationObject" id="::Notification::NotificationObject">
      <webidl>    [NoInterfaceObject] interface NotificationObject {
        readonly attribute <ref>NotificationManager</ref> notification;
    };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated by the <em>Tizen</em> object.
          </brief>
         <description>
          <p>
There is a <em>tizen.notification</em> object that allows access to the
Notification API.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="notification" id="::Notification::NotificationObject::notification">
        <webidl>        readonly attribute <ref>NotificationManager</ref> notification;</webidl>
        <Type name="NotificationManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="NotificationObject">
      <webidl>    <ref>Tizen</ref> implements <ref>NotificationObject</ref>;</webidl>
    </Implements>
    <Interface name="NotificationManager" id="::Notification::NotificationManager">
      <webidl>    [NoInterfaceObject] interface NotificationManager {

    void post(<ref>Notification</ref> notification) raises(<ref>WebAPIException</ref>);

    void update(<ref>Notification</ref> notification) raises(<ref>WebAPIException</ref>);

    void remove(<ref>NotificationId</ref> id) raises(<ref>WebAPIException</ref>);

    void removeAll() raises(<ref>WebAPIException</ref>);

    <ref>Notification</ref> get(<ref>NotificationId</ref> id) raises(<ref>WebAPIException</ref>);

    <ref>Notification</ref>[] getAll() raises(<ref>WebAPIException</ref>);

    };</webidl>
      <descriptive>
          <brief>
 Notification manager interface that provides access to the API.
          </brief>
         <description>
          <p>
This interface provides access to the notification object.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="post" id="::Notification::NotificationManager::post">
        <webidl>    void post(<ref>Notification</ref> notification) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Posts a notification to display.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/notification
            </privilege>
            <Code> try {
      var appControl = new tizen.ApplicationControl(
                       &quot;http://tizen.org/appcontrol/operation/create_content&quot;,
                       null,
                       &quot;image/jpg&quot;,
                       null);
      var notificationDict = {
                  content : &quot;This is a simple notification.&quot;,
                  iconPath : &quot;images/image1.jpg&quot;,
                  soundPath : &quot;music/Over the horizon.mp3&quot;,
                  vibration : true,
                  appControl : appControl};

      var notification = new tizen.StatusNotification(&quot;SIMPLE&quot;,
                  &quot;Simple notification&quot;, notificationDict);

      tizen.notification.post(notification);
 } catch (err) {
      console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="notification">
            <descriptive>
                <description><p>
 A notification to post.
                </p></description>
            </descriptive>
            <Type name="Notification"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="update" id="::Notification::NotificationManager::update">
        <webidl>    void update(<ref>Notification</ref> notification) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Updates a previously posted notification.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/notification
            </privilege>
            <Code> try {
      // Uses a variable for the previously posted notification.
      notification.content = &quot;My notification&quot;;
      tizen.notification.update(notification);
 } catch (err) {
      console.log (err.name + &quot;: &quot; + err.message);
 }

</Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="notification">
            <descriptive>
                <description><p>
 A notification to update.
                </p></description>
            </descriptive>
            <Type name="Notification"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="remove" id="::Notification::NotificationManager::remove">
        <webidl>    void remove(<ref>NotificationId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes a previously posted notification.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/notification
            </privilege>
            <Code> try {
      // Uses a variable for the previously posted notification.
      tizen.notification.remove(notification.id);
 } catch (err) {
      console.log (err.name + &quot;: &quot; + err.message);
 }

</Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 A previously posted notification ID to remove.
                </p></description>
            </descriptive>
            <Type name="NotificationId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any of the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type NotFoundError, if NotificationId is not found in the previously posted notifications.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeAll" id="::Notification::NotificationManager::removeAll">
        <webidl>    void removeAll() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes all notifications that have been posted by the current application.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/notification
            </privilege>
            <Code> try {
      tizen.notification.removeAll();
 } catch (err) {
      console.log (err.name + &quot;: &quot; + err.message);
 }

</Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="get" id="::Notification::NotificationManager::get">
        <webidl>    <ref>Notification</ref> get(<ref>NotificationId</ref> id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets a notification that has previously been posted by the current application. Note that the obtaining notification's progressType is <em>PERCENTAGE</em>            </brief>
            <version>
 2.0
            </version>
            <Code> try {
      // Uses a variable for the previously posted notification
      // Saves notification ID for future use
      var myId = notification.id;

      var myNotification = tizen.notification.get(myId);
 } catch (err) {
      console.log (err.name + &quot;: &quot; + err.message);
 }

</Code>
        </descriptive>
        <Type name="Notification"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 A previously posted notification ID.
                </p></description>
            </descriptive>
            <Type name="NotificationId"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotFoundError, if NotificationId is not found in the previously posted notifications.
                </p></description>
                <description><p>
 with error type UnknownError if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAll" id="::Notification::NotificationManager::getAll">
        <webidl>    <ref>Notification</ref>[] getAll() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets all notifications that have previously been posted by the current application. Note that the obtaining notification's progressType is <em>PERCENTAGE</em>            </brief>
            <version>
 2.0
            </version>
            <Code> try {
     var notifications = tizen.notification.getAll();
     var index = 0;

     for ( index = 0; notifications.length > index; index++ )
     {
         console.log(notifications[index].id);
         console.log(notifications[index].title);
         console.log(notifications[index].statusType);
         console.log(notifications[index].type);
         console.log(notifications[index].content);
         console.log(notifications[index].postedTime);
         console.log(notifications[index].iconPath);
         console.log(notifications[index].soundPath);
         console.log(notifications[index].vibration);
         console.log(notifications[index].appControl);
     }
 } catch (err) {
     console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="array">
          <Type name="Notification"/>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Notification" id="::Notification::Notification">
      <webidl>    [NoInterfaceObject] interface Notification {


    readonly attribute <ref>NotificationId</ref> id;

    readonly attribute <ref>NotificationType</ref> type;

    readonly attribute Date postedTime;

    attribute DOMString title;

    attribute DOMString? content;

    };</webidl>
      <descriptive>
          <brief>
 This interface offers common attributes to represent <em>Notification</em> object.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Notification::Notification::id">
        <webidl>    readonly attribute <ref>NotificationId</ref> id;</webidl>
        <descriptive>
            <brief>
 The Notification identifier. Before the notification is posted, this value is undefined.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="NotificationId"/>
      </Attribute>
      <Attribute readonly="readonly" name="type" id="::Notification::Notification::type">
        <webidl>    readonly attribute <ref>NotificationType</ref> type;</webidl>
        <descriptive>
            <brief>
 The Notification type.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="NotificationType"/>
      </Attribute>
      <Attribute readonly="readonly" name="postedTime" id="::Notification::Notification::postedTime">
        <webidl>    readonly attribute Date postedTime;</webidl>
        <descriptive>
            <brief>
 The time that the notification is posted. Before the notification is posted, this value is undefined.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
      <Attribute name="title" id="::Notification::Notification::title">
        <webidl>    attribute DOMString title;</webidl>
        <descriptive>
            <brief>
 The title to display in a notification.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="content" id="::Notification::Notification::content">
        <webidl>    attribute DOMString? content;</webidl>
        <descriptive>
            <brief>
 The content to display in a notification.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Dictionary name="StatusNotificationInit" id="::Notification::StatusNotificationInit">
      <webidl>    dictionary StatusNotificationInit {
        DOMString? content;
        DOMString? iconPath;
        DOMString? soundPath;
        boolean? vibration;
        <ref>ApplicationControl</ref>? appControl;
        <ref>ApplicationId</ref>? appId;
        <ref>NotificationProgressType</ref>? progressType;
        unsigned long? progressValue;
        long? number;
        DOMString? subIconPath;
        <ref>NotificationDetailInfo</ref>[]? detailInfo;
        DOMString? ledColor;
        unsigned long ledOnPeriod;
        unsigned long ledOffPeriod;
        DOMString? backgroundImagePath;
        DOMString[]? thumbnails;
    };</webidl>
      <descriptive>
          <brief>
 The properties of StatusNotification, to pass a constructor.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <DictionaryMember name="content" id="::Notification::StatusNotificationInit::content">
        <webidl>        DOMString? content;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="iconPath" id="::Notification::StatusNotificationInit::iconPath">
        <webidl>        DOMString? iconPath;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="soundPath" id="::Notification::StatusNotificationInit::soundPath">
        <webidl>        DOMString? soundPath;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="vibration" id="::Notification::StatusNotificationInit::vibration">
        <webidl>        boolean? vibration;</webidl>
        <Type type="boolean" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="appControl" id="::Notification::StatusNotificationInit::appControl">
        <webidl>        <ref>ApplicationControl</ref>? appControl;</webidl>
        <Type name="ApplicationControl" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="appId" id="::Notification::StatusNotificationInit::appId">
        <webidl>        <ref>ApplicationId</ref>? appId;</webidl>
        <Type name="ApplicationId" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="progressType" id="::Notification::StatusNotificationInit::progressType">
        <webidl>        <ref>NotificationProgressType</ref>? progressType;</webidl>
        <Type name="NotificationProgressType" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="progressValue" id="::Notification::StatusNotificationInit::progressValue">
        <webidl>        unsigned long? progressValue;</webidl>
        <Type type="unsigned long" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="number" id="::Notification::StatusNotificationInit::number">
        <webidl>        long? number;</webidl>
        <Type type="long" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="subIconPath" id="::Notification::StatusNotificationInit::subIconPath">
        <webidl>        DOMString? subIconPath;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="detailInfo" id="::Notification::StatusNotificationInit::detailInfo">
        <webidl>        <ref>NotificationDetailInfo</ref>[]? detailInfo;</webidl>
        <Type type="array" nullable="nullable">
          <Type name="NotificationDetailInfo"/>
        </Type>
      </DictionaryMember>
      <DictionaryMember name="ledColor" id="::Notification::StatusNotificationInit::ledColor">
        <webidl>        DOMString? ledColor;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="ledOnPeriod" id="::Notification::StatusNotificationInit::ledOnPeriod">
        <webidl>        unsigned long ledOnPeriod;</webidl>
        <Type type="unsigned long"/>
      </DictionaryMember>
      <DictionaryMember name="ledOffPeriod" id="::Notification::StatusNotificationInit::ledOffPeriod">
        <webidl>        unsigned long ledOffPeriod;</webidl>
        <Type type="unsigned long"/>
      </DictionaryMember>
      <DictionaryMember name="backgroundImagePath" id="::Notification::StatusNotificationInit::backgroundImagePath">
        <webidl>        DOMString? backgroundImagePath;</webidl>
        <Type type="DOMString" nullable="nullable"/>
      </DictionaryMember>
      <DictionaryMember name="thumbnails" id="::Notification::StatusNotificationInit::thumbnails">
        <webidl>        DOMString[]? thumbnails;</webidl>
        <Type type="array" nullable="nullable">
          <Type type="DOMString"/>
        </Type>
      </DictionaryMember>
    </Dictionary>
    <Interface name="StatusNotification" id="::Notification::StatusNotification">
      <webidl>   [Constructor(<ref>StatusNotificationType</ref> statusType, DOMString title, optional <ref>StatusNotificationInit</ref>? notificationInitDict)]


    interface StatusNotification : <ref>Notification</ref> {

    readonly attribute <ref>StatusNotificationType</ref> statusType;

    attribute DOMString? iconPath;

    attribute DOMString? subIconPath;

    attribute long? number;

    attribute <ref>NotificationDetailInfo</ref>[]? detailInfo;

    attribute DOMString? ledColor;

    attribute unsigned long ledOnPeriod;

    attribute unsigned long ledOffPeriod;

     attribute DOMString? backgroundImagePath;

     attribute DOMString[]? thumbnails;

     attribute DOMString? soundPath;

     attribute boolean vibration;

     attribute <ref>ApplicationControl</ref>? appControl;

     attribute <ref>ApplicationId</ref>? appId;

     attribute <ref>NotificationProgressType</ref> progressType;

     attribute unsigned long? progressValue;
    };</webidl>
      <descriptive>
          <brief>
 This interface represents status notification and offers additional attributes to represent notification displayed in notification tray.
          </brief>
         <description>
          <p>
All notification must have a title attribute.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(<ref>StatusNotificationType</ref> statusType, DOMString title, optional <ref>StatusNotificationInit</ref>? notificationInitDict)</webidl>
          <ArgumentList>
            <Argument name="statusType">
              <Type name="StatusNotificationType"/>
            </Argument>
            <Argument name="title">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="notificationInitDict">
              <Type name="StatusNotificationInit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="Notification"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="statusType" id="::Notification::StatusNotification::statusType">
        <webidl>    readonly attribute <ref>StatusNotificationType</ref> statusType;</webidl>
        <descriptive>
            <brief>
 The status notification type.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="StatusNotificationType"/>
      </Attribute>
      <Attribute name="iconPath" id="::Notification::StatusNotification::iconPath">
        <webidl>    attribute DOMString? iconPath;</webidl>
        <descriptive>
            <brief>
 The icon path to display in the notification.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="subIconPath" id="::Notification::StatusNotification::subIconPath">
        <webidl>    attribute DOMString? subIconPath;</webidl>
        <descriptive>
            <brief>
 The sub icon path to display in the notification.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="number" id="::Notification::StatusNotification::number">
        <webidl>    attribute long? number;</webidl>
        <descriptive>
            <brief>
 The number of events to display in the notification.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="long" nullable="nullable"/>
      </Attribute>
      <Attribute name="detailInfo" id="::Notification::StatusNotification::detailInfo">
        <webidl>    attribute <ref>NotificationDetailInfo</ref>[]? detailInfo;</webidl>
        <descriptive>
            <brief>
 Appends lines of the detail information to the notification.
This attribute is available in simple status notification.
By default, this attribute is initialized with an empty array.
The maximum number of detail information elements in the array is 2.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type name="NotificationDetailInfo"/>
        </Type>
      </Attribute>
      <Attribute name="ledColor" id="::Notification::StatusNotification::ledColor">
        <webidl>    attribute DOMString? ledColor;</webidl>
        <descriptive>
            <brief>
 Sets the notification LED indicator color property.
The color is a numerical RGB value(#rrggbb). The format of a RGB value in hexadecimal notation is a &quot;#&quot; immediately followed by exactly six hexadecimal characters(0-9, A-F). The color format is case-insensitive.
The LED indicator color will show its a close approximation.
LED will only light on when screen is off. To turn the LED off, set &quot;#000000&quot; or null to ledColor.
This method has effects when the device has notification LED.
            </brief>
            <Code> try {
      var notificationDict = {
                  content : &quot;This is a simple notification.&quot;,
                  iconPath : &quot;images/image1.jpg&quot;,
                  soundPath : &quot;music/Over the horizon.mp3&quot;,
                  vibration : true,
                  ledColor : &quot;#FFFF00&quot;,
                  ledOnPeriod: 1000,
                  ledOffPeriod : 500 };

      var notification = new tizen.StatusNotification(&quot;SIMPLE&quot;,
                  &quot;Simple notification&quot;, notificationDict);

      tizen.notification.post(notification);
 } catch (err) {
      console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="ledOnPeriod" id="::Notification::StatusNotification::ledOnPeriod">
        <webidl>    attribute unsigned long ledOnPeriod;</webidl>
        <descriptive>
            <brief>
 The milliseconds for which the light is on
The light continuously toggles on (ledOnPeriod) and off (ledOffPeriod).
By default, this attribute is set to 0
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute name="ledOffPeriod" id="::Notification::StatusNotification::ledOffPeriod">
        <webidl>    attribute unsigned long ledOffPeriod;</webidl>
        <descriptive>
            <brief>
 The milliseconds for which the light is off
By default, this attribute is set to 0
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute name="backgroundImagePath" id="::Notification::StatusNotification::backgroundImagePath">
        <webidl>     attribute DOMString? backgroundImagePath;</webidl>
        <descriptive>
            <brief>
 The image path to use as the background of the notification.
This attribute is available on simple or thumbnail status notifications.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="thumbnails" id="::Notification::StatusNotification::thumbnails">
        <webidl>     attribute DOMString[]? thumbnails;</webidl>
        <descriptive>
            <brief>
 The image paths associated with the thumbnail status notification.
By default, this attribute is initialized with an empty array.
The maximum number of thumbnail path elements in the array is 4.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="array" nullable="nullable">
          <Type type="DOMString"/>
        </Type>
      </Attribute>
      <Attribute name="soundPath" id="::Notification::StatusNotification::soundPath">
        <webidl>     attribute DOMString? soundPath;</webidl>
        <descriptive>
            <brief>
 The path of a sound file to play when the notification is shown.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
      <Attribute name="vibration" id="::Notification::StatusNotification::vibration">
        <webidl>     attribute boolean vibration;</webidl>
        <descriptive>
            <brief>
 Holds whether to vibrate when the notification is shown. By default, this attribute is set to false.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute name="appControl" id="::Notification::StatusNotification::appControl">
        <webidl>     attribute <ref>ApplicationControl</ref>? appControl;</webidl>
        <descriptive>
            <brief>
 Holds the application control to launch an application when the notification is selected from the notification tray.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="ApplicationControl" nullable="nullable"/>
      </Attribute>
      <Attribute name="appId" id="::Notification::StatusNotification::appId">
        <webidl>     attribute <ref>ApplicationId</ref>? appId;</webidl>
        <descriptive>
            <brief>
 Holds the application ID to launch when the notification is selected from the notification tray.
            </brief>
            <version>
 2.0
            </version>
            <Code> try {

      // Gets a current application information with tizen.application.getAppInfo
      var myappInfo = tizen.application.getAppInfo();

      var notificationDict = {
                  content : &quot;This is a simple notification.&quot;,
                  iconPath : &quot;images/image1.jpg&quot;,
                  soundPath : &quot;music/Over the horizon.mp3&quot;,
                  vibration : true,
                  appId : myappInfo.id };

      var notification = new tizen.StatusNotification(&quot;SIMPLE&quot;,
                  &quot;Simple notification&quot;, notificationDict);

      tizen.notification.post(notification);
 } catch (err) {
      console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type name="ApplicationId" nullable="nullable"/>
      </Attribute>
      <Attribute name="progressType" id="::Notification::StatusNotification::progressType">
        <webidl>     attribute <ref>NotificationProgressType</ref> progressType;</webidl>
        <descriptive>
            <brief>
 Defines the type for an ongoing notification's progress.
By default, this attribute is set to PERCENTAGE.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="NotificationProgressType"/>
      </Attribute>
      <Attribute name="progressValue" id="::Notification::StatusNotification::progressValue">
        <webidl>     attribute unsigned long? progressValue;</webidl>
        <descriptive>
            <brief>
 Defines the current notification progress value (<em>PERCENTAGE</em> or <em>BYTE</em>), depending on the <em>progressType</em>            </brief>
           <description>
            <p>
If progressValue is set, the progressbar will be displayed in notification. The progressValue can change the amount of progress as it moves forward or backward. Or gets a progress value of current notification
If 0, the indeterminate progressbar will be shown.
This attribute is only available for StatusNotifcation of type <em>PROGRESS</em>.
            </p>
            <p>
Application should keep the progress value for its job because
the saved value in the notification status tray would be different from
exact progress value.
            </p>
            <p>
Range of <em>progressValue</em>: percent (0 to 100).
            </p>
           </description>
            <Code> try {
      var appControl = new tizen.ApplicationControl(
      &quot;http://tizen.org/appcontrol/operation/create_content&quot;,
      null,
      &quot;image/jpg&quot;,
      null);

      var notificationDict = {
                  content : &quot;This is a progress notificaiton.&quot;,
                  iconPath : &quot;images/image2.jpg&quot;,
                  soundPath : &quot;music/Over the horizon.mp3&quot;,
                  vibration : true,
                  appControl : appControl,
                  progressValue : 20};
      // Constructs the progress notification
      var notification = new tizen.StatusNotification(&quot;PROGRESS&quot;,
                         &quot;Progress notification&quot;, notificationDict);
      // Posts the notification
      tizen.notification.post(notification);

      // Updates the progress value of the notification
      notification.progressValue = 59;
      tizen.notification.update(notification);


 } catch (err) {
     console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned long" nullable="nullable"/>
      </Attribute>
    </Interface>
    <Interface name="NotificationDetailInfo" id="::Notification::NotificationDetailInfo">
      <webidl>[Constructor(DOMString mainText, optional DOMString? subText)]
    interface NotificationDetailInfo {
    attribute DOMString mainText;

    attribute DOMString? subText;
    };</webidl>
      <descriptive>
          <brief>
 The NotificationDetailInfo object that contains the detail information to the notification.
          </brief>
          <version>
 2.1
          </version>
          <Code> var detailInfo1 = new tizen.NotificationDetailInfo('Missed Call from James', 'Feb 11 2013');
 notification.detailInfo = [detailInfo1];
</Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString mainText, optional DOMString? subText)</webidl>
          <ArgumentList>
            <Argument name="mainText">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="subText">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="mainText" id="::Notification::NotificationDetailInfo::mainText">
        <webidl>    attribute DOMString mainText;</webidl>
        <descriptive>
            <brief>
 The main content of the detail information.
This attribute is available on simple status notifications.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="subText" id="::Notification::NotificationDetailInfo::subText">
        <webidl>    attribute DOMString? subText;</webidl>
        <descriptive>
            <brief>
 The secondary content of the detail information.
            </brief>
           <description>
            <p>
By default, this attribute is set to null.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString" nullable="nullable"/>
      </Attribute>
    </Interface>
  </Module>
  <Module name="Package" id="::Package">
    <webidl>module Package {&#13;
&#13;
&#13;
    typedef DOMString PackageId;&#13;
&#13;
&#13;
    [NoInterfaceObject] interface PackageManagerObject {&#13;
        readonly attribute <ref>PackageManager</ref> package;&#13;
    };&#13;
    <ref>Tizen</ref> implements <ref>PackageManagerObject</ref>;&#13;
&#13;
&#13;
    [NoInterfaceObject] interface PackageManager {&#13;
&#13;
&#13;
        void install(DOMString path,&#13;
                     <ref>PackageProgressCallback</ref> progressCallback,&#13;
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        void uninstall(<ref>PackageId</ref> id, &#13;
                       <ref>PackageProgressCallback</ref> progressCallback,&#13;
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
&#13;
&#13;
        void getPackagesInfo(<ref>PackageInformationArraySuccessCallback</ref> successCallback,&#13;
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        <ref>PackageInformation</ref> getPackageInfo(optional <ref>PackageId</ref>? id) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        void setPackageInfoEventListener(<ref>PackageInformationEventCallback</ref> eventCallback) raises(<ref>WebAPIException</ref>);&#13;
        &#13;
&#13;
        void unsetPackageInfoEventListener() raises(<ref>WebAPIException</ref>);&#13;
    &#13;
    };&#13;
&#13;
&#13;
    [NoInterfaceObject] interface PackageInformation {&#13;
&#13;
        readonly attribute <ref>PackageId</ref> id;&#13;
&#13;
&#13;
        readonly attribute DOMString name;&#13;
&#13;
&#13;
        readonly attribute DOMString iconPath;&#13;
&#13;
&#13;
        readonly attribute DOMString version;&#13;
&#13;
&#13;
        readonly attribute long totalSize;&#13;
&#13;
&#13;
        readonly attribute long dataSize;&#13;
&#13;
&#13;
        readonly attribute Date lastModified;&#13;
&#13;
&#13;
        readonly attribute DOMString author;&#13;
&#13;
&#13;
        readonly attribute DOMString description;&#13;
&#13;
&#13;
        readonly attribute <ref>ApplicationId</ref>[] appIds;&#13;
&#13;
    };&#13;
&#13;
&#13;
    [Callback=FunctionOnly, NoInterfaceObject] interface PackageInformationArraySuccessCallback {&#13;
&#13;
&#13;
        void onsuccess(<ref>PackageInformation</ref>[] informationArray);&#13;
    };&#13;
&#13;
&#13;
    [Callback, NoInterfaceObject] interface PackageProgressCallback {&#13;
&#13;
&#13;
        void onprogress(<ref>PackageId</ref> id, short progress);&#13;
&#13;
&#13;
        void oncomplete(<ref>PackageId</ref> id);&#13;
    };&#13;
&#13;
&#13;
    [Callback, NoInterfaceObject] interface PackageInformationEventCallback {&#13;
&#13;
&#13;
        void oninstalled(<ref>PackageInformation</ref> info);&#13;
&#13;
&#13;
        void onupdated(<ref>PackageInformation</ref> info);&#13;
&#13;
&#13;
        void onuninstalled(<ref>PackageId</ref> id);&#13;
    };&#13;
&#13;
};</webidl>
    <descriptive>
        <brief>
 This API provides functionalities to install or uninstall packages, and retrieve information about installed packages.<br/>It also provides a listener method so that an application is able to be notified when there is a change on the installed packages.
For more information on the Package features, see <a href="../../org.tizen.web.appprogramming/html/guide/app_guide/package.htm">Package Guide</a>.
        </brief>
        <version>
 2.1
        </version>
    </descriptive>
    <Typedef name="PackageId" id="::Package::PackageId">
      <webidl>    typedef DOMString PackageId;</webidl>
      <descriptive>
          <brief>
 A unique ID for an installed package.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Interface name="PackageManagerObject" id="::Package::PackageManagerObject">
      <webidl>    [NoInterfaceObject] interface PackageManagerObject {&#13;
        readonly attribute <ref>PackageManager</ref> package;&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen </em>object from the Tizen Platform.
          </brief>
         <description>
          <p>
There is a <em>tizen.package </em>object that allows access to Package API functionality.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="package" id="::Package::PackageManagerObject::package">
        <webidl>        readonly attribute <ref>PackageManager</ref> package;</webidl>
        <Type name="PackageManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="PackageManagerObject">
      <webidl>    <ref>Tizen</ref> implements <ref>PackageManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="PackageManager" id="::Package::PackageManager">
      <webidl>    [NoInterfaceObject] interface PackageManager {&#13;
&#13;
&#13;
        void install(DOMString path,&#13;
                     <ref>PackageProgressCallback</ref> progressCallback,&#13;
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        void uninstall(<ref>PackageId</ref> id, &#13;
                       <ref>PackageProgressCallback</ref> progressCallback,&#13;
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
&#13;
&#13;
        void getPackagesInfo(<ref>PackageInformationArraySuccessCallback</ref> successCallback,&#13;
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        <ref>PackageInformation</ref> getPackageInfo(optional <ref>PackageId</ref>? id) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
        void setPackageInfoEventListener(<ref>PackageInformationEventCallback</ref> eventCallback) raises(<ref>WebAPIException</ref>);&#13;
        &#13;
&#13;
        void unsetPackageInfoEventListener() raises(<ref>WebAPIException</ref>);&#13;
    &#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines the package manager.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="install" id="::Package::PackageManager::install">
        <webidl>        void install(DOMString path,&#13;
                     <ref>PackageProgressCallback</ref> progressCallback,&#13;
                     optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Installs a package with a specified package path on a device.
            </brief>
           <description>
            <p>
This API provides a way to notify the progress and completion of an installation request through PackageProgressCallback.
            </p>
            <p>
The <em>ErrorCallback() </em>is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If the package is not found in the specified path.              </li>
              <li>
UnknownError - If it is not allowed to install the package by platform or any other platform error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 platform
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/packagemanager.install
            </privilege>
            <remark>
 Virtual path cannot be used for the parameter. First, you need to convert any virtual path to a file URI path using the resolve function in the Filesystem API before passing it to the function.
            </remark>
            <Code> var onInstallation = {
      onprogress: function(packageId, percentage) {
         console.log(&quot;On installation(&quot; + packageId + &quot;) : progress(&quot; + percentage + &quot;)&quot;);
      },
      oncomplete: function(packageId) {
         console.log(&quot;Installation(&quot; + packageId + &quot;) Complete&quot;);
      }
 }

 var onError = function (err) {
      console.log(&quot;Error occurred on installation : &quot; + err.name);
 }

 // Let's assume that &quot;test.wgt&quot; file is exist in the downloads directory
 tizen.filesystem.resolve(&quot;downloads/test.wgt&quot;,
     function (file) {
         console.log(&quot;file path : &quot; + file.path);
         tizen.package.install(file.toURI(), onInstallation, onError);
     },
     function (err) {
         console.log(&quot;Error occurred on resolve : &quot; + err.name);
     },
     &quot;r&quot;);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="path">
            <descriptive>
                <description><p>
 The package path to install
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="progressCallback">
            <descriptive>
                <description><p>
 The method to invoke when the installation is in progress or has been completed
                </p></description>
            </descriptive>
            <Type name="PackageProgressCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="uninstall" id="::Package::PackageManager::uninstall">
        <webidl>        void uninstall(<ref>PackageId</ref> id, &#13;
                       <ref>PackageProgressCallback</ref> progressCallback,&#13;
                       optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Uninstalls the package with a specified package ID.
            </brief>
           <description>
            <p>
This API provides a way to notify about the progress and completion of an uninstallation request through PackageProgressCallback.
            </p>
            <p>
The <em>ErrorCallback() </em>is launched with these error types:
            </p>
            <ul>
              <li>
NotFoundError - If the package is not found with specified ID.              </li>
              <li>
UnknownError - If it is not allowed to uninstall the package from the platform or any other platform error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 platform
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/packagemanager.install
            </privilege>
            <remark>
 Some preloaded packages cannot be uninstalled. In this case, ErrorCallback with UnKnownError type will be launched.
            </remark>
            <Code> var onUninstallation = {
      onprogress: function(packageId, percentage) {
         console.log(&quot;On Uninstallation(&quot; + packageId + &quot;) : progress(&quot; + percentage + &quot;)&quot;);
      },
      oncomplete: function(packageId) {
         console.log(&quot;Uninstallation(&quot; + packageId + &quot;) Complete&quot;);
      }
 };

 var onError = function (err) {
      console.log(&quot;Error occurred on installation : &quot; + err.name);
 };

 // Let's assume that the package id to uninstall is &quot;testapp001&quot;
 tizen.package.uninstall(&quot;testapp001&quot;, onUninstallation, onError);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The package ID to uninstall
                </p></description>
            </descriptive>
            <Type name="PackageId"/>
          </Argument>
          <Argument name="progressCallback">
            <descriptive>
                <description><p>
 The method to invoke when uninstallation is in progress or has been completed
                </p></description>
            </descriptive>
            <Type name="PackageProgressCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to invoke when an error occurs
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if an input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getPackagesInfo" id="::Package::PackageManager::getPackagesInfo">
        <webidl>        void getPackagesInfo(<ref>PackageInformationArraySuccessCallback</ref> successCallback,&#13;
                             optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets information of the installed packages.
            </brief>
           <description>
            <p>
The result contains the snapshots of the installed packages information.
            </p>
            <p>
The <em>errorCallback()</em> is launched with this error type:
            </p>
            <ul>
              <li>
UnknownError - If any other platform error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/package.info
            </privilege>
            <Code> function onListInstalledPackages(packages) {
     for (var i = 0; i &#60; packages.length; i++) {
         console.log(&quot;Package id[&quot;+i+&quot;] : &quot; +packages[i].id);
     }
 }

 tizen.package.getPackagesInfo(
     onListInstalledPackages,
     function (err) {console.log(&quot;Can't obtain packages list&quot; + err.name);});
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to call when an invocation ends successfully
                </p></description>
            </descriptive>
            <Type name="PackageInformationArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if an input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getPackageInfo" id="::Package::PackageManager::getPackageInfo">
        <webidl>        <ref>PackageInformation</ref> getPackageInfo(optional <ref>PackageId</ref>? id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets information of an installed package.
            </brief>
           <description>
            <p>
If the ID is set to <var>null</var> or not set at all, it returns package information of the current application.
The list of installed packages and their package IDs is obtained using <em>getPackagesInfo()</em>.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/package.info
            </privilege>
            <Code> var packageInfo = tizen.package.getPackageInfo(null);

 console.log(&quot;Current Package ID : &quot; + packageInfo.id);
 </Code>
        </descriptive>
        <Type name="PackageInformation">
          <descriptive>
              <description><p>
 PackageInformation The information of a package
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="id">
            <descriptive>
                <description><p>
 A string representing package ID. If the ID is not provided, the package information of the calling application is returned.
                </p></description>
            </descriptive>
            <Type name="PackageId" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if an input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotFoundError, if the package with the specified ID is not found.
                </p></description>
                <description><p>
 with error type UnknownError, if the package information cannot be retrieved because of a platform error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setPackageInfoEventListener" id="::Package::PackageManager::setPackageInfoEventListener">
        <webidl>        void setPackageInfoEventListener(<ref>PackageInformationEventCallback</ref> eventCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets a listener to receive notifications for any changes made to the list of installed packages.
            </brief>
           <description>
            <p>
This method sets a <em>PackageInformationEventCallback</em> type callback that is triggered when a package is installed, removed or updated.
            </p>
            <p>
The callback lasts until <em>unsetPackageInfoEventListener()</em> method is called.
            </p>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/package.info
            </privilege>
            <Code> var packageEventCallback = {
    oninstalled: function(packageInfo) {
       console.log('The package ' + packageInfo.name + ' is installed');
    },
    onupdated: function(packageInfo) {
       console.log('The package ' + packageInfo.name + ' is updated');
    },
    onuninstalled: function(packageId) {
       console.log('The package ' + packageId + ' is uninstalled');
    }
 };

 tizen.package.setPackageInfoEventListener(packageEventCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="eventCallback">
            <descriptive>
                <description><p>
 The method to be called when any change is made to the list of installed packages.
                </p></description>
            </descriptive>
            <Type name="PackageInformationEventCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if an input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if the package list change event cannot be generated because of a platform error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unsetPackageInfoEventListener" id="::Package::PackageManager::unsetPackageInfoEventListener">
        <webidl>        void unsetPackageInfoEventListener() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsets the listener to stop receiving package notifications.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/package.info
            </privilege>
            <Code> tizen.package.unsetPackageInfoEventListener();
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if the listener removal request fails because of a platform error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="PackageInformation" id="::Package::PackageInformation">
      <webidl>    [NoInterfaceObject] interface PackageInformation {&#13;
&#13;
        readonly attribute <ref>PackageId</ref> id;&#13;
&#13;
&#13;
        readonly attribute DOMString name;&#13;
&#13;
&#13;
        readonly attribute DOMString iconPath;&#13;
&#13;
&#13;
        readonly attribute DOMString version;&#13;
&#13;
&#13;
        readonly attribute long totalSize;&#13;
&#13;
&#13;
        readonly attribute long dataSize;&#13;
&#13;
&#13;
        readonly attribute Date lastModified;&#13;
&#13;
&#13;
        readonly attribute DOMString author;&#13;
&#13;
&#13;
        readonly attribute DOMString description;&#13;
&#13;
&#13;
        readonly attribute <ref>ApplicationId</ref>[] appIds;&#13;
&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines the general information available to an installed package.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="id" id="::Package::PackageInformation::id">
        <webidl>        readonly attribute <ref>PackageId</ref> id;</webidl>
        <descriptive>
            <brief>
 An attribute to store the identifier of a package.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type name="PackageId"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Package::PackageInformation::name">
        <webidl>        readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 An attribute to store the package name.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="iconPath" id="::Package::PackageInformation::iconPath">
        <webidl>        readonly attribute DOMString iconPath;</webidl>
        <descriptive>
            <brief>
 An attribute to store the icon path of a package.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="version" id="::Package::PackageInformation::version">
        <webidl>        readonly attribute DOMString version;</webidl>
        <descriptive>
            <brief>
 An attribute to store the package version.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="totalSize" id="::Package::PackageInformation::totalSize">
        <webidl>        readonly attribute long totalSize;</webidl>
        <descriptive>
            <brief>
 An attribute to store the total installed size(package + data) of a package.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="dataSize" id="::Package::PackageInformation::dataSize">
        <webidl>        readonly attribute long dataSize;</webidl>
        <descriptive>
            <brief>
 An attribute to store the current data size of a package.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="long"/>
      </Attribute>
      <Attribute readonly="readonly" name="lastModified" id="::Package::PackageInformation::lastModified">
        <webidl>        readonly attribute Date lastModified;</webidl>
        <descriptive>
            <brief>
 An attribute to store the latest installed or updated time of a package.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
      <Attribute readonly="readonly" name="author" id="::Package::PackageInformation::author">
        <webidl>        readonly attribute DOMString author;</webidl>
        <descriptive>
            <brief>
 An attribute to store the author of a package.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="description" id="::Package::PackageInformation::description">
        <webidl>        readonly attribute DOMString description;</webidl>
        <descriptive>
            <brief>
 An attribute to store the package description.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="appIds" id="::Package::PackageInformation::appIds">
        <webidl>        readonly attribute <ref>ApplicationId</ref>[] appIds;</webidl>
        <descriptive>
            <brief>
 An attribute to store the application ID list of a package.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="array">
          <Type name="ApplicationId"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="PackageInformationArraySuccessCallback" id="::Package::PackageInformationArraySuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject] interface PackageInformationArraySuccessCallback {&#13;
&#13;
&#13;
        void onsuccess(<ref>PackageInformation</ref>[] informationArray);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface invokes the success callback with an array of <em>PackageInformation </em>objects as an input parameter when the installed package list is retrieved.
          </brief>
         <description>
          <p>
It is used in <em>tizen.package.getPackagesInfo()</em>.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Package::PackageInformationArraySuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>PackageInformation</ref>[] informationArray);</webidl>
        <descriptive>
            <brief>
 Called when the asynchronous call completes successfully.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="informationArray">
            <descriptive>
                <description><p>
 A list of installed packages information.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="PackageInformation"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="PackageProgressCallback" id="::Package::PackageProgressCallback">
      <webidl>    [Callback, NoInterfaceObject] interface PackageProgressCallback {&#13;
&#13;
&#13;
        void onprogress(<ref>PackageId</ref> id, short progress);&#13;
&#13;
&#13;
        void oncomplete(<ref>PackageId</ref> id);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This callback interface specifies subscriptions for any notification on the progress or completion of requests.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onprogress" id="::Package::PackageProgressCallback::onprogress">
        <webidl>        void onprogress(<ref>PackageId</ref> id, short progress);</webidl>
        <descriptive>
            <brief>
 Called while the request is in progress.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The package ID
                </p></description>
            </descriptive>
            <Type name="PackageId"/>
          </Argument>
          <Argument name="progress">
            <descriptive>
                <description><p>
 The progress in percentage.
                </p></description>
            </descriptive>
            <Type type="short"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="oncomplete" id="::Package::PackageProgressCallback::oncomplete">
        <webidl>        void oncomplete(<ref>PackageId</ref> id);</webidl>
        <descriptive>
            <brief>
 Called while the request is completed.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The package ID
                </p></description>
            </descriptive>
            <Type name="PackageId"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="PackageInformationEventCallback" id="::Package::PackageInformationEventCallback">
      <webidl>    [Callback, NoInterfaceObject] interface PackageInformationEventCallback {&#13;
&#13;
&#13;
        void oninstalled(<ref>PackageInformation</ref> info);&#13;
&#13;
&#13;
        void onupdated(<ref>PackageInformation</ref> info);&#13;
&#13;
&#13;
        void onuninstalled(<ref>PackageId</ref> id);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This callback interface specifies methods that are invoked when a package is installed, updated, or uninstalled.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="oninstalled" id="::Package::PackageInformationEventCallback::oninstalled">
        <webidl>        void oninstalled(<ref>PackageInformation</ref> info);</webidl>
        <descriptive>
            <brief>
 Called when a package is installed.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="info">
            <descriptive>
                <description><p>
 The information of the installed package
                </p></description>
            </descriptive>
            <Type name="PackageInformation"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onupdated" id="::Package::PackageInformationEventCallback::onupdated">
        <webidl>        void onupdated(<ref>PackageInformation</ref> info);</webidl>
        <descriptive>
            <brief>
 Called when a package is updated.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="info">
            <descriptive>
                <description><p>
 The information of the updated package
                </p></description>
            </descriptive>
            <Type name="PackageInformation"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onuninstalled" id="::Package::PackageInformationEventCallback::onuninstalled">
        <webidl>        void onuninstalled(<ref>PackageId</ref> id);</webidl>
        <descriptive>
            <brief>
 Called when a package is uninstalled.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The ID of the uninstalled package
                </p></description>
            </descriptive>
            <Type name="PackageId"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Power" id="::Power">
    <webidl>module Power {

    enum PowerResource    { &quot;SCREEN&quot;, &quot;CPU&quot; };

    enum PowerScreenState { &quot;SCREEN_OFF&quot;, &quot;SCREEN_DIM&quot;, &quot;SCREEN_NORMAL&quot;, &quot;SCREEN_BRIGHT&quot; };

    enum PowerCpuState { &quot;CPU_AWAKE&quot; };

    typedef (<ref>PowerScreenState</ref> or <ref>PowerCpuState</ref>) PowerState;

    [NoInterfaceObject] interface PowerManagerObject {
        readonly attribute <ref>PowerManager</ref> power;
    };
    <ref>Tizen</ref> implements <ref>PowerManagerObject</ref>;

   [NoInterfaceObject] interface PowerManager {
       void request(<ref>PowerResource</ref> resource, <ref>PowerState</ref> state) raises(<ref>WebAPIException</ref>);

       void release(<ref>PowerResource</ref> resource) raises(<ref>WebAPIException</ref>);

       void setScreenStateChangeListener(<ref>ScreenStateChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);

       void unsetScreenStateChangeListener() raises(<ref>WebAPIException</ref>);

       double getScreenBrightness() raises(<ref>WebAPIException</ref>);

       void setScreenBrightness(double brightness) raises(<ref>WebAPIException</ref>);

       boolean isScreenOn() raises(<ref>WebAPIException</ref>);

       void restoreScreenBrightness() raises(<ref>WebAPIException</ref>);

       void turnScreenOn() raises(<ref>WebAPIException</ref>);

       void turnScreenOff() raises(<ref>WebAPIException</ref>);
   };

   [Callback=FunctionOnly, NoInterfaceObject] interface ScreenStateChangeCallback {
       void onchanged(<ref>PowerScreenState</ref> previousState, <ref>PowerScreenState</ref> changedState);
   };

};</webidl>
    <descriptive>
        <brief>
 This API provides support for requesting power management related resource states.
        </brief>
       <description>
        <p>
For more information on the Power features, see <a href="../../org.tizen.web.appprogramming/html/guide/sys_guide/power.htm">Power Guide</a>.
        </p>
       </description>
        <version>
 2.0
        </version>
    </descriptive>
    <Enum name="PowerResource" id="::Power::PowerResource">
      <webidl>    enum PowerResource    { &quot;SCREEN&quot;, &quot;CPU&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that defines power resources with values aligned with <em>SystemInfo </em>property values.
          </brief>
         <description>
          <p>
We support screen and cpu resources for now.
Supported power resource states are provided in PowerScreenState and PowerCpuState enums respectively prefixed by the corresponding resource type.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="SCREEN">
        <webidl> &quot;SCREEN</webidl>
      </EnumValue>
      <EnumValue stringvalue="CPU">
        <webidl> &quot;CPU</webidl>
      </EnumValue>
    </Enum>
    <Enum name="PowerScreenState" id="::Power::PowerScreenState">
      <webidl>    enum PowerScreenState { &quot;SCREEN_OFF&quot;, &quot;SCREEN_DIM&quot;, &quot;SCREEN_NORMAL&quot;, &quot;SCREEN_BRIGHT&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the power state for screen resource.
          </brief>
         <description>
          <p>
The supported values are:
          </p>
          <ul>
            <li>
SCREEN_OFF - This screen state cannot be requested but can only be used in the state change callback.            </li>
            <li>
SCREEN_DIM - The minimal screen state is set to <em>DIM</em> and device does not change to <em>OFF</em> state automatically.            </li>
            <li>
SCREEN_NORMAL - The minimal screen state is set to <em>NORMAL</em> and device does not change to <em>DIM</em> state automatically.            </li>
            <li>
SCREEN_BRIGHT (Deprecated) - The minimal screen state is set to <em>BRIGHT</em> and device does not change to <em>NORMAL</em> state automatically.            </li>
          </ul>
          <p>
<em>DIM</em> state refers to the screen that the backlight is turned off
<em>NORMAL</em> state refers to the default screen brightness that a user has configured for the device.
<em>BRIGHT(Deprecated)</em> state refers to the maximum screen brightness that the device provides.
Note that the change in brightness does not affect the system brightness setting, i.e., the system brightness value is automatically restored when the resource is released or the process is completed.
          </p>
         </description>
          <deprecated>
 SCREEN_BRIGHT is deprecated.
          </deprecated>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="SCREEN_OFF">
        <webidl> &quot;SCREEN_OFF</webidl>
      </EnumValue>
      <EnumValue stringvalue="SCREEN_DIM">
        <webidl> &quot;SCREEN_DIM</webidl>
      </EnumValue>
      <EnumValue stringvalue="SCREEN_NORMAL">
        <webidl> &quot;SCREEN_NORMAL</webidl>
      </EnumValue>
      <EnumValue stringvalue="SCREEN_BRIGHT">
        <webidl> &quot;SCREEN_BRIGHT</webidl>
      </EnumValue>
    </Enum>
    <Enum name="PowerCpuState" id="::Power::PowerCpuState">
      <webidl>    enum PowerCpuState { &quot;CPU_AWAKE&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the power state for cpu resource.
          </brief>
         <description>
          <p>
The supported values are:
          </p>
          <ul>
            <li>
CPU_AWAKE - The cpu state is set to be awaken and it does not go to <em>SLEEP</em> state automatically.            </li>
          </ul>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="CPU_AWAKE">
        <webidl> &quot;CPU_AWAKE</webidl>
      </EnumValue>
    </Enum>
    <Typedef name="PowerState" id="::Power::PowerState">
      <webidl>    typedef (<ref>PowerScreenState</ref> or <ref>PowerCpuState</ref>) PowerState;</webidl>
      <descriptive>
          <brief>
 The supported power states in general.
It can be either a PowerScreenState or a PowerCpuState.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <Type type="union">
        <Type name="PowerScreenState"/>
        <Type name="PowerCpuState"/>
      </Type>
    </Typedef>
    <Interface name="PowerManagerObject" id="::Power::PowerManagerObject">
      <webidl>    [NoInterfaceObject] interface PowerManagerObject {
        readonly attribute <ref>PowerManager</ref> power;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen</em> object from the Tizen Platform.
          </brief>
         <description>
          <p>
There will be a <em>tizen.power </em>object that allows accessing of a functionality of the Power API.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="power" id="::Power::PowerManagerObject::power">
        <webidl>        readonly attribute <ref>PowerManager</ref> power;</webidl>
        <Type name="PowerManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="PowerManagerObject">
      <webidl>    <ref>Tizen</ref> implements <ref>PowerManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="PowerManager" id="::Power::PowerManager">
      <webidl>   [NoInterfaceObject] interface PowerManager {
       void request(<ref>PowerResource</ref> resource, <ref>PowerState</ref> state) raises(<ref>WebAPIException</ref>);

       void release(<ref>PowerResource</ref> resource) raises(<ref>WebAPIException</ref>);

       void setScreenStateChangeListener(<ref>ScreenStateChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);

       void unsetScreenStateChangeListener() raises(<ref>WebAPIException</ref>);

       double getScreenBrightness() raises(<ref>WebAPIException</ref>);

       void setScreenBrightness(double brightness) raises(<ref>WebAPIException</ref>);

       boolean isScreenOn() raises(<ref>WebAPIException</ref>);

       void restoreScreenBrightness() raises(<ref>WebAPIException</ref>);

       void turnScreenOn() raises(<ref>WebAPIException</ref>);

       void turnScreenOff() raises(<ref>WebAPIException</ref>);
   };</webidl>
      <descriptive>
          <brief>
 This interface is used to request resource states, however, these requests can be overridden by the system. If the requests are overridden, the application is notified with the provided listener callback.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="request" id="::Power::PowerManager::request">
        <webidl>       void request(<ref>PowerResource</ref> resource, <ref>PowerState</ref> state) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Requests the minimum-state for a power resource.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/power
            </privilege>
            <Code> tizen.power.request(&quot;SCREEN&quot;, &quot;SCREEN_NORMAL&quot;);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="resource">
            <descriptive>
                <description><p>
 The power resource for which the request is made.
                </p></description>
            </descriptive>
            <Type name="PowerResource"/>
          </Argument>
          <Argument name="state">
            <descriptive>
                <description><p>
 The minimal power state in which the power resource is desired to be.
                </p></description>
            </descriptive>
            <Type name="PowerState"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not
compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="release" id="::Power::PowerManager::release">
        <webidl>       void release(<ref>PowerResource</ref> resource) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Releases the power state request for the given resource.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Release SCREEN resource.
 tizen.power.release(&quot;SCREEN&quot;);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="resource">
            <descriptive>
                <description><p>
 The resource for which requests are to be removed.
                </p></description>
            </descriptive>
            <Type name="PowerResource"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not
compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setScreenStateChangeListener" id="::Power::PowerManager::setScreenStateChangeListener">
        <webidl>       void setScreenStateChangeListener(<ref>ScreenStateChangeCallback</ref> listener) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the screen state change callback and monitors its state changes.
            </brief>
            <version>
 2.0
            </version>
            <Code> function onScreenStateChanged(previousState, changedState) {
   console.log(&quot;Screen state changed from &quot; + previousState + &quot; to &quot; + changedState);
 }

 // Set the screen state change listener.
 tizen.power.setScreenStateChangeListener(onScreenStateChanged);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="listener">
            <descriptive>
                <description><p>
 The screen state change callback.
                </p></description>
            </descriptive>
            <Type name="ScreenStateChangeCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not
compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unsetScreenStateChangeListener" id="::Power::PowerManager::unsetScreenStateChangeListener">
        <webidl>       void unsetScreenStateChangeListener() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsets the screen state change callback and stop monitoring it.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Unset the screen state change listener.
 tizen.power.unsetScreenStateChangeListener();
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getScreenBrightness" id="::Power::PowerManager::getScreenBrightness">
        <webidl>       double getScreenBrightness() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the screen brightness level of an application, from 0 to 1.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Get the current screen brightness value.
 var screenBrightness = tizen.power.getScreenBrightness();
 </Code>
        </descriptive>
        <Type type="double">
          <descriptive>
              <description><p>
 double Current screen brightness value.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="setScreenBrightness" id="::Power::PowerManager::setScreenBrightness">
        <webidl>       void setScreenBrightness(double brightness) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the screen brightness level for an application, from 0 to 1.
            </brief>
           <description>
            <p>
An approximation is made for best effort when the given value is not exactly applicable by the hardware or system.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/power
            </privilege>
            <Code> // Set the screen brightness value for the application.
 tizen.power.setScreenBrightness(1);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="brightness">
            <descriptive>
                <description><p>
 The screen brightness value to set.
                </p></description>
            </descriptive>
            <Type type="double"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not
compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="isScreenOn" id="::Power::PowerManager::isScreenOn">
        <webidl>       boolean isScreenOn() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns <var>true</var> if the screen is on.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Check whether the screen is on or off.
 var isScreenOn = tizen.power.isScreenOn();
 </Code>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean true if screen is on.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="restoreScreenBrightness" id="::Power::PowerManager::restoreScreenBrightness">
        <webidl>       void restoreScreenBrightness() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Restores the screen brightness to the system default setting value.
            </brief>
            <version>
 2.0
            </version>
            <Code> // Restore the screen brightness value to the system default setting value.
 tizen.power.restoreScreenBrightness();
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="turnScreenOn" id="::Power::PowerManager::turnScreenOn">
        <webidl>       void turnScreenOn() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Turns on the screen.
            </brief>
           <description>
            <p>
This API triggers turn-on process and then updates the status when it completes. While the operation is on-going, the isScreenOn() method returns false.
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/power
            </privilege>
            <Code> // Turn on the screen.
 tizen.power.turnScreenOn();
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="turnScreenOff" id="::Power::PowerManager::turnScreenOff">
        <webidl>       void turnScreenOff() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Turns off the screen.
            </brief>
           <description>
            <p>
This API triggers turn-off process and then updates the status when it completes. While the operation is on-going, the isScreenOn() method returns true
            </p>
           </description>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/power
            </privilege>
            <Code> // Turn off the screen.
 tizen.power.turnScreenOff();
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="ScreenStateChangeCallback" id="::Power::ScreenStateChangeCallback">
      <webidl>   [Callback=FunctionOnly, NoInterfaceObject] interface ScreenStateChangeCallback {
       void onchanged(<ref>PowerScreenState</ref> previousState, <ref>PowerScreenState</ref> changedState);
   };</webidl>
      <descriptive>
          <brief>
 This callback interface defines notification for the screen state changes.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onchanged" id="::Power::ScreenStateChangeCallback::onchanged">
        <webidl>       void onchanged(<ref>PowerScreenState</ref> previousState, <ref>PowerScreenState</ref> changedState);</webidl>
        <descriptive>
            <brief>
 Called on screen state change.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="previousState">
            <descriptive>
                <description><p>
 The previous screen state.
                </p></description>
            </descriptive>
            <Type name="PowerScreenState"/>
          </Argument>
          <Argument name="changedState">
            <descriptive>
                <description><p>
 The changed screen state.
                </p></description>
            </descriptive>
            <Type name="PowerScreenState"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Push" id="::Push">
    <webidl>module Push {&#13;
&#13;
    typedef DOMString PushRegistrationId;&#13;
&#13;
&#13;
    [NoInterfaceObject] interface PushManagerObject {&#13;
        readonly attribute <ref>PushManager</ref> push;&#13;
    };&#13;
    <ref>Tizen</ref> implements <ref>PushManagerObject</ref>;&#13;
&#13;
&#13;
    [NoInterfaceObject] interface PushManager {&#13;
&#13;
      void registerService(<ref>ApplicationControl</ref> appControl, <ref>PushRegisterSuccessCallback</ref> successCallback,&#13;
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
      void unregisterService(optional <ref>SuccessCallback</ref>? successCallback,&#13;
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
      void connectService(<ref>PushNotificationCallback</ref> notificationCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
      void disconnectService() raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
      <ref>PushRegistrationId</ref> getRegistrationId() raises(<ref>WebAPIException</ref>);&#13;
    };&#13;
&#13;
&#13;
    [NoInterfaceObject] interface PushMessage {&#13;
&#13;
        readonly attribute DOMString appData;&#13;
&#13;
&#13;
        readonly attribute DOMString alertMessage;&#13;
&#13;
&#13;
        readonly attribute Date date;&#13;
    };&#13;
&#13;
&#13;
    [Callback=FunctionOnly, NoInterfaceObject]&#13;
    interface PushRegisterSuccessCallback {&#13;
&#13;
        void onsuccess(<ref>PushRegistrationId</ref> id);&#13;
    };&#13;
&#13;
&#13;
    [Callback=FunctionOnly, NoInterfaceObject]&#13;
    interface PushNotificationCallback {&#13;
&#13;
        void onsuccess(<ref>PushMessage</ref> message);&#13;
    };&#13;
};</webidl>
    <descriptive>
        <brief>
 This API provides the functionality for receiving push notifications
from Tizen push server.
The push service is a client daemon that maintains a permanent connection
between your device and Tizen push server in order to process your registration
and deregistration requests, deliver push notifications to applications on a device.
        </brief>
       <description>
        <p>
If the application is connected, the push service passes the notification data over
the connection. Otherwise, the push service posts UI notification with the data.
It will be delivered when a user launches the application by selecting the posting.
        </p>
        <p>
To receive push notifications, follow the steps below:
        </p>
        <ul>
          <li>
Get administrative permission for an application on your device          </li>
          <li>
Register the application          </li>
          <li>
Connect to the push service          </li>
          <li>
Get notification data          </li>
        </ul>
        <p>
For more information on the Push features, see <a href="../../org.tizen.web.appprogramming/html/guide/communication_guide/push.htm">Push Guide</a>.
        </p>
       </description>
        <version>
 2.1
        </version>
        <def-api-feature identifier="http://tizen.org/feature/network.push">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with Push feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
    </descriptive>
    <Typedef name="PushRegistrationId" id="::Push::PushRegistrationId">
      <webidl>    typedef DOMString PushRegistrationId;</webidl>
      <descriptive>
          <brief>
 A push service registration identifier.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <Type type="DOMString"/>
    </Typedef>
    <Interface name="PushManagerObject" id="::Push::PushManagerObject">
      <webidl>    [NoInterfaceObject] interface PushManagerObject {&#13;
        readonly attribute <ref>PushManager</ref> push;&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen </em>object from the Tizen Platform.
          </brief>
         <description>
          <p>
There will be a <em>tizen.push </em>object that allows access to the functionality of the Push API.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="push" id="::Push::PushManagerObject::push">
        <webidl>        readonly attribute <ref>PushManager</ref> push;</webidl>
        <Type name="PushManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="PushManagerObject">
      <webidl>    <ref>Tizen</ref> implements <ref>PushManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="PushManager" id="::Push::PushManager">
      <webidl>    [NoInterfaceObject] interface PushManager {&#13;
&#13;
      void registerService(<ref>ApplicationControl</ref> appControl, <ref>PushRegisterSuccessCallback</ref> successCallback,&#13;
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
      void unregisterService(optional <ref>SuccessCallback</ref>? successCallback,&#13;
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
      void connectService(<ref>PushNotificationCallback</ref> notificationCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
      void disconnectService() raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
      <ref>PushRegistrationId</ref> getRegistrationId() raises(<ref>WebAPIException</ref>);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface provides methods to manage push registration and notification.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="registerService" id="::Push::PushManager::registerService">
        <webidl>      void registerService(<ref>ApplicationControl</ref> appControl, <ref>PushRegisterSuccessCallback</ref> successCallback,&#13;
                  optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Registers an application to the Tizen push server.
            </brief>
            <remark>
 In order to use the push messaging service, see <a href="../../org.tizen.native.appprogramming/html/guide/messaging/push_messaging.htm">Push Messaging Guide</a>.
            </remark>
           <description>
            <p>
The <em>ErrorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/push
            </privilege>
            <Code> // Defines the data to be used when this process is launched by notification service.
 var service = new tizen.ApplicationControl(&quot;http://tizen.org/appcontrol/operation/push_test&quot;);

 // Defines the error callback.
 function errorCallback(response) {
   console.log( 'The following error occurred: ' +  response.name);
 }

 // Defines the registration success callback
 function registerSuccessCallback(id) {
   console.log(&quot;Registration succeeded with id: &quot; + id);
 }

 // Requests registration.
 tizen.push.registerService(service, registerSuccessCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="appControl">
            <descriptive>
                <description><p>
 The data to deliver via notification service when the process is not running.<br/> For more information, see <a href="../../org.tizen.web.device.apireference/tizen/application.html">Application API</a>.
                </p></description>
            </descriptive>
            <Type name="ApplicationControl"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to be called when the registration request succeeds.
                </p></description>
            </descriptive>
            <Type name="PushRegisterSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be called when the registration request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameters
does not contain a valid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unregisterService" id="::Push::PushManager::unregisterService">
        <webidl>      void unregisterService(optional <ref>SuccessCallback</ref>? successCallback,&#13;
                    optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unregisters an application from the Tizen push server.
            </brief>
           <description>
            <p>
The <em>ErrorCallback()</em> is launched with these error types:
            </p>
            <ul>
              <li>
UnknownError - If an unknown error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/push
            </privilege>
            <Code> // Defines the error callback
 function errorCallback(response) {
   console.log( 'The following error occurred: ' +  response.name);
 }

 // Defines the unregistration success callback
 function unregisterSuccessCallback() {
   console.log(&quot;Unregistration succeeded.&quot;);
 }

 // Requests unregistration
 tizen.push.unregisterService(unregisterSuccessCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 The method to be called when the request is successfully unregistered.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be called when the unregistration request fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameters does not contain a valid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="connectService" id="::Push::PushManager::connectService">
        <webidl>      void connectService(<ref>PushNotificationCallback</ref> notificationCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Connects to the push service and receives push notifications.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/push
            </privilege>
            <Code> // Defines the connect success callback
 function notificationCallback(noti) {
   console.log(&quot;Notification received with alert message: &quot; + noti.alertMessage);
 }

 // Requests for push service connection
 tizen.push.connectService(notificationCallback, errorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="notificationCallback">
            <descriptive>
                <description><p>
 The method to be called when the notification message arrives.
                </p></description>
            </descriptive>
            <Type name="PushNotificationCallback"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any input parameters does not contain a valid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="disconnectService" id="::Push::PushManager::disconnectService">
        <webidl>      void disconnectService() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Disconnects to the push service and stop receiving push notifications.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/push
            </privilege>
            <Code> // Requests disconnection
 tizen.push.disconnectService();
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getRegistrationId" id="::Push::PushManager::getRegistrationId">
        <webidl>      <ref>PushRegistrationId</ref> getRegistrationId() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the push service registration ID for this application if the registration process was successful. <var>null </var>is returned if the application has not been registered yet.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/push
            </privilege>
            <Code> var registrationId = tizen.push.getRegistrationId();
 if ( registrationId != NULL ) {
   console.log(&quot;The registration id: &quot; + registrationId);
 }
 </Code>
        </descriptive>
        <Type name="PushRegistrationId"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="PushMessage" id="::Push::PushMessage">
      <webidl>    [NoInterfaceObject] interface PushMessage {&#13;
&#13;
        readonly attribute DOMString appData;&#13;
&#13;
&#13;
        readonly attribute DOMString alertMessage;&#13;
&#13;
&#13;
        readonly attribute Date date;&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface specifies the push message that is delivered from the push service.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="appData" id="::Push::PushMessage::appData">
        <webidl>        readonly attribute DOMString appData;</webidl>
        <descriptive>
            <brief>
 An attribute to store the push notification data.
            </brief>
           <description>
            <p>
This data is the message that the sender wants to send and its length must be less than 1 KB.
            </p>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="alertMessage" id="::Push::PushMessage::alertMessage">
        <webidl>        readonly attribute DOMString alertMessage;</webidl>
        <descriptive>
            <brief>
 An attribute to store the push notification message that is displayed as an alert message to the user.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="date" id="::Push::PushMessage::date">
        <webidl>        readonly attribute Date date;</webidl>
        <descriptive>
            <brief>
 An attribute to store the date/time when a push notification message is received.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="Date"/>
      </Attribute>
    </Interface>
    <Interface name="PushRegisterSuccessCallback" id="::Push::PushRegisterSuccessCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject]&#13;
    interface PushRegisterSuccessCallback {&#13;
&#13;
        void onsuccess(<ref>PushRegistrationId</ref> id);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface specifies the success callback for push service registration request.
          </brief>
         <description>
          <p>
This success callback is invoked when a push service registration request is successful.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Push::PushRegisterSuccessCallback::onsuccess">
        <webidl>        void onsuccess(<ref>PushRegistrationId</ref> id);</webidl>
        <descriptive>
            <brief>
 Called when a push service registration request is successful.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 The registration ID.
                </p></description>
            </descriptive>
            <Type name="PushRegistrationId"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="PushNotificationCallback" id="::Push::PushNotificationCallback">
      <webidl>    [Callback=FunctionOnly, NoInterfaceObject]&#13;
    interface PushNotificationCallback {&#13;
&#13;
        void onsuccess(<ref>PushMessage</ref> message);&#13;
    };</webidl>
      <descriptive>
          <brief>
 This interface specifies the notification callback for the received push notification message.
          </brief>
         <description>
          <p>
This notification callback is invoked when the push notification message arrives.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Push::PushNotificationCallback::onsuccess">
        <webidl>        void onsuccess(<ref>PushMessage</ref> message);</webidl>
        <descriptive>
            <brief>
 Called when the push notification message arrives.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="message">
            <descriptive>
                <description><p>
 The received push notification message.
                </p></description>
            </descriptive>
            <Type name="PushMessage"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="SecureElement" id="::SecureElement">
    <webidl>module SecureElement {&#13;
&#13;
  [NoInterfaceObject] interface SEServiceManagerObject {&#13;
    readonly attribute <ref>SEService</ref> seService;&#13;
  };&#13;
  <ref>Tizen</ref> implements <ref>SEServiceManagerObject</ref>;&#13;
 &#13;
&#13;
  [NoInterfaceObject] interface SEService&#13;
  {&#13;
&#13;
    void getReaders(<ref>ReaderArraySuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    unsigned long registerSEListener(<ref>SEChangeListener</ref> listener) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void unregisterSEListener(unsigned long id) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
    void shutdown() raises(<ref>WebAPIException</ref>);&#13;
  };&#13;
&#13;
&#13;
  [NoInterfaceObject] interface Reader&#13;
  {&#13;
&#13;
    readonly attribute boolean isPresent;&#13;
&#13;
    DOMString getName() raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void openSession(<ref>SessionSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void closeSessions() raises(<ref>WebAPIException</ref>);&#13;
  };&#13;
&#13;
  [NoInterfaceObject] interface Session&#13;
  {&#13;
&#13;
    readonly attribute boolean isClosed;&#13;
&#13;
    void openBasicChannel(byte[] aid, <ref>ChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void openLogicalChannel(byte[] aid, <ref>ChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    byte[] getATR() raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void close() raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void closeChannels() raises(<ref>WebAPIException</ref>);&#13;
  };&#13;
&#13;
&#13;
  [NoInterfaceObject] interface Channel {&#13;
&#13;
    readonly attribute boolean isBasicChannel;&#13;
&#13;
    void close() raises(<ref>WebAPIException</ref>);&#13;
    &#13;
&#13;
    void transmit(byte[] command, <ref>TransmitSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
  };&#13;
&#13;
&#13;
  [Callback, NoInterfaceObject] interface SEChangeListener {&#13;
&#13;
    void onSEReady(<ref>Reader</ref> reader);&#13;
&#13;
    void onSENotReady(<ref>Reader</ref> reader);&#13;
  };&#13;
&#13;
&#13;
  [Callback=FunctionOnly, NoInterfaceObject] interface ReaderArraySuccessCallback {&#13;
&#13;
    void onsuccess(<ref>Reader</ref>[] readers);&#13;
  };&#13;
&#13;
&#13;
  [Callback=FunctionOnly, NoInterfaceObject] interface SessionSuccessCallback {&#13;
&#13;
    void onsuccess(<ref>Session</ref> session);&#13;
  };&#13;
&#13;
&#13;
  [Callback=FunctionOnly, NoInterfaceObject] interface ChannelSuccessCallback {&#13;
&#13;
    void onsuccess(<ref>Channel</ref> channel);&#13;
  };&#13;
&#13;
&#13;
  [Callback=FunctionOnly, NoInterfaceObject] interface TransmitSuccessCallback {&#13;
&#13;
    void onsuccess(byte[] response);&#13;
  };&#13;
};</webidl>
    <descriptive>
        <brief>
 Secure Element is a secure smart card chip. It can be UICC/SIM, embedded Secure Element, or Secure SD card that is inserted in a device.
        </brief>
       <description>
        <p>
This API provides functionality to communicate with applications in several Secure Elements.
        </p>
       </description>
        <version>
 2.1
        </version>
        <def-api-feature identifier="http://tizen.org/feature/network.secure_element">
          <descriptive>
           <description>
            <p>
To guarantee this application running on a device with SecureElement feature, define below in the config file:
            </p>
           </description>
          </descriptive>
        </def-api-feature>
    </descriptive>
    <Interface name="SEServiceManagerObject" id="::SecureElement::SEServiceManagerObject">
      <webidl>  [NoInterfaceObject] interface SEServiceManagerObject {&#13;
    readonly attribute <ref>SEService</ref> seService;&#13;
  };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated by the Tizen object from the Tizen Platform.
          </brief>
         <description>
          <p>
There is a <em>tizen.seService</em> object that allows access to the functionalities of the Secure Element API.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="seService" id="::SecureElement::SEServiceManagerObject::seService">
        <webidl>    readonly attribute <ref>SEService</ref> seService;</webidl>
        <Type name="SEService"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="SEServiceManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>SEServiceManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="SEService" id="::SecureElement::SEService">
      <webidl>  [NoInterfaceObject] interface SEService&#13;
  {&#13;
&#13;
    void getReaders(<ref>ReaderArraySuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    unsigned long registerSEListener(<ref>SEChangeListener</ref> listener) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void unregisterSEListener(unsigned long id) raises(<ref>WebAPIException</ref>);&#13;
&#13;
&#13;
    void shutdown() raises(<ref>WebAPIException</ref>);&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface provides access to the available Secure Element readers.
          </brief>
         <description>
          <p>
It provides access to the API functionalities through the <em>tizen.seService</em> interface.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getReaders" id="::SecureElement::SEService::getReaders">
        <webidl>    void getReaders(<ref>ReaderArraySuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets all the available Secure Element readers.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 UnknownError - If any error occurs during retrieval.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
  function success(readers) {
   for (var i = 0; i &#60; readers.length; i++) {
    if (readers[i].isPresent) {
     console.log (&quot;Reader Name : &quot; + readers[i].getName());
    }
   }
  }
  function error(err) {
   console.log (err.name + &quot;: &quot; + err.message);
  }
  tizen.seService.getReaders(success, error);
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when the list of available Secure Element readers has been successfully retrieved
                </p></description>
            </descriptive>
            <Type name="ReaderArraySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to call when an error occurs
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="registerSEListener" id="::SecureElement::SEService::registerSEListener">
        <webidl>    unsigned long registerSEListener(<ref>SEChangeListener</ref> listener) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Registers a callback function that is invoked when an available Secure Element reader is detected.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
  var seListener = tizen.seService.registerSEListener({
   onSEReady:function(reader) {
     console.log (reader.getName() + &quot;is ready.&quot;);
    }, onSENotReady:function(reader) {
     console.log (reader.getName() + &quot;is not ready.&quot;);
    }});
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="unsigned long">
          <descriptive>
              <description><p>
 unsigned long An identifier used to clear the watch subscription.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="listener">
            <descriptive>
                <description><p>
 A listener to be invoked for successful detection of available Secure Element readers.
                </p></description>
            </descriptive>
            <Type name="SEChangeListener"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="unregisterSEListener" id="::SecureElement::SEService::unregisterSEListener">
        <webidl>    void unregisterSEListener(unsigned long id) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unregisters the listener from notifying any detection of an available Secure Element reader.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var seListener; //seListener obtained from registerSEListener
 try {
  tizen.seService.unregisterSEListener(seListener);
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="id">
            <descriptive>
                <description><p>
 A subscription identifier that is returned by the <em>registerSEListener()</em> method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contains an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="shutdown" id="::SecureElement::SEService::shutdown">
        <webidl>    void shutdown() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Shuts down Secure Elements after releasing all resources.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
  tizen.seService.shutdown();
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Reader" id="::SecureElement::Reader">
      <webidl>  [NoInterfaceObject] interface Reader&#13;
  {&#13;
&#13;
    readonly attribute boolean isPresent;&#13;
&#13;
    DOMString getName() raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void openSession(<ref>SessionSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void closeSessions() raises(<ref>WebAPIException</ref>);&#13;
  };</webidl>
      <descriptive>
          <brief>
 Reader interface that is connected to this device.
          </brief>
         <description>
          <p>
This interface offers methods to control sessions on the reader.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="isPresent" id="::SecureElement::Reader::isPresent">
        <webidl>    readonly attribute boolean isPresent;</webidl>
        <descriptive>
            <brief>
 An attribute to check whether a Secure Element is present on a reader.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="getName" id="::SecureElement::Reader::getName">
        <webidl>    DOMString getName() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets reader's name.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
  function success(readers) {
   for (var i = 0; i &#60; readers.length; i++) {
    if (readers[i].isPresent) {
     console.log (&quot;Reader Name : &quot; + readers[i].getName());
    }
   }
  }
  function error(err) {
   console.log (err.name + &quot;: &quot; + err.message);
  }
  tizen.seService.getReaders(success, error);
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The name of the reader.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="openSession" id="::SecureElement::Reader::openSession">
        <webidl>    void openSession(<ref>SessionSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Opens a session on a reader.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 IOError - An error occurred in communication with the Secure Element in this reader.              </li>
              <li>
 InvalidStateError - If a Secure Element is not present on this reader.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
  function success(session) {
   console.log (&quot;Open Session Success : &quot; + !session.isClosed);
  }
  function error(err) {
   console.log (err.name + &quot;: &quot; + err.message);
  }
  reader.openSession(success, error);
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when a session has been successfully opened
                </p></description>
            </descriptive>
            <Type name="SessionSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be called when an error occurs
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="closeSessions" id="::SecureElement::Reader::closeSessions">
        <webidl>    void closeSessions() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Closes all sessions opened on a reader.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
  reader.closeSessions();
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Session" id="::SecureElement::Session">
      <webidl>  [NoInterfaceObject] interface Session&#13;
  {&#13;
&#13;
    readonly attribute boolean isClosed;&#13;
&#13;
    void openBasicChannel(byte[] aid, <ref>ChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void openLogicalChannel(byte[] aid, <ref>ChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
&#13;
    byte[] getATR() raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void close() raises(<ref>WebAPIException</ref>);&#13;
&#13;
    void closeChannels() raises(<ref>WebAPIException</ref>);&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface is connected to one of the readers and offers methods to control channels in a session.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="isClosed" id="::SecureElement::Session::isClosed">
        <webidl>    readonly attribute boolean isClosed;</webidl>
        <descriptive>
            <brief>
 An attribute to check whether a session is closed or not.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="openBasicChannel" id="::SecureElement::Session::openBasicChannel">
        <webidl>    void openBasicChannel(byte[] aid, <ref>ChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Opens a basic channel in a session.
The basic channel (defined in the ISO7816-4 specification) is opened by default and its channel ID is <var>0</var>.
Once this channel has been opened by an application, it is considered to be &quot;locked&quot; to other applications, and they cannot open any channel, until the basic channel is closed.
Some Secure Elements might always deny opening a basic channel.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 IOError - If an error occurs while communicating with the Secure Element in the reader.              </li>
              <li>
 SecurityError - If access to this AID or the default application on this session is not allowed .              </li>
              <li>
 InvalidStateError - If this session is closed.               </li>
              <li>
 NotFoundError - If the application of the AID does not exist in the Secure Element.              </li>
              <li>
 NoChannelError - If basic channel is unavailable.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> try {
  function successChannel(channel) {
   if (channel.isBasicChannel) {
    console.log (&quot;Basic channel is opened.&quot;);
   } else {
    console.log (&quot;Logical channel is opened.&quot;);
   }
  }
  function errorChannel(err) {
   console.log (&quot;openBasicChannel Error :&quot; + err.name +&quot;: &quot; + err.message);
  }

  function successSession(session) {
   console.log (&quot;Open Session Success : &quot; + !session.isClosed);
   // This aid is for test. Use aid for your applet in secure element.
   session.openBasicChannel([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe], successChannel, errorChannel);
  }
  function errorSession(err) {
   console.log (&quot;openSession Error : &quot; + err.name + &quot;: &quot; + err.message);
  }
  reader.openSession(successSession, errorSession);
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="aid">
            <descriptive>
                <description><p>
 The id of the applet to select on this channel.<br/>If the array is empty, the default applet is selected in this session.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when a basic channel has been successfully opened
                </p></description>
            </descriptive>
            <Type name="ChannelSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be called when an error occurs
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the AID's length is not within the limit: 5 to 16(inclusive).
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="openLogicalChannel" id="::SecureElement::Session::openLogicalChannel">
        <webidl>    void openLogicalChannel(byte[] aid, <ref>ChannelSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Opens a logical channel in a session by the specified applet id.
The logical channel is defined in the ISO7816-4 specification.
            </brief>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 IOError - If an error occurs while communicating with the Secure Element in the reader.              </li>
              <li>
 SecurityError - If access to this AID or the default application in this session is not allowed.              </li>
              <li>
 InvalidStateError - If this session is closed.              </li>
              <li>
 NotFoundError - If the application of the AID does not exist in the Secure Element.              </li>
              <li>
 NoChannelError - If logical channel is unavailable.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var session; //Session obtained from openSession callback
 try {
  function successChannel(channel) {
   if (channel.isBasicChannel) {
    console.log (&quot;Basic channel is opened.&quot;);
   } else {
    console.log (&quot;Logical channel is opened.&quot;);
   }
  }
  function errorChannel(err) {
   console.log (&quot;openLogicalChannel Error :&quot; + err.name + &quot;: &quot; + err.message);
  }

   // This aid is for test. Use aid for your applet in secure element.
  session.openLogicalChannel([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe], successChannel, errorChannel);
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="aid">
            <descriptive>
                <description><p>
 The id of the applet to select on this channel<br/>If the array is empty, the default application is selected in this session.
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when a logical channel has been successfully opened
                </p></description>
            </descriptive>
            <Type name="ChannelSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be called when an error occurs
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the AID's length is not within the limit: 5 to 16(inclusive).
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getATR" id="::SecureElement::Session::getATR">
        <webidl>    byte[] getATR() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the answer to reset(ATR) of a Secure Element.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var session; //Session obtained from openSession callback
 try {
  var atr = session.getATR();
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 byte[] The ATR of a Secure Element.
              </p></description>
          </descriptive>
          <Type type="byte"/>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="close" id="::SecureElement::Session::close">
        <webidl>    void close() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Closes a session.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var session; //Session obtained from openSession callback
 try {
  session.close();
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="closeChannels" id="::SecureElement::Session::closeChannels">
        <webidl>    void closeChannels() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Closes all channels on this session.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var session; //Session obtained from openSession callback
 try {
  session.closeChannels();
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="Channel" id="::SecureElement::Channel">
      <webidl>  [NoInterfaceObject] interface Channel {&#13;
&#13;
    readonly attribute boolean isBasicChannel;&#13;
&#13;
    void close() raises(<ref>WebAPIException</ref>);&#13;
    &#13;
&#13;
    void transmit(byte[] command, <ref>TransmitSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface is open to a Secure Element and offers methods to send Application Protocol Data Units(APDU) to the Secure Element.
The channel is defined in the ISO7816-4.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="isBasicChannel" id="::SecureElement::Channel::isBasicChannel">
        <webidl>    readonly attribute boolean isBasicChannel;</webidl>
        <descriptive>
            <brief>
 An attribute to check whether it is a basic channel or not.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Operation name="close" id="::SecureElement::Channel::close">
        <webidl>    void close() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Closes a channel.
            </brief>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
            <Code> var channel; //Obtained from openLogicalChannel or openBasicChannel
 try {
  channel.close();
 } catch (err) {
  console.log (err.name + &quot;: &quot; + err.message);
 }
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
                <description><p>
 with error type UnknownError, if any other error occurs.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="transmit" id="::SecureElement::Channel::transmit">
        <webidl>    void transmit(byte[] command, <ref>TransmitSuccessCallback</ref> successCallback, optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Transmits an APDU command to a Secure Element. The APDU command is defined in ISO7816-4.
            </brief>
           <description>
            <p>
Some commands that are not allowed to be sent are:
            </p>
            <ul>
              <li>
 MANAGE_CHANNEL commands.               </li>
              <li>
 SELECT by DF Name (p1=04).               </li>
              <li>
 The commands that CLA bytes with channel numbers are de-masked.               </li>
            </ul>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
 InvalidValuesError - If the command contain an invalid value.              </li>
              <li>
 IOError - An error occurred while communicating with the Secure Element in the reader.              </li>
              <li>
 SecurityError - If the command is not allowed.              </li>
              <li>
 InvalidStateError - If this channel is closed.              </li>
              <li>
 UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
            <privilege>
 http://tizen.org/privilege/secureelement
            </privilege>
            <privilegelevel>
 public
            </privilegelevel>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="command">
            <descriptive>
                <description><p>
 The APDU command to transmit through this channel
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 The method to be invoked when a command has been successfully transmitted
                </p></description>
            </descriptive>
            <Type name="TransmitSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 The method to be called when an error occurs
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="SEChangeListener" id="::SecureElement::SEChangeListener">
      <webidl>  [Callback, NoInterfaceObject] interface SEChangeListener {&#13;
&#13;
    void onSEReady(<ref>Reader</ref> reader);&#13;
&#13;
    void onSENotReady(<ref>Reader</ref> reader);&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface provides the success callback that is invoked when a Secure Element reader is detected or lost.
          </brief>
         <description>
          <p>
It is used in <em>SEService.registerSEListener()</em>.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onSEReady" id="::SecureElement::SEChangeListener::onSEReady">
        <webidl>    void onSEReady(<ref>Reader</ref> reader);</webidl>
        <descriptive>
            <brief>
 Called when a Secure Element reader is detected.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reader">
            <descriptive>
                <description><p>
 A newly detected Secure Element reader
                </p></description>
            </descriptive>
            <Type name="Reader"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="onSENotReady" id="::SecureElement::SEChangeListener::onSENotReady">
        <webidl>    void onSENotReady(<ref>Reader</ref> reader);</webidl>
        <descriptive>
            <brief>
 Called when a Secure Element reader is lost.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="reader">
            <descriptive>
                <description><p>
 A lost Secure Element reader
                </p></description>
            </descriptive>
            <Type name="Reader"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ReaderArraySuccessCallback" id="::SecureElement::ReaderArraySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ReaderArraySuccessCallback {&#13;
&#13;
    void onsuccess(<ref>Reader</ref>[] readers);&#13;
  };</webidl>
      <descriptive>
          <brief>
 This callback interface provides a success callback that is invoked when a list of available Secure Element readers is retrieved.
          </brief>
         <description>
          <p>
It specifies a success method with an array of <em>Reader</em> objects as an input parameter.
It is used in asynchronous operations such as <em>SEService.getReaders()</em>.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::SecureElement::ReaderArraySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>Reader</ref>[] readers);</webidl>
        <descriptive>
            <brief>
 Called when an asynchronous call completes successfully.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="readers">
            <descriptive>
                <description><p>
 A list of available Secure Element readers
                </p></description>
            </descriptive>
            <Type type="array">
              <Type name="Reader"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="SessionSuccessCallback" id="::SecureElement::SessionSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface SessionSuccessCallback {&#13;
&#13;
    void onsuccess(<ref>Session</ref> session);&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface specifies the success callback that is invoked when a session on a specific reader is open.
          </brief>
         <description>
          <p>
This callback interface specifies a success method with a <em>Session</em> object as an input parameter.
It is used in asynchronous operations such as <em>Reader.openSession()</em>.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::SecureElement::SessionSuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>Session</ref> session);</webidl>
        <descriptive>
            <brief>
 Called when an asynchronous call completes successfully.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="session">
            <descriptive>
                <description><p>
 An open session
                </p></description>
            </descriptive>
            <Type name="Session"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="ChannelSuccessCallback" id="::SecureElement::ChannelSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface ChannelSuccessCallback {&#13;
&#13;
    void onsuccess(<ref>Channel</ref> channel);&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface specifies the success callback that is invoked when a channel is open to communicate with a specific applet.
          </brief>
         <description>
          <p>
This callback interface specifies a success method with a <em>Channel</em> object as an input parameter.
It is used in asynchronous operations such as <em>Session.openBasicChannel() </em>or <em>Session.openLogicalChannel()</em>.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::SecureElement::ChannelSuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>Channel</ref> channel);</webidl>
        <descriptive>
            <brief>
 Called when an asynchronous call completes successfully.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="channel">
            <descriptive>
                <description><p>
 An open channel
                </p></description>
            </descriptive>
            <Type name="Channel"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="TransmitSuccessCallback" id="::SecureElement::TransmitSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface TransmitSuccessCallback {&#13;
&#13;
    void onsuccess(byte[] response);&#13;
  };</webidl>
      <descriptive>
          <brief>
 This interface specifies the success callback that is invoked when <em>Channel.transmit() </em>completes successfully.
          </brief>
         <description>
          <p>
This callback interface specifies a success method with an array of bytes as an input parameter. It is used in <em>Channel.transmit()</em>.
          </p>
         </description>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::SecureElement::TransmitSuccessCallback::onsuccess">
        <webidl>    void onsuccess(byte[] response);</webidl>
        <descriptive>
            <brief>
 Called when an asynchronous call completes successfully.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="response">
            <descriptive>
                <description><p>
 An APDU command response that is transmitted on a channel
                </p></description>
            </descriptive>
            <Type type="array">
              <Type type="byte"/>
            </Type>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="SystemInfo" id="::SystemInfo">
    <webidl>module SystemInfo {

  enum SystemInfoPropertyId { &quot;BATTERY&quot; , &quot;CPU&quot;, &quot;STORAGE&quot;, &quot;DISPLAY&quot;, &quot;DEVICE_ORIENTATION&quot;, &quot;BUILD&quot;, &quot;LOCALE&quot;, &quot;NETWORK&quot;, &quot;WIFI_NETWORK&quot;, &quot;CELLULAR_NETWORK&quot;, &quot;SIM&quot;, &quot;PERIPHERAL&quot; };

  enum SystemInfoNetworkType { &quot;NONE&quot;, &quot;2G&quot;, &quot;2.5G&quot;, &quot;3G&quot;, &quot;4G&quot;, &quot;WIFI&quot;, &quot;ETHERNET&quot;, &quot;UNKNOWN&quot; };

  enum SystemInfoDeviceOrientationStatus { &quot;PORTRAIT_PRIMARY&quot;, &quot;PORTRAIT_SECONDARY&quot;, &quot;LANDSCAPE_PRIMARY&quot;, &quot;LANDSCAPE_SECONDARY&quot; };

  enum SystemInfoSimState { &quot;ABSENT&quot;, &quot;INITIALIZING&quot;, &quot;READY&quot;, &quot;PIN_REQUIRED&quot;, &quot;PUK_REQUIRED&quot;, &quot;NETWORK_LOCKED&quot;, &quot;SIM_LOCKED&quot;, &quot;UNKNOWN&quot; };

  enum SystemInfoProfile { &quot;MOBILE_FULL&quot;, &quot;MOBILE_WEB&quot; };

  [NoInterfaceObject] interface SystemInfoObject {
    readonly attribute <ref>SystemInfo</ref> systeminfo;
  };
  <ref>Tizen</ref> implements <ref>SystemInfoObject</ref>;

  [NoInterfaceObject] interface SystemInfo {

    <ref>SystemInfoDeviceCapability</ref> getCapabilities() raises(<ref>WebAPIException</ref>);

    void getPropertyValue(<ref>SystemInfoPropertyId</ref> property,
                          <ref>SystemInfoPropertySuccessCallback</ref> successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    unsigned long addPropertyValueChangeListener(<ref>SystemInfoPropertyId</ref> property,
                                        <ref>SystemInfoPropertySuccessCallback</ref> successCallback,
                                        optional <ref>SystemInfoOptions</ref>? options) raises(<ref>WebAPIException</ref>);

    void removePropertyValueChangeListener(unsigned long listenerId) raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface SystemInfoDeviceCapability {
    readonly attribute boolean bluetooth;

    readonly attribute boolean nfc;

    readonly attribute boolean nfcReservedPush ;

    readonly attribute unsigned short multiTouchCount;

    readonly attribute boolean inputKeyboard;

    readonly attribute boolean inputKeyboardLayout;

    readonly attribute boolean wifi;

    readonly attribute boolean wifiDirect;

    readonly attribute boolean opengles;

    readonly attribute DOMString openglestextureFormat;

    readonly attribute boolean openglesVersion1_1;

    readonly attribute boolean openglesVersion2_0;

    readonly attribute boolean fmRadio;

    readonly attribute DOMString platformVersion raises(<ref>WebAPIException</ref>);

    readonly attribute DOMString webApiVersion raises(<ref>WebAPIException</ref>);

    readonly attribute DOMString nativeApiVersion raises(<ref>WebAPIException</ref>);

    readonly attribute DOMString platformName;

    readonly attribute boolean camera;

    readonly attribute boolean cameraFront;

    readonly attribute boolean cameraFrontFlash;

    readonly attribute boolean cameraBack;

    readonly attribute boolean cameraBackFlash;

    readonly attribute boolean location;

    readonly attribute boolean locationGps;

    readonly attribute boolean locationWps;

    readonly attribute boolean microphone;

    readonly attribute boolean usbHost;

    readonly attribute boolean usbAccessory;

    readonly attribute boolean screenOutputRca;

    readonly attribute boolean screenOutputHdmi;

    readonly attribute DOMString platformCoreCpuArch;

    readonly attribute DOMString platformCoreFpuArch;

    readonly attribute boolean sipVoip;

    readonly attribute DOMString duid;

    readonly attribute boolean speechRecognition;

    readonly attribute boolean speechSynthesis;

    readonly attribute boolean accelerometer;

    readonly attribute boolean accelerometerWakeup;

    readonly attribute boolean barometer;

    readonly attribute boolean barometerWakeup;

    readonly attribute boolean gyroscope;

    readonly attribute boolean gyroscopeWakeup;

    readonly attribute boolean magnetometer;

    readonly attribute boolean magnetometerWakeup;

    readonly attribute boolean photometer;

    readonly attribute boolean photometerWakeup;

    readonly attribute boolean proximity;

    readonly attribute boolean proximityWakeup;

    readonly attribute boolean tiltmeter;

    readonly attribute boolean tiltmeterWakeup;

    readonly attribute boolean dataEncryption;

    readonly attribute boolean graphicsAcceleration;

    readonly attribute boolean push;

    readonly attribute boolean telephony;

    readonly attribute boolean telephonyMms;

    readonly attribute boolean telephonySms;

    readonly attribute boolean screenSizeNormal;

    readonly attribute boolean screenSize480_800;

    readonly attribute boolean screenSize720_1280;

    readonly attribute boolean autoRotation;

    readonly attribute boolean shellAppWidget;

    readonly attribute boolean visionImageRecognition;

    readonly attribute boolean visionQrcodeGeneration;

    readonly attribute boolean visionQrcodeRecognition;

    readonly attribute boolean visionFaceRecognition;

    readonly attribute boolean secureElement;

    readonly attribute boolean nativeOspCompatible;

    readonly attribute <ref>SystemInfoProfile</ref> profile;
  };

  dictionary SystemInfoOptions {
    unsigned long timeout;

    double highThreshold;

    double lowThreshold;
  };

  [Callback=FunctionOnly, NoInterfaceObject] interface SystemInfoPropertySuccessCallback {
    void onsuccess(<ref>SystemInfoProperty</ref> prop);
  };

  [NoInterfaceObject] interface SystemInfoProperty {
  };

  [NoInterfaceObject] interface SystemInfoBattery : <ref>SystemInfoProperty</ref> {
    readonly attribute double level;

    readonly attribute boolean isCharging;
  };

  [NoInterfaceObject] interface SystemInfoCpu : <ref>SystemInfoProperty</ref> {
    readonly attribute double load;
  };

  [NoInterfaceObject] interface SystemInfoStorage : <ref>SystemInfoProperty</ref> {
    readonly attribute <ref>SystemInfoStorageUnit</ref>[] units;
  };

  [NoInterfaceObject] interface SystemInfoStorageUnit : <ref>SystemInfoProperty</ref> {
    readonly attribute DOMString type;

    readonly attribute unsigned long long capacity;

    readonly attribute unsigned long long availableCapacity;

    readonly attribute boolean isRemovable;

    readonly attribute boolean isRemoveable;
  };

  [NoInterfaceObject] interface SystemInfoDisplay : <ref>SystemInfoProperty</ref> {
    readonly attribute unsigned long resolutionWidth;

    readonly attribute unsigned long resolutionHeight;

    readonly attribute unsigned long dotsPerInchWidth;

    readonly attribute unsigned long dotsPerInchHeight;

    readonly attribute double physicalWidth;

    readonly attribute double physicalHeight;

    readonly attribute double brightness;
  };

  [NoInterfaceObject] interface SystemInfoDeviceOrientation : <ref>SystemInfoProperty</ref> {

    readonly attribute <ref>SystemInfoDeviceOrientationStatus</ref> status;
    readonly attribute boolean isAutoRotation;
  };

  [NoInterfaceObject] interface SystemInfoBuild : <ref>SystemInfoProperty</ref> {

    readonly attribute DOMString model;
    readonly attribute DOMString manufacturer;
    readonly attribute DOMString buildVersion;
  };

  [NoInterfaceObject] interface SystemInfoLocale : <ref>SystemInfoProperty</ref> {

    readonly attribute DOMString language;

    readonly attribute DOMString country;
  };

  [NoInterfaceObject] interface SystemInfoNetwork : <ref>SystemInfoProperty</ref> {

    readonly attribute <ref>SystemInfoNetworkType</ref> networkType;
  };

   [NoInterfaceObject] interface SystemInfoWifiNetwork : <ref>SystemInfoProperty</ref> {

    readonly attribute DOMString status;
    readonly attribute DOMString ssid;
    readonly attribute DOMString ipAddress;
     readonly attribute DOMString ipv6Address;
    readonly attribute double signalStrength;
  };

  [NoInterfaceObject] interface SystemInfoCellularNetwork : <ref>SystemInfoProperty</ref> {

    readonly attribute DOMString status;
    readonly attribute DOMString apn;
    readonly attribute DOMString ipAddress;
    readonly attribute DOMString ipv6Address;
    readonly attribute unsigned short mcc;
    readonly attribute unsigned short mnc;
    readonly attribute unsigned short cellId;
    readonly attribute unsigned short lac;
    readonly attribute boolean isRoaming;
    readonly attribute boolean isFlightMode;
    readonly attribute DOMString imei raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface SystemInfoSIM : <ref>SystemInfoProperty</ref> {
    readonly attribute <ref>SystemInfoSimState</ref> state raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString operatorName raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString msisdn raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString iccid raises(<ref>WebAPIException</ref>);
    readonly attribute unsigned short mcc raises(<ref>WebAPIException</ref>);
    readonly attribute unsigned short mnc raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString msin raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString spn raises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject] interface SystemInfoPeripheral : <ref>SystemInfoProperty</ref> {

    readonly attribute boolean isVideoOutputOn;
  };
};</webidl>
    <descriptive>
        <brief>
 This specification defines interfaces and methods that provide web applications with access to various properties of a system.
        </brief>
       <description>
        <p>
This API also provides interfaces and methods that can retrieve statuses of hardware devices, get the value of selected properties, and subscribe to asynchronous notifications of changes for selected values.
        </p>
        <p>
The following provides an overview of the tree data structure:
        </p>
        <ul>
          <li>
BATTERY          </li>
          <li>
CPU          </li>
          <li>
STORAGE          </li>
          <li>
DISPLAY          </li>
          <li>
DEVICE_ORIENTATION          </li>
          <li>
BUILD          </li>
          <li>
LOCALE          </li>
          <li>
NETWORK          </li>
          <li>
WIFI_NETWORK          </li>
          <li>
CELLULAR_NETWORK          </li>
          <li>
SIM          </li>
          <li>
PERIPHERAL          </li>
        </ul>
        <p>
For more information on the SystemInfo features, see <a href="../../org.tizen.web.appprogramming/html/guide/sys_guide/systeminfo.htm">System Information Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
    </descriptive>
    <Enum name="SystemInfoPropertyId" id="::SystemInfo::SystemInfoPropertyId">
      <webidl>  enum SystemInfoPropertyId { &quot;BATTERY&quot; , &quot;CPU&quot;, &quot;STORAGE&quot;, &quot;DISPLAY&quot;, &quot;DEVICE_ORIENTATION&quot;, &quot;BUILD&quot;, &quot;LOCALE&quot;, &quot;NETWORK&quot;, &quot;WIFI_NETWORK&quot;, &quot;CELLULAR_NETWORK&quot;, &quot;SIM&quot;, &quot;PERIPHERAL&quot; };</webidl>
      <descriptive>
          <brief>
 The device property identifier.
          </brief>
          <version>
 2.0
          </version>
          <remark>
 LOCALE and PERIPHERAL are supported Since 2.1
          </remark>
      </descriptive>
      <EnumValue stringvalue="BATTERY">
        <webidl> &quot;BATTERY</webidl>
      </EnumValue>
      <EnumValue stringvalue="CPU">
        <webidl> &quot;CPU</webidl>
      </EnumValue>
      <EnumValue stringvalue="STORAGE">
        <webidl> &quot;STORAGE</webidl>
      </EnumValue>
      <EnumValue stringvalue="DISPLAY">
        <webidl> &quot;DISPLAY</webidl>
      </EnumValue>
      <EnumValue stringvalue="DEVICE_ORIENTATION">
        <webidl> &quot;DEVICE_ORIENTATION</webidl>
      </EnumValue>
      <EnumValue stringvalue="BUILD">
        <webidl> &quot;BUILD</webidl>
      </EnumValue>
      <EnumValue stringvalue="LOCALE">
        <webidl> &quot;LOCALE</webidl>
      </EnumValue>
      <EnumValue stringvalue="NETWORK">
        <webidl> &quot;NETWORK</webidl>
      </EnumValue>
      <EnumValue stringvalue="WIFI_NETWORK">
        <webidl> &quot;WIFI_NETWORK</webidl>
      </EnumValue>
      <EnumValue stringvalue="CELLULAR_NETWORK">
        <webidl> &quot;CELLULAR_NETWORK</webidl>
      </EnumValue>
      <EnumValue stringvalue="SIM">
        <webidl> &quot;SIM</webidl>
      </EnumValue>
      <EnumValue stringvalue="PERIPHERAL">
        <webidl> &quot;PERIPHERAL</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SystemInfoNetworkType" id="::SystemInfo::SystemInfoNetworkType">
      <webidl>  enum SystemInfoNetworkType { &quot;NONE&quot;, &quot;2G&quot;, &quot;2.5G&quot;, &quot;3G&quot;, &quot;4G&quot;, &quot;WIFI&quot;, &quot;ETHERNET&quot;, &quot;UNKNOWN&quot; };</webidl>
      <descriptive>
          <brief>
 Data Network Type.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="NONE">
        <webidl> &quot;NONE</webidl>
      </EnumValue>
      <EnumValue stringvalue="2G">
        <webidl> &quot;2G</webidl>
      </EnumValue>
      <EnumValue stringvalue="2.5G">
        <webidl> &quot;2.5G</webidl>
      </EnumValue>
      <EnumValue stringvalue="3G">
        <webidl> &quot;3G</webidl>
      </EnumValue>
      <EnumValue stringvalue="4G">
        <webidl> &quot;4G</webidl>
      </EnumValue>
      <EnumValue stringvalue="WIFI">
        <webidl> &quot;WIFI</webidl>
      </EnumValue>
      <EnumValue stringvalue="ETHERNET">
        <webidl> &quot;ETHERNET</webidl>
      </EnumValue>
      <EnumValue stringvalue="UNKNOWN">
        <webidl> &quot;UNKNOWN</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SystemInfoDeviceOrientationStatus" id="::SystemInfo::SystemInfoDeviceOrientationStatus">
      <webidl>  enum SystemInfoDeviceOrientationStatus { &quot;PORTRAIT_PRIMARY&quot;, &quot;PORTRAIT_SECONDARY&quot;, &quot;LANDSCAPE_PRIMARY&quot;, &quot;LANDSCAPE_SECONDARY&quot; };</webidl>
      <descriptive>
          <brief>
 Device Orientation Status.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="PORTRAIT_PRIMARY">
        <webidl> &quot;PORTRAIT_PRIMARY</webidl>
      </EnumValue>
      <EnumValue stringvalue="PORTRAIT_SECONDARY">
        <webidl> &quot;PORTRAIT_SECONDARY</webidl>
      </EnumValue>
      <EnumValue stringvalue="LANDSCAPE_PRIMARY">
        <webidl> &quot;LANDSCAPE_PRIMARY</webidl>
      </EnumValue>
      <EnumValue stringvalue="LANDSCAPE_SECONDARY">
        <webidl> &quot;LANDSCAPE_SECONDARY</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SystemInfoSimState" id="::SystemInfo::SystemInfoSimState">
      <webidl>  enum SystemInfoSimState { &quot;ABSENT&quot;, &quot;INITIALIZING&quot;, &quot;READY&quot;, &quot;PIN_REQUIRED&quot;, &quot;PUK_REQUIRED&quot;, &quot;NETWORK_LOCKED&quot;, &quot;SIM_LOCKED&quot;, &quot;UNKNOWN&quot; };</webidl>
      <descriptive>
          <brief>
 Sim State.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <EnumValue stringvalue="ABSENT">
        <webidl> &quot;ABSENT</webidl>
      </EnumValue>
      <EnumValue stringvalue="INITIALIZING">
        <webidl> &quot;INITIALIZING</webidl>
      </EnumValue>
      <EnumValue stringvalue="READY">
        <webidl> &quot;READY</webidl>
      </EnumValue>
      <EnumValue stringvalue="PIN_REQUIRED">
        <webidl> &quot;PIN_REQUIRED</webidl>
      </EnumValue>
      <EnumValue stringvalue="PUK_REQUIRED">
        <webidl> &quot;PUK_REQUIRED</webidl>
      </EnumValue>
      <EnumValue stringvalue="NETWORK_LOCKED">
        <webidl> &quot;NETWORK_LOCKED</webidl>
      </EnumValue>
      <EnumValue stringvalue="SIM_LOCKED">
        <webidl> &quot;SIM_LOCKED</webidl>
      </EnumValue>
      <EnumValue stringvalue="UNKNOWN">
        <webidl> &quot;UNKNOWN</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SystemInfoProfile" id="::SystemInfo::SystemInfoProfile">
      <webidl>  enum SystemInfoProfile { &quot;MOBILE_FULL&quot;, &quot;MOBILE_WEB&quot; };</webidl>
      <descriptive>
          <brief>
 Device Profile.
          </brief>
          <version>
 2.2
          </version>
      </descriptive>
      <EnumValue stringvalue="MOBILE_FULL">
        <webidl> &quot;MOBILE_FULL</webidl>
      </EnumValue>
      <EnumValue stringvalue="MOBILE_WEB">
        <webidl> &quot;MOBILE_WEB</webidl>
      </EnumValue>
    </Enum>
    <Interface name="SystemInfoObject" id="::SystemInfo::SystemInfoObject">
      <webidl>  [NoInterfaceObject] interface SystemInfoObject {
    readonly attribute <ref>SystemInfo</ref> systeminfo;
  };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated by the <em>Tizen </em>object from the Tizen Platform.
          </brief>
         <description>
          <p>
There will be a tizen.systeminfo object that allows accessing the
functionality of the SystemInfo API.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="systeminfo" id="::SystemInfo::SystemInfoObject::systeminfo">
        <webidl>    readonly attribute <ref>SystemInfo</ref> systeminfo;</webidl>
        <Type name="SystemInfo"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="SystemInfoObject">
      <webidl>  <ref>Tizen</ref> implements <ref>SystemInfoObject</ref>;</webidl>
    </Implements>
    <Interface name="SystemInfo" id="::SystemInfo::SystemInfo">
      <webidl>  [NoInterfaceObject] interface SystemInfo {

    <ref>SystemInfoDeviceCapability</ref> getCapabilities() raises(<ref>WebAPIException</ref>);

    void getPropertyValue(<ref>SystemInfoPropertyId</ref> property,
                          <ref>SystemInfoPropertySuccessCallback</ref> successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);

    unsigned long addPropertyValueChangeListener(<ref>SystemInfoPropertyId</ref> property,
                                        <ref>SystemInfoPropertySuccessCallback</ref> successCallback,
                                        optional <ref>SystemInfoOptions</ref>? options) raises(<ref>WebAPIException</ref>);

    void removePropertyValueChangeListener(unsigned long listenerId) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This entry interface queries the information of a system.
          </brief>
         <description>
          <p>
This API offers methods for retrieving system information
and for subscribing notifications of system information changes.
          </p>
         </description>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getCapabilities" id="::SystemInfo::SystemInfo::getCapabilities">
        <webidl>    <ref>SystemInfoDeviceCapability</ref> getCapabilities() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the capabilities of the device.
            </brief>
           <description>
            <p>
The function must synchronously acquire the capabilities of the device.
            </p>
           </description>
            <version>
 2.0
            </version>
            <Code> var deviceCapabilities;
 deviceCapabilities = tizen.systeminfo.getCapabilities();
 if (deviceCapabilities.bluetooth)
 {
     console.log(&quot;Bluetooth is supported&quot;);
 }
 </Code>
        </descriptive>
        <Type name="SystemInfoDeviceCapability"/>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getPropertyValue" id="::SystemInfo::SystemInfo::getPropertyValue">
        <webidl>    void getPropertyValue(<ref>SystemInfoPropertyId</ref> property,
                          <ref>SystemInfoPropertySuccessCallback</ref> successCallback,
                          optional <ref>ErrorCallback</ref>? errorCallback) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the current value of a specified system property.
            </brief>
           <description>
            <p>
The function must asynchronously acquire the current value of the requested property. If it is successful,
the successCallback must be invoked with an object containing the information provided by the property.
            </p>
            <p>
The <em>errorCallback() </em>can be launched with any of these error types:
            </p>
            <ul>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
            <Code> function onSuccessCallback(battery) {
     console.log(&quot;The battery level is &quot; + battery.level);
 }

 function onErrorCallback(error) {
     console.log(&quot;An error occurred &quot; + error.message);
 }

 tizen.systeminfo.getPropertyValue(&quot;BATTERY&quot;, onSuccessCallback, onErrorCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="property">
            <descriptive>
                <description><p>
 The name of the property to retrieve.
                </p></description>
            </descriptive>
            <Type name="SystemInfoPropertyId"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 Function called when the properties have been successfully retrieved.
                </p></description>
            </descriptive>
            <Type name="SystemInfoPropertySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 Function called when an error occurred while retrieving the properties.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addPropertyValueChangeListener" id="::SystemInfo::SystemInfo::addPropertyValueChangeListener">
        <webidl>    unsigned long addPropertyValueChangeListener(<ref>SystemInfoPropertyId</ref> property,
                                        <ref>SystemInfoPropertySuccessCallback</ref> successCallback,
                                        optional <ref>SystemInfoOptions</ref>? options) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Adds a listener to allow tracking of changes in one or more system properties.
            </brief>
           <description>
            <p>
When called, it immediately returns and then asynchronously starts a watch process defined by the following steps:
            </p>
            <p>
1. Register the successCallback to receive system events that the status of the requested properties may have changed.
            </p>
            <p>
2. When a system event is successfully received invoke the associated successCallback with an object containing the property
values.
            </p>
            <p>
3. Repeat step 2 until removePropertyValueChangeListener function is called.
            </p>
            <p>
If property value is 'BUILD', listener would not be registered because 'BUILD' property's value is a fixed value.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> function onSuccessCallback(battery) {
     console.log(&quot;Low battery:  &quot; + battery.level);
 }


 tizen.systeminfo.addPropertyValueChangeListener(&quot;BATTERY&quot;, onSuccessCallback, {lowThreshold : 0.2});
 </Code>
        </descriptive>
        <Type type="unsigned long">
          <descriptive>
              <description><p>
 unsigned long An identifier used to clear the watch subscription.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="property">
            <descriptive>
                <description><p>
 The name of the property to retrieve.
                </p></description>
            </descriptive>
            <Type name="SystemInfoPropertyId"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 Function called when the properties have been successfully retrieved.
                </p></description>
            </descriptive>
            <Type name="SystemInfoPropertySuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="options">
            <descriptive>
                <description><p>
 An object containing the various options for fetching the properties requested.
                </p></description>
            </descriptive>
            <Type name="SystemInfoOptions" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removePropertyValueChangeListener" id="::SystemInfo::SystemInfo::removePropertyValueChangeListener">
        <webidl>    void removePropertyValueChangeListener(unsigned long listenerId) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Unsubscribes notifications for property changes set up by addPropertyValueChangeListener.
            </brief>
           <description>
            <p>
If a valid listenerId argument is passed that corresponds to a subscription
already place, then the watch process MUST immediately terminate and no further
callback is invoked. If the listenerId argument does not correspond to a valid subscription,
the method should return without any further action.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var id = null;
 function onSuccessCallback(battery) {
    console.log(&quot;New value for Battery level is &quot; + battery.level);
    if (id != null) { // After receiving the first notification, we clear it
        tizen.systeminfo.removePropertyValueChangeListener(id);
    }
 }

 id = tizen.systeminfo.addPropertyValueChangeListener(&quot;BATTERY&quot;, onSuccessCallback);
 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="listenerId">
            <descriptive>
                <description><p>
 An identifier of the subscription returned by the addPropertyValueChangeListener() method.
                </p></description>
            </descriptive>
            <Type type="unsigned long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="SystemInfoDeviceCapability" id="::SystemInfo::SystemInfoDeviceCapability">
      <webidl>  [NoInterfaceObject] interface SystemInfoDeviceCapability {
    readonly attribute boolean bluetooth;

    readonly attribute boolean nfc;

    readonly attribute boolean nfcReservedPush ;

    readonly attribute unsigned short multiTouchCount;

    readonly attribute boolean inputKeyboard;

    readonly attribute boolean inputKeyboardLayout;

    readonly attribute boolean wifi;

    readonly attribute boolean wifiDirect;

    readonly attribute boolean opengles;

    readonly attribute DOMString openglestextureFormat;

    readonly attribute boolean openglesVersion1_1;

    readonly attribute boolean openglesVersion2_0;

    readonly attribute boolean fmRadio;

    readonly attribute DOMString platformVersion raises(<ref>WebAPIException</ref>);

    readonly attribute DOMString webApiVersion raises(<ref>WebAPIException</ref>);

    readonly attribute DOMString nativeApiVersion raises(<ref>WebAPIException</ref>);

    readonly attribute DOMString platformName;

    readonly attribute boolean camera;

    readonly attribute boolean cameraFront;

    readonly attribute boolean cameraFrontFlash;

    readonly attribute boolean cameraBack;

    readonly attribute boolean cameraBackFlash;

    readonly attribute boolean location;

    readonly attribute boolean locationGps;

    readonly attribute boolean locationWps;

    readonly attribute boolean microphone;

    readonly attribute boolean usbHost;

    readonly attribute boolean usbAccessory;

    readonly attribute boolean screenOutputRca;

    readonly attribute boolean screenOutputHdmi;

    readonly attribute DOMString platformCoreCpuArch;

    readonly attribute DOMString platformCoreFpuArch;

    readonly attribute boolean sipVoip;

    readonly attribute DOMString duid;

    readonly attribute boolean speechRecognition;

    readonly attribute boolean speechSynthesis;

    readonly attribute boolean accelerometer;

    readonly attribute boolean accelerometerWakeup;

    readonly attribute boolean barometer;

    readonly attribute boolean barometerWakeup;

    readonly attribute boolean gyroscope;

    readonly attribute boolean gyroscopeWakeup;

    readonly attribute boolean magnetometer;

    readonly attribute boolean magnetometerWakeup;

    readonly attribute boolean photometer;

    readonly attribute boolean photometerWakeup;

    readonly attribute boolean proximity;

    readonly attribute boolean proximityWakeup;

    readonly attribute boolean tiltmeter;

    readonly attribute boolean tiltmeterWakeup;

    readonly attribute boolean dataEncryption;

    readonly attribute boolean graphicsAcceleration;

    readonly attribute boolean push;

    readonly attribute boolean telephony;

    readonly attribute boolean telephonyMms;

    readonly attribute boolean telephonySms;

    readonly attribute boolean screenSizeNormal;

    readonly attribute boolean screenSize480_800;

    readonly attribute boolean screenSize720_1280;

    readonly attribute boolean autoRotation;

    readonly attribute boolean shellAppWidget;

    readonly attribute boolean visionImageRecognition;

    readonly attribute boolean visionQrcodeGeneration;

    readonly attribute boolean visionQrcodeRecognition;

    readonly attribute boolean visionFaceRecognition;

    readonly attribute boolean secureElement;

    readonly attribute boolean nativeOspCompatible;

    readonly attribute <ref>SystemInfoProfile</ref> profile;
  };</webidl>
      <descriptive>
          <brief>
 SystemInfoDeviceCapability object.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="bluetooth" id="::SystemInfo::SystemInfoDeviceCapability::bluetooth">
        <webidl>    readonly attribute boolean bluetooth;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Bluetooth.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="nfc" id="::SystemInfo::SystemInfoDeviceCapability::nfc">
        <webidl>    readonly attribute boolean nfc;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports NFC.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="nfcReservedPush" id="::SystemInfo::SystemInfoDeviceCapability::nfcReservedPush">
        <webidl>    readonly attribute boolean nfcReservedPush ;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports NFC reserved push.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="multiTouchCount" id="::SystemInfo::SystemInfoDeviceCapability::multiTouchCount">
        <webidl>    readonly attribute unsigned short multiTouchCount;</webidl>
        <descriptive>
            <brief>
 The number of point in Multi-point touch.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="inputKeyboard" id="::SystemInfo::SystemInfoDeviceCapability::inputKeyboard">
        <webidl>    readonly attribute boolean inputKeyboard;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports the built-in Keyboard.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="inputKeyboardLayout" id="::SystemInfo::SystemInfoDeviceCapability::inputKeyboardLayout">
        <webidl>    readonly attribute boolean inputKeyboardLayout;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports the built-in keyboard layout.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="wifi" id="::SystemInfo::SystemInfoDeviceCapability::wifi">
        <webidl>    readonly attribute boolean wifi;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Wi-Fi.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="wifiDirect" id="::SystemInfo::SystemInfoDeviceCapability::wifiDirect">
        <webidl>    readonly attribute boolean wifiDirect;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Wi-Fi direct.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="opengles" id="::SystemInfo::SystemInfoDeviceCapability::opengles">
        <webidl>    readonly attribute boolean opengles;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports OpenGL-ES.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="openglestextureFormat" id="::SystemInfo::SystemInfoDeviceCapability::openglestextureFormat">
        <webidl>    readonly attribute DOMString openglestextureFormat;</webidl>
        <descriptive>
            <brief>
 The device 3DC texture format for OpenGL-ES.
One example of possible output is as follows: &quot;3dc/atc/etc/ptc/pvrtc/utc&quot;
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="openglesVersion1_1" id="::SystemInfo::SystemInfoDeviceCapability::openglesVersion1_1">
        <webidl>    readonly attribute boolean openglesVersion1_1;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports OpenGL-ES version 1.1.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="openglesVersion2_0" id="::SystemInfo::SystemInfoDeviceCapability::openglesVersion2_0">
        <webidl>    readonly attribute boolean openglesVersion2_0;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports OpenGL-ES version 2.0.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="fmRadio" id="::SystemInfo::SystemInfoDeviceCapability::fmRadio">
        <webidl>    readonly attribute boolean fmRadio;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports FM radio.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="platformVersion" id="::SystemInfo::SystemInfoDeviceCapability::platformVersion">
        <webidl>    readonly attribute DOMString platformVersion raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The version of the platform in the <em>[Major].[Minor].[Patch Version] </em> format. <br/>For example, <var>1.0.0 </var> represents a platform version where the major version is <var>1 </var>and the minor and build versions are <var>0</var>.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="webApiVersion" id="::SystemInfo::SystemInfoDeviceCapability::webApiVersion">
        <webidl>    readonly attribute DOMString webApiVersion raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The version of the Web API in the <em>[Major].[Minor] </em> format. <br/>For example, <var>1.0 </var>represents a web api version where the major version is <var>1 </var> and the minor version is <var>0</var>.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="nativeApiVersion" id="::SystemInfo::SystemInfoDeviceCapability::nativeApiVersion">
        <webidl>    readonly attribute DOMString nativeApiVersion raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The version of the native API in the <em>[Major].[Minor] </em>format.<br/>For example, <var>1.0</var> represents a native api version where the major version is <var>1 </var>and the minor version is <var>0</var>.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="platformName" id="::SystemInfo::SystemInfoDeviceCapability::platformName">
        <webidl>    readonly attribute DOMString platformName;</webidl>
        <descriptive>
            <brief>
 The name of the platform.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="camera" id="::SystemInfo::SystemInfoDeviceCapability::camera">
        <webidl>    readonly attribute boolean camera;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports camera.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="cameraFront" id="::SystemInfo::SystemInfoDeviceCapability::cameraFront">
        <webidl>    readonly attribute boolean cameraFront;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports front camera.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="cameraFrontFlash" id="::SystemInfo::SystemInfoDeviceCapability::cameraFrontFlash">
        <webidl>    readonly attribute boolean cameraFrontFlash;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports flash on the front camera.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="cameraBack" id="::SystemInfo::SystemInfoDeviceCapability::cameraBack">
        <webidl>    readonly attribute boolean cameraBack;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports back-side camera.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="cameraBackFlash" id="::SystemInfo::SystemInfoDeviceCapability::cameraBackFlash">
        <webidl>    readonly attribute boolean cameraBackFlash;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports flash on the back-side camera.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="location" id="::SystemInfo::SystemInfoDeviceCapability::location">
        <webidl>    readonly attribute boolean location;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports CPS or not.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="locationGps" id="::SystemInfo::SystemInfoDeviceCapability::locationGps">
        <webidl>    readonly attribute boolean locationGps;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports GPS based location feature.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="locationWps" id="::SystemInfo::SystemInfoDeviceCapability::locationWps">
        <webidl>    readonly attribute boolean locationWps;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports WPS based location feature.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="microphone" id="::SystemInfo::SystemInfoDeviceCapability::microphone">
        <webidl>    readonly attribute boolean microphone;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports microphone.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="usbHost" id="::SystemInfo::SystemInfoDeviceCapability::usbHost">
        <webidl>    readonly attribute boolean usbHost;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports USB host.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="usbAccessory" id="::SystemInfo::SystemInfoDeviceCapability::usbAccessory">
        <webidl>    readonly attribute boolean usbAccessory;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports USB accessory.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="screenOutputRca" id="::SystemInfo::SystemInfoDeviceCapability::screenOutputRca">
        <webidl>    readonly attribute boolean screenOutputRca;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports RCA output.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="screenOutputHdmi" id="::SystemInfo::SystemInfoDeviceCapability::screenOutputHdmi">
        <webidl>    readonly attribute boolean screenOutputHdmi;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports HDMI output.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="platformCoreCpuArch" id="::SystemInfo::SystemInfoDeviceCapability::platformCoreCpuArch">
        <webidl>    readonly attribute DOMString platformCoreCpuArch;</webidl>
        <descriptive>
            <brief>
 The device CPU architecture.
The possible values for this attribute are: armv6, armv7, x86.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="platformCoreFpuArch" id="::SystemInfo::SystemInfoDeviceCapability::platformCoreFpuArch">
        <webidl>    readonly attribute DOMString platformCoreFpuArch;</webidl>
        <descriptive>
            <brief>
 The device FPU architecture.
The possible values for this attribute are: vfpv3 / sse2 / sse3 / ssse3.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="sipVoip" id="::SystemInfo::SystemInfoDeviceCapability::sipVoip">
        <webidl>    readonly attribute boolean sipVoip;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports VOIP.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="duid" id="::SystemInfo::SystemInfoDeviceCapability::duid">
        <webidl>    readonly attribute DOMString duid;</webidl>
        <descriptive>
            <brief>
 The device unique ID.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="speechRecognition" id="::SystemInfo::SystemInfoDeviceCapability::speechRecognition">
        <webidl>    readonly attribute boolean speechRecognition;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports speech recognition.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="speechSynthesis" id="::SystemInfo::SystemInfoDeviceCapability::speechSynthesis">
        <webidl>    readonly attribute boolean speechSynthesis;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports speech synthesis.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="accelerometer" id="::SystemInfo::SystemInfoDeviceCapability::accelerometer">
        <webidl>    readonly attribute boolean accelerometer;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Accelerometer sensor.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="accelerometerWakeup" id="::SystemInfo::SystemInfoDeviceCapability::accelerometerWakeup">
        <webidl>    readonly attribute boolean accelerometerWakeup;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Accelerometer sensor wake-up feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="barometer" id="::SystemInfo::SystemInfoDeviceCapability::barometer">
        <webidl>    readonly attribute boolean barometer;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Barometer sensor.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="barometerWakeup" id="::SystemInfo::SystemInfoDeviceCapability::barometerWakeup">
        <webidl>    readonly attribute boolean barometerWakeup;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Barometer sensor wake-up feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="gyroscope" id="::SystemInfo::SystemInfoDeviceCapability::gyroscope">
        <webidl>    readonly attribute boolean gyroscope;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Gyroscope sensor.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="gyroscopeWakeup" id="::SystemInfo::SystemInfoDeviceCapability::gyroscopeWakeup">
        <webidl>    readonly attribute boolean gyroscopeWakeup;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Gyroscope sensor wake-up feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="magnetometer" id="::SystemInfo::SystemInfoDeviceCapability::magnetometer">
        <webidl>    readonly attribute boolean magnetometer;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Magnetometer sensor.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="magnetometerWakeup" id="::SystemInfo::SystemInfoDeviceCapability::magnetometerWakeup">
        <webidl>    readonly attribute boolean magnetometerWakeup;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Magnetometer sensor wake-up feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="photometer" id="::SystemInfo::SystemInfoDeviceCapability::photometer">
        <webidl>    readonly attribute boolean photometer;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Photometer sensor.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="photometerWakeup" id="::SystemInfo::SystemInfoDeviceCapability::photometerWakeup">
        <webidl>    readonly attribute boolean photometerWakeup;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Photometer sensor wake-up feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="proximity" id="::SystemInfo::SystemInfoDeviceCapability::proximity">
        <webidl>    readonly attribute boolean proximity;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Proximity sensor.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="proximityWakeup" id="::SystemInfo::SystemInfoDeviceCapability::proximityWakeup">
        <webidl>    readonly attribute boolean proximityWakeup;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Proximity sensor wake-up feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="tiltmeter" id="::SystemInfo::SystemInfoDeviceCapability::tiltmeter">
        <webidl>    readonly attribute boolean tiltmeter;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Tiltmeter sensor.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="tiltmeterWakeup" id="::SystemInfo::SystemInfoDeviceCapability::tiltmeterWakeup">
        <webidl>    readonly attribute boolean tiltmeterWakeup;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports Tiltmeter sensor wake-up feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="dataEncryption" id="::SystemInfo::SystemInfoDeviceCapability::dataEncryption">
        <webidl>    readonly attribute boolean dataEncryption;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports data encryption.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="graphicsAcceleration" id="::SystemInfo::SystemInfoDeviceCapability::graphicsAcceleration">
        <webidl>    readonly attribute boolean graphicsAcceleration;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports hardware acceleration for 2D/3D graphics.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="push" id="::SystemInfo::SystemInfoDeviceCapability::push">
        <webidl>    readonly attribute boolean push;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports push service.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="telephony" id="::SystemInfo::SystemInfoDeviceCapability::telephony">
        <webidl>    readonly attribute boolean telephony;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports the telephony feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="telephonyMms" id="::SystemInfo::SystemInfoDeviceCapability::telephonyMms">
        <webidl>    readonly attribute boolean telephonyMms;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports the mms feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="telephonySms" id="::SystemInfo::SystemInfoDeviceCapability::telephonySms">
        <webidl>    readonly attribute boolean telephonySms;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports the sms feature.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="screenSizeNormal" id="::SystemInfo::SystemInfoDeviceCapability::screenSizeNormal">
        <webidl>    readonly attribute boolean screenSizeNormal;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports the screen normal size.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="screenSize480_800" id="::SystemInfo::SystemInfoDeviceCapability::screenSize480_800">
        <webidl>    readonly attribute boolean screenSize480_800;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports the 480 * 800 screen size.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="screenSize720_1280" id="::SystemInfo::SystemInfoDeviceCapability::screenSize720_1280">
        <webidl>    readonly attribute boolean screenSize720_1280;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports the 720 * 1280 screen size.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="autoRotation" id="::SystemInfo::SystemInfoDeviceCapability::autoRotation">
        <webidl>    readonly attribute boolean autoRotation;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports auto rotation.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="shellAppWidget" id="::SystemInfo::SystemInfoDeviceCapability::shellAppWidget">
        <webidl>    readonly attribute boolean shellAppWidget;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports shell app widget.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="visionImageRecognition" id="::SystemInfo::SystemInfoDeviceCapability::visionImageRecognition">
        <webidl>    readonly attribute boolean visionImageRecognition;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports vision image recognition.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="visionQrcodeGeneration" id="::SystemInfo::SystemInfoDeviceCapability::visionQrcodeGeneration">
        <webidl>    readonly attribute boolean visionQrcodeGeneration;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports vision qrcode generation.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="visionQrcodeRecognition" id="::SystemInfo::SystemInfoDeviceCapability::visionQrcodeRecognition">
        <webidl>    readonly attribute boolean visionQrcodeRecognition;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports vision qrcode recognition.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="visionFaceRecognition" id="::SystemInfo::SystemInfoDeviceCapability::visionFaceRecognition">
        <webidl>    readonly attribute boolean visionFaceRecognition;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports vision face recognition.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="secureElement" id="::SystemInfo::SystemInfoDeviceCapability::secureElement">
        <webidl>    readonly attribute boolean secureElement;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports secure element.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="nativeOspCompatible" id="::SystemInfo::SystemInfoDeviceCapability::nativeOspCompatible">
        <webidl>    readonly attribute boolean nativeOspCompatible;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device supports native osp API.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="profile" id="::SystemInfo::SystemInfoDeviceCapability::profile">
        <webidl>    readonly attribute <ref>SystemInfoProfile</ref> profile;</webidl>
        <descriptive>
            <brief>
 Represents the profile of the current device.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type name="SystemInfoProfile"/>
      </Attribute>
    </Interface>
    <Dictionary name="SystemInfoOptions" id="::SystemInfo::SystemInfoOptions">
      <webidl>  dictionary SystemInfoOptions {
    unsigned long timeout;

    double highThreshold;

    double lowThreshold;
  };</webidl>
      <descriptive>
          <brief>
 An object containing the various options for fetching the properties requested.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <DictionaryMember name="timeout" id="::SystemInfo::SystemInfoOptions::timeout">
        <webidl>    unsigned long timeout;</webidl>
        <descriptive>
            <brief>
 The number of milliseconds beyond which the operation must be interrupted.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </DictionaryMember>
      <DictionaryMember name="highThreshold" id="::SystemInfo::SystemInfoOptions::highThreshold">
        <webidl>    double highThreshold;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate that the <em>successCallback()</em> method in the watch
operation will be triggered only if the device property is a number and its value is greater than or equal to this number.
This attribute has no effect on the <em>get()</em> method.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
      </DictionaryMember>
      <DictionaryMember name="lowThreshold" id="::SystemInfo::SystemInfoOptions::lowThreshold">
        <webidl>    double lowThreshold;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate that the <em>successCallback()</em> method in the watch operation must be triggered only if the property is a number and its value is lower than or equal to this number.
If both <em>highThreshold </em>and <em>lowThreshold </em>parameters are specified, the <em>successCallback()</em> is triggered if and only if the property value is either lower than the value of <em>lowThreshold</em> or higher than the value of <em>highThreshold</em>.
This attribute has no effect on the get method.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
      </DictionaryMember>
    </Dictionary>
    <Interface name="SystemInfoPropertySuccessCallback" id="::SystemInfo::SystemInfoPropertySuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface SystemInfoPropertySuccessCallback {
    void onsuccess(<ref>SystemInfoProperty</ref> prop);
  };</webidl>
      <descriptive>
          <brief>
 Systemfinfo specific success callback.
          </brief>
         <description>
          <p>
This callback interface specifies a success callback with SystemInfoProperty as input argument.
It is used in asynchronous
operations, such as getPropertyValue() or addPropertyValueChangeListener()
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::SystemInfo::SystemInfoPropertySuccessCallback::onsuccess">
        <webidl>    void onsuccess(<ref>SystemInfoProperty</ref> prop);</webidl>
        <descriptive>
            <brief>
 Method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="prop">
            <descriptive>
                <description><p>
 The property returned from a successful asynchronous operation.
                </p></description>
            </descriptive>
            <Type name="SystemInfoProperty"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
    <Interface name="SystemInfoProperty" id="::SystemInfo::SystemInfoProperty">
      <webidl>  [NoInterfaceObject] interface SystemInfoProperty {
  };</webidl>
      <descriptive>
          <brief>
 This is a common abstract interface used by different types of system information objects.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
    </Interface>
    <Interface name="SystemInfoBattery" id="::SystemInfo::SystemInfoBattery">
      <webidl>  [NoInterfaceObject] interface SystemInfoBattery : <ref>SystemInfoProperty</ref> {
    readonly attribute double level;

    readonly attribute boolean isCharging;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the general state of the system's battery
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="level" id="::SystemInfo::SystemInfoBattery::level">
        <webidl>    readonly attribute double level;</webidl>
        <descriptive>
            <brief>
 An attribute to specify the remaining level of an internal battery, scaled from <var>0 </var>to <var>1</var>:
            </brief>
           <description>
            <ul>
              <li>
<var>0 </var>indicates that the battery level is the lowest and the system is about to enter shutdown mode.              </li>
              <li>
<var>1 </var>indicates that the system's charge is maximum.              </li>
            </ul>
            <p>
Any threshold parameter used in a watch operation to monitor this property applies to this attribute.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
      </Attribute>
      <Attribute readonly="readonly" name="isCharging" id="::SystemInfo::SystemInfoBattery::isCharging">
        <webidl>    readonly attribute boolean isCharging;</webidl>
        <descriptive>
            <brief>
 Indicates whether the battery source is currently charging.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoCpu" id="::SystemInfo::SystemInfoCpu">
      <webidl>  [NoInterfaceObject] interface SystemInfoCpu : <ref>SystemInfoProperty</ref> {
    readonly attribute double load;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the state of the CPUs available to this system.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="load" id="::SystemInfo::SystemInfoCpu::load">
        <webidl>    readonly attribute double load;</webidl>
        <descriptive>
            <brief>
  An attribute to indicate the current CPU load, as a number between <var>0.0 </var>and <var>1.0</var>, representing the minimum and maximum values allowed on this system.
Any threshold parameter used in a watch function to monitor this property applies to this attribute.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoStorage" id="::SystemInfo::SystemInfoStorage">
      <webidl>  [NoInterfaceObject] interface SystemInfoStorage : <ref>SystemInfoProperty</ref> {
    readonly attribute <ref>SystemInfoStorageUnit</ref>[] units;
  };</webidl>
      <descriptive>
          <brief>
 This property exposes the data storage devices connected to this system.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="units" id="::SystemInfo::SystemInfoStorage::units">
        <webidl>    readonly attribute <ref>SystemInfoStorageUnit</ref>[] units;</webidl>
        <descriptive>
            <brief>
 The array of storage units connected to this device.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="SystemInfoStorageUnit"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoStorageUnit" id="::SystemInfo::SystemInfoStorageUnit">
      <webidl>  [NoInterfaceObject] interface SystemInfoStorageUnit : <ref>SystemInfoProperty</ref> {
    readonly attribute DOMString type;

    readonly attribute unsigned long long capacity;

    readonly attribute unsigned long long availableCapacity;

    readonly attribute boolean isRemovable;

    readonly attribute boolean isRemoveable;
  };</webidl>
      <descriptive>
          <brief>
 This property exposes a single storage device connected to this system.
          </brief>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="type" id="::SystemInfo::SystemInfoStorageUnit::type">
        <webidl>    readonly attribute DOMString type;</webidl>
        <descriptive>
            <brief>
 The type of a storage device. The value is one of the constants defined for this type.
            </brief>
           <description>
            <p>
The supported storage unit types are:
            </p>
            <ul>
              <li>
UNKNOWN              </li>
              <li>
INTERNAL               </li>
              <li>
USB_HOST              </li>
              <li>
MMC              </li>


            </ul>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="capacity" id="::SystemInfo::SystemInfoStorageUnit::capacity">
        <webidl>    readonly attribute unsigned long long capacity;</webidl>
        <descriptive>
            <brief>
 The amount of data that this device can hold, in bytes.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long long"/>
      </Attribute>
      <Attribute readonly="readonly" name="availableCapacity" id="::SystemInfo::SystemInfoStorageUnit::availableCapacity">
        <webidl>    readonly attribute unsigned long long availableCapacity;</webidl>
        <descriptive>
            <brief>
 The amount of available data that this device can hold, in bytes.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long long"/>
      </Attribute>
      <Attribute readonly="readonly" name="isRemovable" id="::SystemInfo::SystemInfoStorageUnit::isRemovable">
        <webidl>    readonly attribute boolean isRemovable;</webidl>
        <descriptive>
            <brief>
 An attribute to indicate whether a device can be removed or not.
            </brief>
           <description>
            <p>
The following values are supported:
            </p>
            <ul>
              <li>
<var>true </var> - If this storage unit can be removed from the system (such as an sdcard unplugged)              </li>
              <li>
<var>false</var> - If this storage unit cannot be removed from the system              </li>
            </ul>
           </description>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="isRemoveable" id="::SystemInfo::SystemInfoStorageUnit::isRemoveable">
        <webidl>    readonly attribute boolean isRemoveable;</webidl>
        <descriptive>
            <brief>
 true if this unit can be removed from the system (such as an sdcard unplugged), false otherwise.
            </brief>
            <version>
 1.0
            </version>
            <deprecated>
 A typographic error.
            </deprecated>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoDisplay" id="::SystemInfo::SystemInfoDisplay">
      <webidl>  [NoInterfaceObject] interface SystemInfoDisplay : <ref>SystemInfoProperty</ref> {
    readonly attribute unsigned long resolutionWidth;

    readonly attribute unsigned long resolutionHeight;

    readonly attribute unsigned long dotsPerInchWidth;

    readonly attribute unsigned long dotsPerInchHeight;

    readonly attribute double physicalWidth;

    readonly attribute double physicalHeight;

    readonly attribute double brightness;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the information of the Display.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="resolutionWidth" id="::SystemInfo::SystemInfoDisplay::resolutionWidth">
        <webidl>    readonly attribute unsigned long resolutionWidth;</webidl>
        <descriptive>
            <brief>
 The total number of addressable pixels in the horizontal direction of a rectangular entity
(such as Camera, Display, Image, Video, ...) when held in its default orientation.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="resolutionHeight" id="::SystemInfo::SystemInfoDisplay::resolutionHeight">
        <webidl>    readonly attribute unsigned long resolutionHeight;</webidl>
        <descriptive>
            <brief>
 The total number of addressable pixels in the vertical direction of a rectangular element
(such as Camera, Display, Image, Video, ...) when held in its default orientation.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="dotsPerInchWidth" id="::SystemInfo::SystemInfoDisplay::dotsPerInchWidth">
        <webidl>    readonly attribute unsigned long dotsPerInchWidth;</webidl>
        <descriptive>
            <brief>
 Resolution of this device, along its width, in dots per inch.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="dotsPerInchHeight" id="::SystemInfo::SystemInfoDisplay::dotsPerInchHeight">
        <webidl>    readonly attribute unsigned long dotsPerInchHeight;</webidl>
        <descriptive>
            <brief>
 Resolution of this device, along its height, in dots per inch.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned long"/>
      </Attribute>
      <Attribute readonly="readonly" name="physicalWidth" id="::SystemInfo::SystemInfoDisplay::physicalWidth">
        <webidl>    readonly attribute double physicalWidth;</webidl>
        <descriptive>
            <brief>
 The display's physical width in millimeters.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
      </Attribute>
      <Attribute readonly="readonly" name="physicalHeight" id="::SystemInfo::SystemInfoDisplay::physicalHeight">
        <webidl>    readonly attribute double physicalHeight;</webidl>
        <descriptive>
            <brief>
 The display's physical height in millimeters.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
      </Attribute>
      <Attribute readonly="readonly" name="brightness" id="::SystemInfo::SystemInfoDisplay::brightness">
        <webidl>    readonly attribute double brightness;</webidl>
        <descriptive>
            <brief>
 The current brightness of a display ranging between <var>0 </var>to <var>1</var>.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoDeviceOrientation" id="::SystemInfo::SystemInfoDeviceOrientation">
      <webidl>  [NoInterfaceObject] interface SystemInfoDeviceOrientation : <ref>SystemInfoProperty</ref> {

    readonly attribute <ref>SystemInfoDeviceOrientationStatus</ref> status;
    readonly attribute boolean isAutoRotation;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the information of the device orientation in this system.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="status" id="::SystemInfo::SystemInfoDeviceOrientation::status">
        <webidl>    readonly attribute <ref>SystemInfoDeviceOrientationStatus</ref> status;</webidl>
        <descriptive>
            <brief>
 Represents the status of the current device orientation.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="SystemInfoDeviceOrientationStatus"/>
      </Attribute>
      <Attribute readonly="readonly" name="isAutoRotation" id="::SystemInfo::SystemInfoDeviceOrientation::isAutoRotation">
        <webidl>    readonly attribute boolean isAutoRotation;</webidl>
        <descriptive>
            <brief>
 whether the device is in autorotation.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoBuild" id="::SystemInfo::SystemInfoBuild">
      <webidl>  [NoInterfaceObject] interface SystemInfoBuild : <ref>SystemInfoProperty</ref> {

    readonly attribute DOMString model;
    readonly attribute DOMString manufacturer;
    readonly attribute DOMString buildVersion;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the information of the current device.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="model" id="::SystemInfo::SystemInfoBuild::model">
        <webidl>    readonly attribute DOMString model;</webidl>
        <descriptive>
            <brief>
 Represents the model name of the current device.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="manufacturer" id="::SystemInfo::SystemInfoBuild::manufacturer">
        <webidl>    readonly attribute DOMString manufacturer;</webidl>
        <descriptive>
            <brief>
 Represents the manufacturer of the device.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="buildVersion" id="::SystemInfo::SystemInfoBuild::buildVersion">
        <webidl>    readonly attribute DOMString buildVersion;</webidl>
        <descriptive>
            <brief>
 Represents the build version information of the device.
            </brief>
            <version>
 2.2
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoLocale" id="::SystemInfo::SystemInfoLocale">
      <webidl>  [NoInterfaceObject] interface SystemInfoLocale : <ref>SystemInfoProperty</ref> {

    readonly attribute DOMString language;

    readonly attribute DOMString country;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the locale information of the current device.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="language" id="::SystemInfo::SystemInfoLocale::language">
        <webidl>    readonly attribute DOMString language;</webidl>
        <descriptive>
            <brief>
 Indicates the current language setting in the (LANGUAGE)_(REGION) syntax.
The language setting is in the ISO 630-2 format and the region setting is in the ISO 3166-1 format.
The language setting is case-sensitive.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="country" id="::SystemInfo::SystemInfoLocale::country">
        <webidl>    readonly attribute DOMString country;</webidl>
        <descriptive>
            <brief>
 Indicates the current country setting in the (LANGUAGE)_(REGION) syntax.
The language setting is in the ISO 630-2 format and the region setting is in the ISO 3166-1 format.
The country setting is case-sensitive.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoNetwork" id="::SystemInfo::SystemInfoNetwork">
      <webidl>  [NoInterfaceObject] interface SystemInfoNetwork : <ref>SystemInfoProperty</ref> {

    readonly attribute <ref>SystemInfoNetworkType</ref> networkType;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the information of the data network in this system.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="networkType" id="::SystemInfo::SystemInfoNetwork::networkType">
        <webidl>    readonly attribute <ref>SystemInfoNetworkType</ref> networkType;</webidl>
        <descriptive>
            <brief>
 Represents the network type of the current data network.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type name="SystemInfoNetworkType"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoWifiNetwork" id="::SystemInfo::SystemInfoWifiNetwork">
      <webidl>   [NoInterfaceObject] interface SystemInfoWifiNetwork : <ref>SystemInfoProperty</ref> {

    readonly attribute DOMString status;
    readonly attribute DOMString ssid;
    readonly attribute DOMString ipAddress;
     readonly attribute DOMString ipv6Address;
    readonly attribute double signalStrength;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the information of the Wi-Fi network in this system.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="status" id="::SystemInfo::SystemInfoWifiNetwork::status">
        <webidl>    readonly attribute DOMString status;</webidl>
        <descriptive>
            <brief>
 Represents the status (ON or OFF) of the Wi-Fi interface.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="ssid" id="::SystemInfo::SystemInfoWifiNetwork::ssid">
        <webidl>    readonly attribute DOMString ssid;</webidl>
        <descriptive>
            <brief>
 Represents the SSID of a Wi-Fi network.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="ipAddress" id="::SystemInfo::SystemInfoWifiNetwork::ipAddress">
        <webidl>    readonly attribute DOMString ipAddress;</webidl>
        <descriptive>
            <brief>
 Represents the IPv4 address of Wi-Fi network.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="ipv6Address" id="::SystemInfo::SystemInfoWifiNetwork::ipv6Address">
        <webidl>     readonly attribute DOMString ipv6Address;</webidl>
        <descriptive>
            <brief>
 Represents the IPv6 address of Wi-Fi network.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="signalStrength" id="::SystemInfo::SystemInfoWifiNetwork::signalStrength">
        <webidl>    readonly attribute double signalStrength;</webidl>
        <descriptive>
            <brief>
 This connection's signal strength, as a normalized value between 0 (no signal detected) and 1 (the level is at its maximum value).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoCellularNetwork" id="::SystemInfo::SystemInfoCellularNetwork">
      <webidl>  [NoInterfaceObject] interface SystemInfoCellularNetwork : <ref>SystemInfoProperty</ref> {

    readonly attribute DOMString status;
    readonly attribute DOMString apn;
    readonly attribute DOMString ipAddress;
    readonly attribute DOMString ipv6Address;
    readonly attribute unsigned short mcc;
    readonly attribute unsigned short mnc;
    readonly attribute unsigned short cellId;
    readonly attribute unsigned short lac;
    readonly attribute boolean isRoaming;
    readonly attribute boolean isFlightMode;
    readonly attribute DOMString imei raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the information of the Cellular network in this system.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="status" id="::SystemInfo::SystemInfoCellularNetwork::status">
        <webidl>    readonly attribute DOMString status;</webidl>
        <descriptive>
            <brief>
 Represents the status (ON or OFF) of the cellular network.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="apn" id="::SystemInfo::SystemInfoCellularNetwork::apn">
        <webidl>    readonly attribute DOMString apn;</webidl>
        <descriptive>
            <brief>
 Represents an Access Point Name of the cellular network.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="ipAddress" id="::SystemInfo::SystemInfoCellularNetwork::ipAddress">
        <webidl>    readonly attribute DOMString ipAddress;</webidl>
        <descriptive>
            <brief>
 Represents the IPv4 address of the cellular network.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="ipv6Address" id="::SystemInfo::SystemInfoCellularNetwork::ipv6Address">
        <webidl>    readonly attribute DOMString ipv6Address;</webidl>
        <descriptive>
            <brief>
 Represents the IPv6 address of the cellular network.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="mcc" id="::SystemInfo::SystemInfoCellularNetwork::mcc">
        <webidl>    readonly attribute unsigned short mcc;</webidl>
        <descriptive>
            <brief>
 Represents Mobile Country Code (MCC) of the cellular network.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="mnc" id="::SystemInfo::SystemInfoCellularNetwork::mnc">
        <webidl>    readonly attribute unsigned short mnc;</webidl>
        <descriptive>
            <brief>
 Represents Mobile Network Code (MNC) of the cellular network. MNC is used in combination with MCC (also known as a &quot;MCC / MNC tuple&quot;) to uniquely
identify a mobile phone operator/carrier using the GSM, CDMA, iDEN, TETRA and UMTS public land mobile networks and some satellite mobile networks.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="cellId" id="::SystemInfo::SystemInfoCellularNetwork::cellId">
        <webidl>    readonly attribute unsigned short cellId;</webidl>
        <descriptive>
            <brief>
 Represents Cell Id.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="lac" id="::SystemInfo::SystemInfoCellularNetwork::lac">
        <webidl>    readonly attribute unsigned short lac;</webidl>
        <descriptive>
            <brief>
 Represents Location Area Code.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="isRoaming" id="::SystemInfo::SystemInfoCellularNetwork::isRoaming">
        <webidl>    readonly attribute boolean isRoaming;</webidl>
        <descriptive>
            <brief>
 Whether the connection is set up while the device is roaming.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="isFlightMode" id="::SystemInfo::SystemInfoCellularNetwork::isFlightMode">
        <webidl>    readonly attribute boolean isFlightMode;</webidl>
        <descriptive>
            <brief>
 Indicates whether the device is in flight mode.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
      <Attribute readonly="readonly" name="imei" id="::SystemInfo::SystemInfoCellularNetwork::imei">
        <webidl>    readonly attribute DOMString imei raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the International Mobile Equipment Identity (IMEI).
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/systemmanager
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoSIM" id="::SystemInfo::SystemInfoSIM">
      <webidl>  [NoInterfaceObject] interface SystemInfoSIM : <ref>SystemInfoProperty</ref> {
    readonly attribute <ref>SystemInfoSimState</ref> state raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString operatorName raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString msisdn raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString iccid raises(<ref>WebAPIException</ref>);
    readonly attribute unsigned short mcc raises(<ref>WebAPIException</ref>);
    readonly attribute unsigned short mnc raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString msin raises(<ref>WebAPIException</ref>);
    readonly attribute DOMString spn raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the information of the SIM card information.
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="state" id="::SystemInfo::SystemInfoSIM::state">
        <webidl>    readonly attribute <ref>SystemInfoSimState</ref> state raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the SIM card state.
            </brief>
            <version>
 2.1
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type name="SystemInfoSimState"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="operatorName" id="::SystemInfo::SystemInfoSIM::operatorName">
        <webidl>    readonly attribute DOMString operatorName raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the Operator Name String (ONS) of Common PCN Handset Specification (CPHS) in SIM card.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="msisdn" id="::SystemInfo::SystemInfoSIM::msisdn">
        <webidl>    readonly attribute DOMString msisdn raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the SIM card subscriber number.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/systemmanager
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="iccid" id="::SystemInfo::SystemInfoSIM::iccid">
        <webidl>    readonly attribute DOMString iccid raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the Integrated Circuit Card ID.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="mcc" id="::SystemInfo::SystemInfoSIM::mcc">
        <webidl>    readonly attribute unsigned short mcc raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the Mobile Country Code (MCC) of SIM provider.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type type="unsigned short"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="mnc" id="::SystemInfo::SystemInfoSIM::mnc">
        <webidl>    readonly attribute unsigned short mnc raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the Mobile Network Code (MNC) of SIM provider.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type type="unsigned short"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="msin" id="::SystemInfo::SystemInfoSIM::msin">
        <webidl>    readonly attribute DOMString msin raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the Mobile Subscription Identification Number (MSIN) of SIM provider.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 partner
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/systemmanager
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
      <Attribute readonly="readonly" name="spn" id="::SystemInfo::SystemInfoSIM::spn">
        <webidl>    readonly attribute DOMString spn raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Represents the Service Provider Name (SPN) of SIM card.
            </brief>
            <version>
 2.0
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/system
            </privilege>
        </descriptive>
        <Type type="DOMString"/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type SecurityError, if this attribute is not allowed.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Attribute>
    </Interface>
    <Interface name="SystemInfoPeripheral" id="::SystemInfo::SystemInfoPeripheral">
      <webidl>  [NoInterfaceObject] interface SystemInfoPeripheral : <ref>SystemInfoProperty</ref> {

    readonly attribute boolean isVideoOutputOn;
  };</webidl>
      <descriptive>
          <brief>
 This property reflects the peripheral information of the current device.
          </brief>
          <version>
 2.1
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="SystemInfoProperty"/>
      </InterfaceInheritance>
      <Attribute readonly="readonly" name="isVideoOutputOn" id="::SystemInfo::SystemInfoPeripheral::isVideoOutputOn">
        <webidl>    readonly attribute boolean isVideoOutputOn;</webidl>
        <descriptive>
            <brief>
 Represents the video out status.
            </brief>
            <version>
 2.1
            </version>
        </descriptive>
        <Type type="boolean"/>
      </Attribute>
    </Interface>
  </Module>
  <Module name="SystemSetting" id="::SystemSetting">
    <webidl>module SystemSetting {

  [NoInterfaceObject] interface SystemSettingObject {
    readonly attribute <ref>SystemSettingManager</ref> systemsetting;
  };
    <ref>Tizen</ref> implements <ref>SystemSettingObject</ref>;

  enum SystemSettingType {&quot;HOME_SCREEN&quot;, &quot;LOCK_SCREEN&quot;, &quot;INCOMING_CALL&quot;, &quot;NOTIFICATION_EMAIL&quot;};

  [NoInterfaceObject] interface SystemSettingManager {

     void setProperty(<ref>SystemSettingType</ref> type,
              DOMString value,
              <ref>SuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);

     void getProperty(<ref>SystemSettingType</ref> type,
              <ref>SystemSettingSuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);

  };

  [Callback=FunctionOnly, NoInterfaceObject] interface SystemSettingSuccessCallback {
    void onsuccess(DOMString value);
  };

};</webidl>
    <descriptive>
        <brief>
 This API provides interfaces and methods providing Web applications with access to various values of the system.
        </brief>
       <description>
        <p>
This API provides an interface and method through features such as:
        </p>
        <ul>
          <li>
 HOME_SCREEN          </li>
          <li>
 LOCK_SCREEN          </li>
          <li>
 INCOMING_CALL          </li>
          <li>
 NOTIFICATION_EMAIL          </li>
        </ul>
        <p>
For more information on the SystemSetting features, see <a href="../../org.tizen.web.appprogramming/html/guide/sys_guide/systemsetting.htm">System Setting Guide</a>.
        </p>
       </description>
        <version>
 2.0
        </version>
    </descriptive>
    <Interface name="SystemSettingObject" id="::SystemSetting::SystemSettingObject">
      <webidl>  [NoInterfaceObject] interface SystemSettingObject {
    readonly attribute <ref>SystemSettingManager</ref> systemsetting;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated by the <em>Tizen </em>object from the Tizen Platform.
          </brief>
         <description>
          <p>
There will be a <em>tizen.systemsetting </em>object that allows accessing the functionality of the SystemSetting API.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="systemsetting" id="::SystemSetting::SystemSettingObject::systemsetting">
        <webidl>    readonly attribute <ref>SystemSettingManager</ref> systemsetting;</webidl>
        <Type name="SystemSettingManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="SystemSettingObject">
      <webidl>    <ref>Tizen</ref> implements <ref>SystemSettingObject</ref>;</webidl>
    </Implements>
    <Enum name="SystemSettingType" id="::SystemSetting::SystemSettingType">
      <webidl>  enum SystemSettingType {&quot;HOME_SCREEN&quot;, &quot;LOCK_SCREEN&quot;, &quot;INCOMING_CALL&quot;, &quot;NOTIFICATION_EMAIL&quot;};</webidl>
      <descriptive>
          <brief>
 This enumerator indicates the type of supported system setting.
The following values are supported in this release:
          </brief>
         <description>
          <ul>
            <li>
HOME_SCREEN - For homescreen background image.            </li>
            <li>
LOCK_SCREEN - For lockscreen background image.            </li>
            <li>
INCOMING_CALL - For incoming call ringtone.            </li>
            <li>
NOTIFICATION_EMAIL - For email notification alert tone.            </li>
          </ul>
          <p>
Defines supporting setting types.
The HOME_SCREEN and LOCK_SCREEN are supported for images files.
The INCOMING_CALL and NOTIFICATION_EMAIL are support for sound files.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <EnumValue stringvalue="HOME_SCREEN">
        <webidl>&quot;HOME_SCREEN</webidl>
      </EnumValue>
      <EnumValue stringvalue="LOCK_SCREEN">
        <webidl> &quot;LOCK_SCREEN</webidl>
      </EnumValue>
      <EnumValue stringvalue="INCOMING_CALL">
        <webidl> &quot;INCOMING_CALL</webidl>
      </EnumValue>
      <EnumValue stringvalue="NOTIFICATION_EMAIL">
        <webidl> &quot;NOTIFICATION_EMAIL</webidl>
      </EnumValue>
    </Enum>
    <Interface name="SystemSettingManager" id="::SystemSetting::SystemSettingManager">
      <webidl>  [NoInterfaceObject] interface SystemSettingManager {

     void setProperty(<ref>SystemSettingType</ref> type,
              DOMString value,
              <ref>SuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);

     void getProperty(<ref>SystemSettingType</ref> type,
              <ref>SystemSettingSuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);

  };</webidl>
      <descriptive>
          <brief>
 This is the top-level interface for the SystemSetting API that provides
access to the module functionalities.
          </brief>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="setProperty" id="::SystemSetting::SystemSettingManager::setProperty">
        <webidl>     void setProperty(<ref>SystemSettingType</ref> type,
              DOMString value,
              <ref>SuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the property of a device.
            </brief>
           <description>
            <p>
This method allows the user to set the image or sound file specified as an input parameter as the wallpaper or ringtone of a device.
            </p>
           </description>
            <version>
 2.0
            </version>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
TypeMismatchError - If any input parameter is not compatible with the expected type for that parameter.               </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/setting
            </privilege>
            <Code> // Define the success callback
 function successCallback() {
   console.log(&quot;Success to setProperty&quot;);
 }

 // Define the error callback.
 function errorCallback(error) {
   console.log(&quot;Fail to setProperty&quot; + error.message);
 }

 tizen.systemsetting.setProperty(&quot;HOME_SCREEN&quot;, &quot;/opt/usr/media/Images/image1.jpg&quot;, successCallback, errorCallback);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="type">
            <descriptive>
                <description><p>
 The setting type to set.
                </p></description>
            </descriptive>
            <Type name="SystemSettingType"/>
          </Argument>
          <Argument name="value">
            <descriptive>
                <description><p>
 The location path of a wallpaper or ringtone file.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 To be invoked if the setting value is successfully set.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 To be invoked if the setting value cannot be set.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if this functionality is not allowed.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getProperty" id="::SystemSetting::SystemSettingManager::getProperty">
        <webidl>     void getProperty(<ref>SystemSettingType</ref> type,
              <ref>SystemSettingSuccessCallback</ref> successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
  Gets the value of the property of a device.
            </brief>
           <description>
            <p>
This method allows the user to get the value of the specified system property as wallpaper or ringtone of a device.
            </p>
           </description>
            <version>
 2.0
            </version>
           <description>
            <p>
The ErrorCallback is launched with these error types:
            </p>
            <ul>
              <li>
TypeMismatchError - If any input parameter is not compatible with the expected type for that parameter.               </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
              <li>
UnknownError - If any other error occurs.              </li>
            </ul>
           </description>
            <Code> // Define the success callback
 function getPropertySuccessCallback(value) {
   console.log(&quot;Success to getProperty : &quot; + value);
 }

 // Define the error callback.
 function errorCallback(error) {
   console.log(&quot;Fail to getProperty&quot; + error.message);
 }

 tizen.systemsetting.getProperty(&quot;HOME_SCREEN&quot;, getPropertySuccessCallback, errorCallback);

 </Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="type">
            <descriptive>
                <description><p>
 The type of the property to get.
                </p></description>
            </descriptive>
            <Type name="SystemSettingType"/>
          </Argument>
          <Argument name="successCallback">
            <descriptive>
                <description><p>
 To be invoked if the setting value is successfully retrieved.
                </p></description>
            </descriptive>
            <Type name="SystemSettingSuccessCallback"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 To be invoked if the setting value cannot be retrieved.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type InvalidValuesError, if any of the input parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type NotSupportedError, if this feature is not supported.
                </p></description>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError in any other error case.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="SystemSettingSuccessCallback" id="::SystemSetting::SystemSettingSuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject] interface SystemSettingSuccessCallback {
    void onsuccess(DOMString value);
  };</webidl>
      <descriptive>
          <brief>
 The success callback for getProperty().
          </brief>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::SystemSetting::SystemSettingSuccessCallback::onsuccess">
        <webidl>    void onsuccess(DOMString value);</webidl>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="value">
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="Time" id="::Time">
    <webidl>module Time {

  enum TimeDurationUnit { &quot;MSECS&quot;, &quot;SECS&quot;, &quot;MINS&quot;, &quot;HOURS&quot;, &quot;DAYS&quot; };

  [NoInterfaceObject] interface TimeManagerObject {
    readonly attribute <ref>TimeUtil</ref> time;
  };
  <ref>Tizen</ref> implements <ref>TimeManagerObject</ref>;

  [NoInterfaceObject] interface TimeUtil {
    <ref>TZDate</ref> getCurrentDateTime() raises(<ref>WebAPIException</ref>);

    DOMString getLocalTimezone() raises(<ref>WebAPIException</ref>);

    DOMString[] getAvailableTimezones() raises(<ref>WebAPIException</ref>);

    DOMString getDateFormat(optional boolean? shortformat) raises(<ref>WebAPIException</ref>);

    DOMString getTimeFormat() raises(<ref>WebAPIException</ref>);

    boolean isLeapYear(long year) raises(<ref>WebAPIException</ref>);
  };


  [Constructor(optional Date? datetime, optional DOMString? timezone),
   Constructor(long year, long month, long day, optional long? hours, optional long? minutes, optional long? seconds, optional long? milliseconds, optional DOMString? timezone)]

  interface TZDate {
    long getDate();

    void setDate(long date);

    long getDay();

    long getFullYear();

    void setFullYear(long year);

    long getHours();

    void setHours(long hours);

    long getMilliseconds();

    void setMilliseconds(long ms);

    long getMinutes();

    void setMinutes(long minutes);

    long getMonth();

    void setMonth(long month);

    long getSeconds();

    void setSeconds(long seconds);

    long getUTCDate();

    void setUTCDate(long date);

    long getUTCDay();

    long getUTCFullYear();

    void setUTCFullYear(long year);

    long getUTCHours();

    void setUTCHours(long hours);

    long getUTCMilliseconds();

    void setUTCMilliseconds(long ms);

    long getUTCMinutes();

    void setUTCMinutes(long minutes);

    long getUTCMonth();

    void setUTCMonth(long month);

    long getUTCSeconds();

    void setUTCSeconds(long seconds);

    DOMString getTimezone();

    <ref>TZDate</ref> toTimezone(DOMString tzid) raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref> toLocalTimezone() raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref> toUTC() raises(<ref>WebAPIException</ref>);

    <ref>TimeDuration</ref> difference(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);

    boolean equalsTo(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);

    boolean earlierThan(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);

    boolean laterThan(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref> addDuration(<ref>TimeDuration</ref> duration) raises(<ref>WebAPIException</ref>);

    DOMString toLocaleDateString();

    DOMString toLocaleTimeString();

    DOMString toLocaleString();

    DOMString toDateString();

    DOMString toTimeString();

    DOMString toString();

    DOMString getTimezoneAbbreviation() raises(<ref>WebAPIException</ref>);

    long secondsFromUTC() raises(<ref>WebAPIException</ref>);

    boolean isDST() raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref>? getPreviousDSTTransition() raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref>? getNextDSTTransition() raises(<ref>WebAPIException</ref>);
  };

  [Constructor(long long length, optional <ref>TimeDurationUnit</ref>? unit)]
  interface TimeDuration
  {
    attribute long long length;

    attribute <ref>TimeDurationUnit</ref> unit;

    <ref>TimeDuration</ref> difference(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);

    boolean equalsTo(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);

    boolean lessThan(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);

    boolean greaterThan(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);
  };
};</webidl>
    <descriptive>
        <brief>
  The Time API provides information regarding date / time and time zones.
        </brief>
        <version>
 1.0
        </version>
       <description>
        <p>
The JavaScript Date object does not have full timezone support.
Date objects allow only simple representations to denote a particular location's
offset from Universal Coordinated Time (UTC). This is typically provided as a +/-
offset from UTC-0 (also known as Greenwich Mean Time, or GMT) for example, +05:30 denotes
that a location is 5 hours and 30 minutes ahead of UTC +00:00.
The issue with this method is not getting the correct
local time for a given date. The existing methods are sufficient for this purpose.
The issue is correctly converting to and from local time and UTC for all points in
time - in any of the past, present, and future - based on an initial time provided.
This is important for defining relative dates, where a time in a given location may
observe different UTC offsets, according to any Daylight Savings Rules (DST) in effect
or any other changes that may occur to a location's time zone over time.
Without the communication of the explicit time zone rules governing a given date and
time, the ability to effectively calculate the offset of the local time to UTC or to
any other time zone at any point in the past or future is lost.
        </p>
        <p>
This API can be used to get TZDate objects with full time zone support, convert them
between timezones, retrieve available timezones.
        </p>
        <p>
For more information on the Time features, see <a href="../../org.tizen.web.appprogramming/html/guide/sys_guide/time.htm">Time Guide</a>.
        </p>
       </description>
    </descriptive>
    <Enum name="TimeDurationUnit" id="::Time::TimeDurationUnit">
      <webidl>  enum TimeDurationUnit { &quot;MSECS&quot;, &quot;SECS&quot;, &quot;MINS&quot;, &quot;HOURS&quot;, &quot;DAYS&quot; };</webidl>
      <descriptive>
          <brief>
 TimeDuration unit (milliseconds, seconds, minutes, hours or days).
          </brief>
         <description>
          <p>
At least the following values must be supported:
          </p>
          <ul>
            <li>
MSECS - Indicates a duration in milliseconds            </li>
            <li>
SECS - Indicates a duration in seconds             </li>
            <li>
MINS - Indicates a duration in minutes             </li>
            <li>
HOURS - Indicates a duration in hours             </li>
            <li>
DAYS - Indicates a duration in days            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="MSECS">
        <webidl> &quot;MSECS</webidl>
      </EnumValue>
      <EnumValue stringvalue="SECS">
        <webidl> &quot;SECS</webidl>
      </EnumValue>
      <EnumValue stringvalue="MINS">
        <webidl> &quot;MINS</webidl>
      </EnumValue>
      <EnumValue stringvalue="HOURS">
        <webidl> &quot;HOURS</webidl>
      </EnumValue>
      <EnumValue stringvalue="DAYS">
        <webidl> &quot;DAYS</webidl>
      </EnumValue>
    </Enum>
    <Interface name="TimeManagerObject" id="::Time::TimeManagerObject">
      <webidl>  [NoInterfaceObject] interface TimeManagerObject {
    readonly attribute <ref>TimeUtil</ref> time;
  };</webidl>
      <descriptive>
          <brief>
 Defines what is instantiated in the tizen object by the Tizen Platform.
          </brief>
         <description>
          <p>
There will be a tizen.time object that allows accessing the
functionality of the Time API.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="time" id="::Time::TimeManagerObject::time">
        <webidl>    readonly attribute <ref>TimeUtil</ref> time;</webidl>
        <Type name="TimeUtil"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="TimeManagerObject">
      <webidl>  <ref>Tizen</ref> implements <ref>TimeManagerObject</ref>;</webidl>
    </Implements>
    <Interface name="TimeUtil" id="::Time::TimeUtil">
      <webidl>  [NoInterfaceObject] interface TimeUtil {
    <ref>TZDate</ref> getCurrentDateTime() raises(<ref>WebAPIException</ref>);

    DOMString getLocalTimezone() raises(<ref>WebAPIException</ref>);

    DOMString[] getAvailableTimezones() raises(<ref>WebAPIException</ref>);

    DOMString getDateFormat(optional boolean? shortformat) raises(<ref>WebAPIException</ref>);

    DOMString getTimeFormat() raises(<ref>WebAPIException</ref>);

    boolean isLeapYear(long year) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The TimeUtil class that provides access to the time API.
          </brief>
         <description>
          <p>
This interface offers methods to manage date / time as well as timezones such as:
          </p>
          <ul>
            <li>
Get the current date / time using getCurrentDateTime().            </li>
            <li>
Get timezones using getLocalTimezone() and getAvailableTimezones().            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getCurrentDateTime" id="::Time::TimeUtil::getCurrentDateTime">
        <webidl>    <ref>TZDate</ref> getCurrentDateTime() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns the current date / time.
            </brief>
            <version>
 1.0
            </version>
            <Code> var current_dt = tizen.time.getCurrentDateTime();
 console.log(&quot;current date / time is &quot; + current_dt.toLocaleString());
 </Code>
        </descriptive>
        <Type name="TZDate">
          <descriptive>
              <description><p>
 TZDate Current TZDate object.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getLocalTimezone" id="::Time::TimeUtil::getLocalTimezone">
        <webidl>    DOMString getLocalTimezone() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns identifier of the local system timezone.
            </brief>
            <version>
 1.0
            </version>
            <Code> console.log(&quot;The local time zone is &quot; + tizen.time.getLocalTimezone());
 </Code>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 Timezone Local timezone.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getAvailableTimezones" id="::Time::TimeUtil::getAvailableTimezones">
        <webidl>    DOMString[] getAvailableTimezones() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns synchronously the identifiers of the timezones supported by the device.
            </brief>
           <description>
            <p>
Zero or more slashes separate different components of a timezone identifier,
with the most general descriptor first and the most specific one last. For example,
'Europe/Berlin', 'America/Argentina/Buenos_Aires'.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var tzids = tizen.time.getAvailableTimezones();
 console.log(&quot;The device supports &quot; + tzids.length + &quot; time zones.&quot;);
 </Code>
        </descriptive>
        <Type type="array">
          <descriptive>
              <description><p>
 Array of time zone identifiers.
              </p></description>
          </descriptive>
          <Type type="DOMString"/>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getDateFormat" id="::Time::TimeUtil::getDateFormat">
        <webidl>    DOMString getDateFormat(optional boolean? shortformat) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
           <description>
            <p>
Returns the date format according to the system's locale settings.
            </p>
            <p>
These expressions may be used in the returned string:
            </p>
            <ul>
              <li>
&quot;d&quot; = day number (1 to 31)              </li>
              <li>
&quot;D&quot; = day name              </li>
              <li>
&quot;m&quot; = month number (1 to 12)              </li>
              <li>
&quot;M&quot; = month name              </li>
              <li>
&quot;y&quot; = year              </li>
            </ul>
            <p>
Examples of string formats include: &quot;d/m/y&quot;, &quot;y-d-m&quot;, &quot;D, M d y&quot;.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The date format according to the system's locale settings.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument optional="optional" name="shortformat">
            <descriptive>
                <description><p>
 Flag indicating if the user is interested in the short
date format (23/10/2011) instead of a long date format (&quot;Monday, October 23 2011&quot;).
By default, this attribute is set to false.
                </p></description>
            </descriptive>
            <Type type="boolean" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getTimeFormat" id="::Time::TimeUtil::getTimeFormat">
        <webidl>    DOMString getTimeFormat() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
           <description>
            <p>
Returns the time format according to the system's locale settings.
            </p>
            <p>
These expressions may be used in the returned string:
            </p>
            <ul>
              <li>
&quot;h&quot; = hours (0 to 23 or 1 to 12 if AM/PM display)              </li>
              <li>
&quot;m&quot; = minutes (0 to 59)              </li>
              <li>
&quot;s&quot; = seconds (0 to 59)              </li>
              <li>
&quot;ap&quot; = AM/PM display              </li>
            </ul>
            <p>
Examples of string formats include: &quot;h:m:s ap&quot;, &quot;h:m:s&quot;.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString The time format according to the system's locale settings.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="isLeapYear" id="::Time::TimeUtil::isLeapYear">
        <webidl>    boolean isLeapYear(long year) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns <em>true</em> if the given year is a leap year.
            </brief>
            <version>
 1.0
            </version>
            <Code> var current_dt = tizen.time.getCurrentDateTime();
 var is_leap = tizen.time.isLeapYear(current_dt.getFullYear());
 if (is_leap)
   console.log(&quot;This year is a leap year.&quot;);
 </Code>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean <em>true</em>, if the year is a leap year.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="year">
            <descriptive>
                <description><p>
 Year to check.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if any of the input
parameters contain an invalid value.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="TZDate" id="::Time::TZDate">
      <webidl>  [Constructor(optional Date? datetime, optional DOMString? timezone),
   Constructor(long year, long month, long day, optional long? hours, optional long? minutes, optional long? seconds, optional long? milliseconds, optional DOMString? timezone)]

  interface TZDate {
    long getDate();

    void setDate(long date);

    long getDay();

    long getFullYear();

    void setFullYear(long year);

    long getHours();

    void setHours(long hours);

    long getMilliseconds();

    void setMilliseconds(long ms);

    long getMinutes();

    void setMinutes(long minutes);

    long getMonth();

    void setMonth(long month);

    long getSeconds();

    void setSeconds(long seconds);

    long getUTCDate();

    void setUTCDate(long date);

    long getUTCDay();

    long getUTCFullYear();

    void setUTCFullYear(long year);

    long getUTCHours();

    void setUTCHours(long hours);

    long getUTCMilliseconds();

    void setUTCMilliseconds(long ms);

    long getUTCMinutes();

    void setUTCMinutes(long minutes);

    long getUTCMonth();

    void setUTCMonth(long month);

    long getUTCSeconds();

    void setUTCSeconds(long seconds);

    DOMString getTimezone();

    <ref>TZDate</ref> toTimezone(DOMString tzid) raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref> toLocalTimezone() raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref> toUTC() raises(<ref>WebAPIException</ref>);

    <ref>TimeDuration</ref> difference(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);

    boolean equalsTo(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);

    boolean earlierThan(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);

    boolean laterThan(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref> addDuration(<ref>TimeDuration</ref> duration) raises(<ref>WebAPIException</ref>);

    DOMString toLocaleDateString();

    DOMString toLocaleTimeString();

    DOMString toLocaleString();

    DOMString toDateString();

    DOMString toTimeString();

    DOMString toString();

    DOMString getTimezoneAbbreviation() raises(<ref>WebAPIException</ref>);

    long secondsFromUTC() raises(<ref>WebAPIException</ref>);

    boolean isDST() raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref>? getPreviousDSTTransition() raises(<ref>WebAPIException</ref>);

    <ref>TZDate</ref>? getNextDSTTransition() raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The TZDate object represents information regarding a given
date / time in a predefined timezone.
If its date / time is exceed the platform limit, TZDate will be invalid.
          </brief>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(optional Date? datetime, optional DOMString? timezone)</webidl>
          <ArgumentList>
            <Argument optional="optional" name="datetime">
              <Type type="Date" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="timezone">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
        <ExtendedAttribute name="Constructor">
          <webidl>   Constructor(long year, long month, long day, optional long? hours, optional long? minutes, optional long? seconds, optional long? milliseconds, optional DOMString? timezone)</webidl>
          <descriptive>
             <description>
              <ul>
                <li>
<b>year</b> : The year of TZDate. If it is between 0 and 99, 1900 will be added to it like Javascript Date object.                </li>
              </ul>
             </description>
          </descriptive>
          <ArgumentList>
            <Argument name="year">
              <Type type="long"/>
            </Argument>
            <Argument name="month">
              <Type type="long"/>
            </Argument>
            <Argument name="day">
              <Type type="long"/>
            </Argument>
            <Argument optional="optional" name="hours">
              <Type type="long" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="minutes">
              <Type type="long" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="seconds">
              <Type type="long" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="milliseconds">
              <Type type="long" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="timezone">
              <Type type="DOMString" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="getDate" id="::Time::TZDate::getDate">
        <webidl>    long getDate();</webidl>
        <descriptive>
            <brief>
 Returns the day of the month (from 1-31).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The day of the month.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setDate" id="::Time::TZDate::setDate">
        <webidl>    void setDate(long date);</webidl>
        <descriptive>
            <brief>
 Sets the day of the month (from 1-31).
            </brief>
           <description>
            <p>
If it tries to set the day bigger than the last day of the month or smaller than 1, it will be calculated automatically.
For example, if TZDate's month is May and parameter is 32, it will be June 1.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="date">
            <descriptive>
                <description><p>
 Date to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getDay" id="::Time::TZDate::getDay">
        <webidl>    long getDay();</webidl>
        <descriptive>
            <brief>
 Returns the day of the week (from 0-6).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The day of the week.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="getFullYear" id="::Time::TZDate::getFullYear">
        <webidl>    long getFullYear();</webidl>
        <descriptive>
            <brief>
 Returns the year.
            </brief>
           <description>
            <p>
Positive values indicate AD(Anno Domini) years. 0 and negative values indicate BC(Before Christ) years.
For example, 1 = AD 1, 0 = BC 1, -1 = BC 2.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The year.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setFullYear" id="::Time::TZDate::setFullYear">
        <webidl>    void setFullYear(long year);</webidl>
        <descriptive>
            <brief>
 Sets the year.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="year">
            <descriptive>
                <description><p>
 Year to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getHours" id="::Time::TZDate::getHours">
        <webidl>    long getHours();</webidl>
        <descriptive>
            <brief>
 Returns the hour (0-23).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The hour.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setHours" id="::Time::TZDate::setHours">
        <webidl>    void setHours(long hours);</webidl>
        <descriptive>
            <brief>
 Sets the hour (0-23).
            </brief>
           <description>
            <p>
If it tries to set the hour bigger than 23 or smaller than 0, it will be calculated automatically.
For example, if hours is 24, it will set 0 and add to a date.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="hours">
            <descriptive>
                <description><p>
 Hours to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getMilliseconds" id="::Time::TZDate::getMilliseconds">
        <webidl>    long getMilliseconds();</webidl>
        <descriptive>
            <brief>
 Returns the milliseconds (from 0-999).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The milliseconds.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setMilliseconds" id="::Time::TZDate::setMilliseconds">
        <webidl>    void setMilliseconds(long ms);</webidl>
        <descriptive>
            <brief>
 Sets the milliseconds (from 0-999).
            </brief>
           <description>
            <p>
If it tries to set the millisecond bigger than 999 or smaller than 0, it will be calculated automatically.
For example, if ms is 1000, it will set 0 and add to a second.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="ms">
            <descriptive>
                <description><p>
 Milliseconds to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getMinutes" id="::Time::TZDate::getMinutes">
        <webidl>    long getMinutes();</webidl>
        <descriptive>
            <brief>
 Returns the minutes (from 0-59).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The minutes.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setMinutes" id="::Time::TZDate::setMinutes">
        <webidl>    void setMinutes(long minutes);</webidl>
        <descriptive>
            <brief>
 Sets the minutes.
            </brief>
           <description>
            <p>
If it tries to set the minute bigger than 59 or smaller than 0, it will be calculated automatically.
For example, if minutes is 60, it will set 0 and add to an hour.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="minutes">
            <descriptive>
                <description><p>
 Minutes to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getMonth" id="::Time::TZDate::getMonth">
        <webidl>    long getMonth();</webidl>
        <descriptive>
            <brief>
 Returns the month (from 0-11).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The month.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setMonth" id="::Time::TZDate::setMonth">
        <webidl>    void setMonth(long month);</webidl>
        <descriptive>
            <brief>
 Sets the month (from 0-11).
            </brief>
           <description>
            <p>
If it tries to set the month bigger than 11 or smaller than 0, it will be calculated automatically.
For example, if month is 12, it will set 0 and add to a year.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="month">
            <descriptive>
                <description><p>
 Month to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getSeconds" id="::Time::TZDate::getSeconds">
        <webidl>    long getSeconds();</webidl>
        <descriptive>
            <brief>
 Returns the seconds (from 0-59).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The seconds.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setSeconds" id="::Time::TZDate::setSeconds">
        <webidl>    void setSeconds(long seconds);</webidl>
        <descriptive>
            <brief>
 Sets the seconds (from 0-59).
            </brief>
           <description>
            <p>
If it tries to set the second bigger than 59 or smaller than 0, it will be calculated automatically.
For example, if seconds is 60, it will set 0 and add to a minute.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="seconds">
            <descriptive>
                <description><p>
 Seconds to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getUTCDate" id="::Time::TZDate::getUTCDate">
        <webidl>    long getUTCDate();</webidl>
        <descriptive>
            <brief>
 Returns the day of the month, according to universal time (from 1-31).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The day of the month, according to universal time.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setUTCDate" id="::Time::TZDate::setUTCDate">
        <webidl>    void setUTCDate(long date);</webidl>
        <descriptive>
            <brief>
 Sets the day of the month, according to universal time (from 1-31).
            </brief>
           <description>
            <p>
If it tries to set the day bigger than the last day of the month or smaller than 1, it will be calculated automatically.
For example, if TZDate's month is May and date is 32, it will be June 1.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="date">
            <descriptive>
                <description><p>
 Date to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getUTCDay" id="::Time::TZDate::getUTCDay">
        <webidl>    long getUTCDay();</webidl>
        <descriptive>
            <brief>
 Returns the day of the week, according to universal time (from 0-6).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The day of the week, according to universal time.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="getUTCFullYear" id="::Time::TZDate::getUTCFullYear">
        <webidl>    long getUTCFullYear();</webidl>
        <descriptive>
            <brief>
 Returns the year, according to universal time.
            </brief>
           <description>
            <p>
Positive values indicate AD(Anno Domini) years. 0 and negative values indicate BC(Before Christ) years.
For example, 1 = AD 1, 0 = BC 1, -1 = BC 2.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The year, according to universal time.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setUTCFullYear" id="::Time::TZDate::setUTCFullYear">
        <webidl>    void setUTCFullYear(long year);</webidl>
        <descriptive>
            <brief>
 Sets the year, according to universal time.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="year">
            <descriptive>
                <description><p>
 Year to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getUTCHours" id="::Time::TZDate::getUTCHours">
        <webidl>    long getUTCHours();</webidl>
        <descriptive>
            <brief>
 Returns the hour, according to universal time (0-23).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The hour, according to universal time.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setUTCHours" id="::Time::TZDate::setUTCHours">
        <webidl>    void setUTCHours(long hours);</webidl>
        <descriptive>
            <brief>
 Sets the hour, according to universal time (0-23).
            </brief>
           <description>
            <p>
If it tries to set the hour bigger than 23 or smaller than 0, it will be calculated automatically.
For example, if hours is 24, it will set 0 and add to a date.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="hours">
            <descriptive>
                <description><p>
 Hours to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getUTCMilliseconds" id="::Time::TZDate::getUTCMilliseconds">
        <webidl>    long getUTCMilliseconds();</webidl>
        <descriptive>
            <brief>
 Returns the milliseconds, according to universal time (from 0-999).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The milliseconds, according to universal time.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setUTCMilliseconds" id="::Time::TZDate::setUTCMilliseconds">
        <webidl>    void setUTCMilliseconds(long ms);</webidl>
        <descriptive>
            <brief>
 Sets the milliseconds, according to universal time (from 0-999).
            </brief>
           <description>
            <p>
If it tries to set the millisecond bigger than 999 or smaller than 0, it will be calculated automatically.
For example, if ms is 1000, it will set 0 and add to a second.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="ms">
            <descriptive>
                <description><p>
 Milliseconds to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getUTCMinutes" id="::Time::TZDate::getUTCMinutes">
        <webidl>    long getUTCMinutes();</webidl>
        <descriptive>
            <brief>
 Returns the minutes, according to universal time (from 0-59).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The minutes, according to universal time.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setUTCMinutes" id="::Time::TZDate::setUTCMinutes">
        <webidl>    void setUTCMinutes(long minutes);</webidl>
        <descriptive>
            <brief>
 Sets the minutes, according to universal time (from 0-59).
            </brief>
           <description>
            <p>
If it tries to set the minute bigger than 59 or smaller than 0, it will be calculated automatically.
For example, if minutes is 60, it will set 0 and add to an hour.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="minutes">
            <descriptive>
                <description><p>
 Minutes to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getUTCMonth" id="::Time::TZDate::getUTCMonth">
        <webidl>    long getUTCMonth();</webidl>
        <descriptive>
            <brief>
 Returns the month, according to universal time (from 0-11).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The month, according to universal time.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setUTCMonth" id="::Time::TZDate::setUTCMonth">
        <webidl>    void setUTCMonth(long month);</webidl>
        <descriptive>
            <brief>
 Sets the month, according to universal time (from 0-11).
            </brief>
           <description>
            <p>
If it tries to set the month bigger than 11 or smaller than 0, it will be calculated automatically.
For example, if month is 12, it will set 0 and add to a year.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="month">
            <descriptive>
                <description><p>
 Month to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getUTCSeconds" id="::Time::TZDate::getUTCSeconds">
        <webidl>    long getUTCSeconds();</webidl>
        <descriptive>
            <brief>
 Returns the seconds, according to universal time (from 0-59).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long The seconds, according to universal time.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="setUTCSeconds" id="::Time::TZDate::setUTCSeconds">
        <webidl>    void setUTCSeconds(long seconds);</webidl>
        <descriptive>
            <brief>
 Sets the seconds, according to universal time (from 0-59).
            </brief>
           <description>
            <p>
If it tries to set the second bigger than 59 or smaller than 0, it will be calculated automatically.
For example, if seconds is 60, it will set 0 and add to a minute.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="seconds">
            <descriptive>
                <description><p>
 Seconds to set.
                </p></description>
            </descriptive>
            <Type type="long"/>
          </Argument>
        </ArgumentList>
      </Operation>
      <Operation name="getTimezone" id="::Time::TZDate::getTimezone">
        <webidl>    DOMString getTimezone();</webidl>
        <descriptive>
            <brief>
 Returns timezone identifier.
            </brief>
           <description>
            <p>
Zero or more slashes separate different components, with the most general
descriptor first and the most specific one last. For example,
'Europe/Berlin', 'America/Argentina/Buenos_Aires'.
            </p>
            <p>
This attribute uniquely identifies the timezone.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString String timezone identifier. If TZDate is invalid, it will return 'Invalid Date'.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="toTimezone" id="::Time::TZDate::toTimezone">
        <webidl>    <ref>TZDate</ref> toTimezone(DOMString tzid) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns a copy of the TZDate converted to a given time zone.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TZDate">
          <descriptive>
              <description><p>
 TZDate New TZDate in given Timezone.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="tzid">
            <descriptive>
                <description><p>
 Timezone identifier to set.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type InvalidValuesError, if the provided TZID
is not recognized as a valid timezone identifier.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="toLocalTimezone" id="::Time::TZDate::toLocalTimezone">
        <webidl>    <ref>TZDate</ref> toLocalTimezone() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns a copy of the TZDate converted to the local time zone.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TZDate">
          <descriptive>
              <description><p>
 TZDate The new TZDate in local Timezone.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="toUTC" id="::Time::TZDate::toUTC">
        <webidl>    <ref>TZDate</ref> toUTC() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns a copy of the TZDate converted to Coordinated Universal Time (UTC).
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TZDate">
          <descriptive>
              <description><p>
 TZDate Date/Time in UTC.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="difference" id="::Time::TZDate::difference">
        <webidl>    <ref>TimeDuration</ref> difference(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Calculates the difference with another TZDate object.
            </brief>
           <description>
            <p>
Calculates the difference in time between <em>this</em> and other.
This comparison method takes timezones into consideration for the comparison.
            </p>
            <p>
The TimeDuration that is returned is effectively <em>this</em> - other.
The return value is a duration in milliseconds both TZDate objects have a time component, in days, otherwise.
The result value will be:
            </p>
            <ul>
              <li>
Negative, if other is in the future              </li>
              <li>
0 if the two date / times are equal              </li>
              <li>
Positive, if other is in the past              </li>
            </ul>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TimeDuration">
          <descriptive>
              <description><p>
 TimeDuration Duration in milliseconds between the two date / time objects
(or in days for comparison between dates with no time component).
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="other">
            <descriptive>
                <description><p>
 Other Date/Time to compare to.
                </p></description>
            </descriptive>
            <Type name="TZDate"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="equalsTo" id="::Time::TZDate::equalsTo">
        <webidl>    boolean equalsTo(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Checks if the TZDate is equal to another.
            </brief>
           <description>
            <p>
This method takes the timezones into consideration and will return <em>true</em>if the two TZDate objects represent the same instant in different timezones.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean <em>true</em> if the 2 date/times are the same.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="other">
            <descriptive>
                <description><p>
 Other Date/Time to compare to.
                </p></description>
            </descriptive>
            <Type name="TZDate"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="earlierThan" id="::Time::TZDate::earlierThan">
        <webidl>    boolean earlierThan(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Checks if the TZDate is earlier than another.
            </brief>
           <description>
            <p>
This method takes the timezones into consideration.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean <em>true</em>, if the Date/Time is earlier than the one passed in argument.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="other">
            <descriptive>
                <description><p>
 Other Date/Time to compare to.
                </p></description>
            </descriptive>
            <Type name="TZDate"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="laterThan" id="::Time::TZDate::laterThan">
        <webidl>    boolean laterThan(<ref>TZDate</ref> other) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Checks if the TZDate is later than another.
            </brief>
           <description>
            <p>
This method takes the timezones into consideration.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean <em>true</em>, if the Date/Time is later than the one passed in argument.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="other">
            <descriptive>
                <description><p>
 Other Date/Time to compare to.
                </p></description>
            </descriptive>
            <Type name="TZDate"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="addDuration" id="::Time::TZDate::addDuration">
        <webidl>    <ref>TZDate</ref> addDuration(<ref>TimeDuration</ref> duration) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns a new date by adding a duration to the current TZDate object.
            </brief>
           <description>
            <p>
If the length of duration is negative, the new date / time will be
earlier than it used to.
            </p>
            <p>
Note that calling this method does not alter the current object.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var now = tizen.time.getCurrentDateTime();
 var in_one_week = now.addDuration(new tizen.TimeDuration(7, &quot;DAYS&quot;));
 </Code>
        </descriptive>
        <Type name="TZDate">
          <descriptive>
              <description><p>
 TZDate The new TZDate by adding a duration.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="duration">
            <descriptive>
                <description><p>
 TimeDuration to add.
                </p></description>
            </descriptive>
            <Type name="TimeDuration"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="toLocaleDateString" id="::Time::TZDate::toLocaleDateString">
        <webidl>    DOMString toLocaleDateString();</webidl>
        <descriptive>
            <brief>
 Returns the date portion of a TZDate object as a string, using locale conventions.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString Date portion of the TZDate object as a string, using locale conventions. If TZDate is invalid, it will return 'Invalid Date'.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="toLocaleTimeString" id="::Time::TZDate::toLocaleTimeString">
        <webidl>    DOMString toLocaleTimeString();</webidl>
        <descriptive>
            <brief>
 Returns the time portion of a TZDate object as a string, using locale conventions.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString Time portion of the TZDate object as a string, using locale conventions. If TZDate is invalid, it will return 'Invalid Date'.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="toLocaleString" id="::Time::TZDate::toLocaleString">
        <webidl>    DOMString toLocaleString();</webidl>
        <descriptive>
            <brief>
 Converts a TZDate object to a string, using locale conventions.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString String representation of the TZDate object, using locale conventions. If TZDate is invalid, it will return 'Invalid Date'.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="toDateString" id="::Time::TZDate::toDateString">
        <webidl>    DOMString toDateString();</webidl>
        <descriptive>
            <brief>
 Returns the date portion of a TZDate object as a string.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString Date portion of the TZDate object as a string. If TZDate is invalid, it will return 'Invalid Date'.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="toTimeString" id="::Time::TZDate::toTimeString">
        <webidl>    DOMString toTimeString();</webidl>
        <descriptive>
            <brief>
 Returns the time portion of a TZDate object as a string.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString Time portion of the TZDate object as a string. If TZDate is invalid, it will return 'Invalid Date'.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="toString" id="::Time::TZDate::toString">
        <webidl>    DOMString toString();</webidl>
        <descriptive>
            <brief>
 Converts a TZDate object to a string.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString String representation of the TZDate object. If TZDate is invalid, it will return 'Invalid Date'.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
      </Operation>
      <Operation name="getTimezoneAbbreviation" id="::Time::TZDate::getTimezoneAbbreviation">
        <webidl>    DOMString getTimezoneAbbreviation() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Determines the time zone abbreviation to be used at a particular date in the time zone.
            </brief>
           <description>
            <p>
For example, in Toronto this is currently &quot;EST&quot; during the winter months and &quot;EDT&quot; during the
summer months when daylight savings time is in effect.
            </p>
           </description>
            <version>
 1.0
            </version>
            <deprecated>
 Some timezones return &quot;GMT[+-]hh:mm&quot;. It is inconsistent.
            </deprecated>
        </descriptive>
        <Type type="DOMString">
          <descriptive>
              <description><p>
 DOMString Abbreviation of the time zone (such as &quot;EST&quot;). If TZDate is invalid, it will return 'Invalid Date'.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="secondsFromUTC" id="::Time::TZDate::secondsFromUTC">
        <webidl>    long secondsFromUTC() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Gets the number of seconds from Coordinated Universal Time (UTC) offset for the timezone.
            </brief>
           <description>
            <p>
Returns the offset (in seconds) from UTC of the timezone, accounting for daylight
savings if in effect in the timezone. For example, if time zone is GMT+8, it will return -32,400.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var offset = tizen.time.getCurrentDateTime().secondsFromUTC();
 var myDate = new Date();
 var exp_offset = myDate.getTimezoneOffset()*60;
 //offset is equals to exp_offset.
 </Code>
        </descriptive>
        <Type type="long">
          <descriptive>
              <description><p>
 long Offset from UTC in seconds.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="isDST" id="::Time::TZDate::isDST">
        <webidl>    boolean isDST() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Indicates if Daylight Saving Time(DST) is active for this TZDate.
            </brief>
           <description>
            <p>
Indicates if daylight savings are in effect for the time zone and instant
identified by the TZDate object.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean Flag indicating if daylight saving are in effect.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getPreviousDSTTransition" id="::Time::TZDate::getPreviousDSTTransition">
        <webidl>    <ref>TZDate</ref>? getPreviousDSTTransition() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns the date of the previous daylight saving time transition for the timezone.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TZDate" nullable="nullable">
          <descriptive>
              <description><p>
 TZDate The date of the previous daylight saving transition (before the instant identified by the TZDate).
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="getNextDSTTransition" id="::Time::TZDate::getNextDSTTransition">
        <webidl>    <ref>TZDate</ref>? getNextDSTTransition() raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Returns the date of the next daylight saving time transition for the timezone.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TZDate" nullable="nullable">
          <descriptive>
              <description><p>
 TZDate The date of the next daylight saving transition (after the instant identified by the TZDate).
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList/>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
    <Interface name="TimeDuration" id="::Time::TimeDuration">
      <webidl>  [Constructor(long long length, optional <ref>TimeDurationUnit</ref>? unit)]
  interface TimeDuration
  {
    attribute long long length;

    attribute <ref>TimeDurationUnit</ref> unit;

    <ref>TimeDuration</ref> difference(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);

    boolean equalsTo(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);

    boolean lessThan(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);

    boolean greaterThan(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 The TimeDuration object that contains the length and its associated
time unit.
          </brief>
          <version>
 1.0
          </version>
          <Code> var now = tizen.time.getCurrentDateTime();
 var tomorrow = now.addDuration(new tizen.TimeDuration(1, &quot;DAYS&quot;)); // Becomes tomorrow, same time.
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(long long length, optional <ref>TimeDurationUnit</ref>? unit)</webidl>
          <ArgumentList>
            <Argument name="length">
              <Type type="long long"/>
            </Argument>
            <Argument optional="optional" name="unit">
              <Type name="TimeDurationUnit" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="length" id="::Time::TimeDuration::length">
        <webidl>    attribute long long length;</webidl>
        <descriptive>
            <brief>
 Duration length.
            </brief>
           <description>
            <p>
The unit of the duration length (milliseconds, seconds, minutes, hours, or days)
is determined by the duration unit attribute.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="long long"/>
      </Attribute>
      <Attribute name="unit" id="::Time::TimeDuration::unit">
        <webidl>    attribute <ref>TimeDurationUnit</ref> unit;</webidl>
        <descriptive>
            <brief>
 Duration unit (milliseconds, seconds, minutes, hours, or days).
            </brief>
           <description>
            <p>
The default value is &quot;MSECS&quot; (milliseconds unit).
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="TimeDurationUnit"/>
      </Attribute>
      <Operation name="difference" id="::Time::TimeDuration::difference">
        <webidl>    <ref>TimeDuration</ref> difference(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Calculates the difference between two TimeDuration objects.
            </brief>
           <description>
            <p>
Calculates the difference in time between <em>this</em> and <em>other</em>.
The TimeDuration that is returned is effectively <em>first</em> - <em>other</em> (that is: positive if the first parameter is larger).
            </p>
            <p>
The returned TimeDuration is the biggest possible unit without losing the precision.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> // Compute event1.duration - event2.duration
 var diff = event1.duration.difference(event2.duration);
 if (diff.length > 0)
   console.log(&quot;event 1's duration is longer than event 2's&quot;);
 else if (diff.length == 0)
   console.log(&quot;event 1's duration is as long as event 2's&quot;);
 else
   console.log(&quot;event 1's duration is shorter than event 2's&quot;);
 </Code>
        </descriptive>
        <Type name="TimeDuration">
          <descriptive>
              <description><p>
 New TimeDuration object corresponding to the result of <em>this</em> - <em>other</em>.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="other">
            <descriptive>
                <description><p>
 Other TimeDuration object to compare to.
                </p></description>
            </descriptive>
            <Type name="TimeDuration"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="equalsTo" id="::Time::TimeDuration::equalsTo">
        <webidl>    boolean equalsTo(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Checks if the TimeDuration is equal to another.
            </brief>
           <description>
            <p>
This method takes the units into consideration and will return true
if the two TimeDuration objects represent the same duration in different units.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var d1 = new tizen.TimeDuration(60, &quot;MINS&quot;); // 60 minutes
 var d2 = new tizen.TimeDuration(1, &quot;HOURS&quot;); // 1 hour
 var ret = d1.equalsTo(d2); // Returns true
 </Code>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean <em>true</em> if the two TimeDuration object represent the same duration.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="other">
            <descriptive>
                <description><p>
 Other TimeDuration object to compare to.
                </p></description>
            </descriptive>
            <Type name="TimeDuration"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="lessThan" id="::Time::TimeDuration::lessThan">
        <webidl>    boolean lessThan(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Checks if the TimeDuration is lower than another.
            </brief>
           <description>
            <p>
This method takes the units into consideration when doing the comparison.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var d1 = new tizen.TimeDuration(1, &quot;HOURS&quot;); // 1 hour
 var d2 = new tizen.TimeDuration(120, &quot;MINS&quot;); // 120 minutes
 var ret = d1.lessThan(d2); // Returns true
 </Code>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean <em>true</em> if the TimeDuration is less than <em>other</em>.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="other">
            <descriptive>
                <description><p>
 Other TimeDuration object to compare to.
                </p></description>
            </descriptive>
            <Type name="TimeDuration"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="greaterThan" id="::Time::TimeDuration::greaterThan">
        <webidl>    boolean greaterThan(<ref>TimeDuration</ref> other) raises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Checks if the TimeDuration is greater than another.
            </brief>
           <description>
            <p>
This method takes the units into consideration when doing the comparison.
            </p>
           </description>
            <version>
 1.0
            </version>
            <Code> var d1 = new tizen.TimeDuration(120, &quot;MINS&quot;); // 120 minutes
 var d2 = new tizen.TimeDuration(1, &quot;HOURS&quot;); // 1 hour
 var ret = d1.greaterThan(d2); // Returns true
 </Code>
        </descriptive>
        <Type type="boolean">
          <descriptive>
              <description><p>
 boolean <em>true</em> if the TimeDuration is greater than <em>other</em>.
              </p></description>
          </descriptive>
        </Type>
        <ArgumentList>
          <Argument name="other">
            <descriptive>
                <description><p>
 Other TimeDuration object to compare to.
                </p></description>
            </descriptive>
            <Type name="TimeDuration"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if the input parameter
is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type UnknownError, if the call failed due to an unknown error.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
  </Module>
  <Module name="Tizen" id="::Tizen">
    <webidl>module Tizen {
  enum FilterMatchFlag { &quot;EXACTLY&quot;, &quot;FULLSTRING&quot;, &quot;CONTAINS&quot;, &quot;STARTSWITH&quot;, &quot;ENDSWITH&quot;, &quot;EXISTS&quot; };

  enum SortModeOrder { &quot;ASC&quot;, &quot;DESC&quot; };

  enum CompositeFilterType { &quot;UNION&quot;, &quot;INTERSECTION&quot; };

  [NoInterfaceObject] interface TizenObject {
    readonly attribute <ref>Tizen</ref> tizen;
  };
  <ref>Window</ref> implements <ref>TizenObject</ref>;

  [NoInterfaceObject] interface Tizen {
  };

  [NoInterfaceObject] interface AbstractFilter {
  };

  [Constructor(DOMString attributeName, optional <ref>FilterMatchFlag</ref>? matchFlag, optional any matchValue)]
  interface AttributeFilter : <ref>AbstractFilter</ref> {
    attribute DOMString attributeName;

    attribute <ref>FilterMatchFlag</ref> matchFlag setraises(<ref>WebAPIException</ref>);

    attribute any matchValue;
  };

  [Constructor(DOMString attributeName, optional any initialValue, optional any endValue)]
  interface AttributeRangeFilter : <ref>AbstractFilter</ref> {
    attribute DOMString attributeName;

    attribute any initialValue;

    attribute any endValue;
  };

  [Constructor(<ref>CompositeFilterType</ref> type, optional <ref>AbstractFilter</ref>[]? filters)]
  interface CompositeFilter : <ref>AbstractFilter</ref> {

    attribute <ref>CompositeFilterType</ref> type;

    attribute <ref>AbstractFilter</ref>[] filters;
  };

  [Constructor(DOMString attributeName, optional <ref>SortModeOrder</ref>? order)]
  interface SortMode {
    attribute DOMString attributeName;

    attribute <ref>SortModeOrder</ref> order setraises(<ref>WebAPIException</ref>);
  };

  [Constructor(double latitude, double longitude)]
  interface SimpleCoordinates {
    attribute double latitude setraises(<ref>WebAPIException</ref>);

    attribute double longitude setraises(<ref>WebAPIException</ref>);
  };

  [NoInterfaceObject]
  interface WebAPIException {
    readonly attribute unsigned short code;

    readonly attribute DOMString name;

    readonly attribute DOMString message;

    const unsigned short INDEX_SIZE_ERR = 1;
    const unsigned short DOMSTRING_SIZE_ERR = 2;
    const unsigned short HIERARCHY_REQUEST_ERR = 3;
    const unsigned short WRONG_DOCUMENT_ERR = 4;
    const unsigned short INVALID_CHARACTER_ERR = 5;
    const unsigned short NO_DATA_ALLOWED_ERR = 6;
    const unsigned short NO_MODIFICATION_ALLOWED_ERR = 7;
    const unsigned short NOT_FOUND_ERR = 8;
    const unsigned short NOT_SUPPORTED_ERR = 9;
    const unsigned short INUSE_ATTRIBUTE_ERR = 10;
    const unsigned short INVALID_STATE_ERR = 11;
    const unsigned short SYNTAX_ERR = 12;
    const unsigned short INVALID_MODIFICATION_ERR = 13;
    const unsigned short NAMESPACE_ERR = 14;
    const unsigned short INVALID_ACCESS_ERR = 15;
    const unsigned short VALIDATION_ERR = 16;
    const unsigned short TYPE_MISMATCH_ERR = 17;
    const unsigned short SECURITY_ERR = 18;
    const unsigned short NETWORK_ERR = 19;
    const unsigned short ABORT_ERR = 20;
    const unsigned short URL_MISMATCH_ERR = 21;
    const unsigned short QUOTA_EXCEEDED_ERR = 22;
    const unsigned short TIMEOUT_ERR = 23;
    const unsigned short INVALID_NODE_TYPE_ERR = 24;
    const unsigned short DATA_CLONE_ERR = 25;
  };

  [NoInterfaceObject]
  interface WebAPIError {
    readonly attribute unsigned short code;

    readonly attribute DOMString name;

    readonly attribute DOMString message;
  };

  [Callback=FunctionOnly, NoInterfaceObject]
  interface SuccessCallback {
    void onsuccess ();
  };

  [Callback=FunctionOnly, NoInterfaceObject]
  interface ErrorCallback {

    void onerror (<ref>WebAPIError</ref> error);
  };
};</webidl>
    <descriptive>
        <brief>
 This API provides common Tizen functionality.
        </brief>
       <description>
        <p>
The API provides the basic definitions that are used in the Tizen Web Device API.
These include generic callbacks that are invoked when the operations succeed or fail,
WebAPIError and WebAPIException that gives information of the platform's error and
filters interfaces that are used to make query for searching.
        </p>
        <p>
Additionally, this API specifies the location in the ECMAScript hierarchy in which
the Tizen Web Device API is instantiated (<em>window.tizen</em>).
        </p>
        <p>
For more information on the Tizen features, see <a href="../../org.tizen.web.appprogramming/html/guide/tizen_guide/tizen.htm">Tizen Guide</a>.
        </p>
       </description>
        <version>
 1.0
        </version>
    </descriptive>
    <Enum name="FilterMatchFlag" id="::Tizen::FilterMatchFlag">
      <webidl>  enum FilterMatchFlag { &quot;EXACTLY&quot;, &quot;FULLSTRING&quot;, &quot;CONTAINS&quot;, &quot;STARTSWITH&quot;, &quot;ENDSWITH&quot;, &quot;EXISTS&quot; };</webidl>
      <descriptive>
          <brief>
 Filter match flag.
          </brief>
         <description>
          <p>
These values are supported:
          </p>
          <ul>
            <li>
EXACTLY - Indicates that an attribute value should match exactly with the specified default value.
For strings, this type of comparison is case-sensitive.            </li>
            <li>
FULLSTRING - Indicates String-based comparison and that the attribute value should match the whole string (case insensitive).            </li>
            <li>
CONTAINS - Indicates that an attribute value should contain the specified string. This type of comparison works only on strings and is case insensitive.            </li>
            <li>
STARTSWITH - Indicates that an attribute value should start with the specified string.
This type of comparison works only on strings and is case insensitive.            </li>
            <li>
ENDSWITH - Indicates that an attribute value should end with the specified string. This type of comparison works only on strings and is case insensitive.            </li>
            <li>
EXISTS - Indicates that a filter comparison should match if the specified attribute exists.            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="EXACTLY">
        <webidl> &quot;EXACTLY</webidl>
      </EnumValue>
      <EnumValue stringvalue="FULLSTRING">
        <webidl> &quot;FULLSTRING</webidl>
      </EnumValue>
      <EnumValue stringvalue="CONTAINS">
        <webidl> &quot;CONTAINS</webidl>
      </EnumValue>
      <EnumValue stringvalue="STARTSWITH">
        <webidl> &quot;STARTSWITH</webidl>
      </EnumValue>
      <EnumValue stringvalue="ENDSWITH">
        <webidl> &quot;ENDSWITH</webidl>
      </EnumValue>
      <EnumValue stringvalue="EXISTS">
        <webidl> &quot;EXISTS</webidl>
      </EnumValue>
    </Enum>
    <Enum name="SortModeOrder" id="::Tizen::SortModeOrder">
      <webidl>  enum SortModeOrder { &quot;ASC&quot;, &quot;DESC&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the sorting order.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
ASC - Indicates the sorting order is ascending            </li>
            <li>
DESC - Indicates the sorting order is descending            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="ASC">
        <webidl> &quot;ASC</webidl>
      </EnumValue>
      <EnumValue stringvalue="DESC">
        <webidl> &quot;DESC</webidl>
      </EnumValue>
    </Enum>
    <Enum name="CompositeFilterType" id="::Tizen::CompositeFilterType">
      <webidl>  enum CompositeFilterType { &quot;UNION&quot;, &quot;INTERSECTION&quot; };</webidl>
      <descriptive>
          <brief>
 An enumerator that indicates the type of composite filter.
          </brief>
         <description>
          <p>
The following values are supported:
          </p>
          <ul>
            <li>
UNION - Indicates that the composite is a union of filters (&quot;OR&quot; operator)            </li>
            <li>
INTERSECTION - Indicates that the composite is an intersection of filters (&quot;AND&quot; operator)            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <EnumValue stringvalue="UNION">
        <webidl> &quot;UNION</webidl>
      </EnumValue>
      <EnumValue stringvalue="INTERSECTION">
        <webidl> &quot;INTERSECTION</webidl>
      </EnumValue>
    </Enum>
    <Interface name="TizenObject" id="::Tizen::TizenObject">
      <webidl>  [NoInterfaceObject] interface TizenObject {
    readonly attribute <ref>Tizen</ref> tizen;
  };</webidl>
      <descriptive>
          <brief>
 Defines the tizen interface as a part of the window global object.
          </brief>
         <description>
          <p>
The <em>Tizen</em> interface is always available within the <em>Window </em>object in the ECMAScript hierarchy.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="tizen" id="::Tizen::TizenObject::tizen">
        <webidl>    readonly attribute <ref>Tizen</ref> tizen;</webidl>
        <Type name="Tizen"/>
      </Attribute>
    </Interface>
    <Implements name1="Window" name2="TizenObject">
      <webidl>  <ref>Window</ref> implements <ref>TizenObject</ref>;</webidl>
    </Implements>
    <Interface name="Tizen" id="::Tizen::Tizen">
      <webidl>  [NoInterfaceObject] interface Tizen {
  };</webidl>
      <descriptive>
          <brief>
 The root of Tizen Web Device API.
          </brief>
         <description>
          <p>
This is the Tizen root interface.
It is a property of the ECMAScript global object, as specified by the <em>TizenObject</em> interface.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
    </Interface>
    <Interface name="AbstractFilter" id="::Tizen::AbstractFilter">
      <webidl>  [NoInterfaceObject] interface AbstractFilter {
  };</webidl>
      <descriptive>
          <brief>
 This is a common interface used by different types of
object filters.
          </brief>
         <description>
          <p>
Never use this base interface directly, instead use <em>AbstractFilter</em> subtypes,
such as <em>AttributeFilter</em>, <em>AttributeRangeFilter</em>, and <em>CompositeFilter</em>.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
    </Interface>
    <Interface name="AttributeFilter" id="::Tizen::AttributeFilter">
      <webidl>  [Constructor(DOMString attributeName, optional <ref>FilterMatchFlag</ref>? matchFlag, optional any matchValue)]
  interface AttributeFilter : <ref>AbstractFilter</ref> {
    attribute DOMString attributeName;

    attribute <ref>FilterMatchFlag</ref> matchFlag setraises(<ref>WebAPIException</ref>);

    attribute any matchValue;
  };</webidl>
      <descriptive>
          <brief>
 This interface represents a set of filter.
          </brief>
         <description>
          <p>
It represents the query statement for the specified value of the <em>matchValue</em> by the rule of <em>matchFlag</em>.
          </p>
          <p>
If no <em>matchValue</em> is defined, the filter will match all objects that have the attribute
defined (same as the &quot;EXISTS&quot; filter works), otherwise, it will only match objects which have an attribute that matches
the specified value.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> // Define success callback
 function successCallback(contacts) {
   console.log(contacts.length + &quot; contacts found.&quot;);
 }

 // Define error callback
 function errorCallback(error) {
   console.log(&quot;An error occurred: &quot; + error.message);
 }

 // Create an attribute filter based on first name: &quot;First name should contain 'Chris' (case insensitive)&quot;
 var filter = new tizen.AttributeFilter(&quot;name.firstName&quot;, &quot;CONTAINS&quot;, &quot;Chris&quot;);
 // Send request on contact address book.
 tizen.contact.getDefaultAddressBook().find(successCallback, errorCallback, filter);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString attributeName, optional <ref>FilterMatchFlag</ref>? matchFlag, optional any matchValue)</webidl>
          <ArgumentList>
            <Argument name="attributeName">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="matchFlag">
              <Type name="FilterMatchFlag" nullable="nullable"/>
            </Argument>
            <Argument optional="optional" name="matchValue">
              <Type type="any"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="AbstractFilter"/>
      </InterfaceInheritance>
      <Attribute name="attributeName" id="::Tizen::AttributeFilter::attributeName">
        <webidl>    attribute DOMString attributeName;</webidl>
        <descriptive>
            <brief>
 The name of the object attribute used for filtering.
            </brief>
           <description>
            <p>
This is the name of the object attribute exactly as it is defined in
the object's interface. For attributes of complex type, use fully-qualified names
(such as 'organizations.role' to filter on a contact's role in an organization).
            </p>
            <p>
For attributes of an array type, the filter will match if any value in the array
matches.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="matchFlag" id="::Tizen::AttributeFilter::matchFlag">
        <webidl>    attribute <ref>FilterMatchFlag</ref> matchFlag setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The match flag used for attribute-based filtering.
            </brief>
           <description>
            <p>
By default, this attribute is set to &quot;EXACTLY&quot;.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="FilterMatchFlag"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="matchValue" id="::Tizen::AttributeFilter::matchValue">
        <webidl>    attribute any matchValue;</webidl>
        <descriptive>
            <brief>
 The value used for matching.
            </brief>
           <description>
            <p>
The filter will match if the attribute value matches the given matchValue.
            </p>
            <p>
This value is not used if the <em>matchFlag</em> is set to &quot;EXISTS&quot;.
By default, this attribute is set to null.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="any"/>
      </Attribute>
    </Interface>
    <Interface name="AttributeRangeFilter" id="::Tizen::AttributeRangeFilter">
      <webidl>  [Constructor(DOMString attributeName, optional any initialValue, optional any endValue)]
  interface AttributeRangeFilter : <ref>AbstractFilter</ref> {
    attribute DOMString attributeName;

    attribute any initialValue;

    attribute any endValue;
  };</webidl>
      <descriptive>
          <brief>
 <em>AttributeRangeFilter</em> represents a filter based on an object attribute
which has values that are within a particular range.
          </brief>
         <description>
          <p>
Range filters, where only one boundary is set, are available.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> // Define success callback
 function successCallback(events) {
   console.log(events.length + &quot; events today.&quot;);
 }

 // Define error callback
 function errorCallback(error) {
   console.log(&quot;An error occurred: &quot; + error.message);
 }

 // Create an attribute range filter based on event start date: &quot;All events occurring today&quot;.
 var now_dt = tizen.time.getCurrentDateTime();
 var today_begin = new tizen.TZDate(now_dt.getFullYear(), now_dt.getMonth(), now_dt.getDate());
 var today_end = today_begin.addDuration(new tizen.TimeDuration(1, &quot;DAYS&quot;));
 var filter = new tizen.AttributeRangeFilter(&quot;startDate&quot;, today_begin, today_end);

 // Send a search request to default event calendar.
 tizen.calendar.getDefaultCalendar(&quot;EVENT&quot;).find(successCallback, errorCallback, filter);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString attributeName, optional any initialValue, optional any endValue)</webidl>
          <ArgumentList>
            <Argument name="attributeName">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="initialValue">
              <Type type="any"/>
            </Argument>
            <Argument optional="optional" name="endValue">
              <Type type="any"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="AbstractFilter"/>
      </InterfaceInheritance>
      <Attribute name="attributeName" id="::Tizen::AttributeRangeFilter::attributeName">
        <webidl>    attribute DOMString attributeName;</webidl>
        <descriptive>
            <brief>
 The name of the object attribute used for filtering.
            </brief>
           <description>
            <p>
The value of this attribute is exactly as it is defined in the object's interface. For attributes of complex type, use fully-qualified names
(such as 'organizations.role' to filter on a contact's role in an organization).
            </p>
            <p>
For attributes of array type, the filter will match if any value in the array
matches.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="initialValue" id="::Tizen::AttributeRangeFilter::initialValue">
        <webidl>    attribute any initialValue;</webidl>
        <descriptive>
            <brief>
 Objects with an attribute that is greater than or equal to <em>initialValue</em> will match.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="any"/>
      </Attribute>
      <Attribute name="endValue" id="::Tizen::AttributeRangeFilter::endValue">
        <webidl>    attribute any endValue;</webidl>
        <descriptive>
            <brief>
 Objects with an attribute that is strictly lower than to <em>endValue</em> will match.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>null</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="any"/>
      </Attribute>
    </Interface>
    <Interface name="CompositeFilter" id="::Tizen::CompositeFilter">
      <webidl>  [Constructor(<ref>CompositeFilterType</ref> type, optional <ref>AbstractFilter</ref>[]? filters)]
  interface CompositeFilter : <ref>AbstractFilter</ref> {

    attribute <ref>CompositeFilterType</ref> type;

    attribute <ref>AbstractFilter</ref>[] filters;
  };</webidl>
      <descriptive>
          <brief>
 <em>CompositeFilter</em> represents a set of filters.
          </brief>
         <description>
          <p>
The composite filters can be one of the 2 types:
          </p>
          <ul>
            <li>
The union - used to filter objects that match any of the filters it includes.            </li>
            <li>
The intersection - used to filter objects that match all filters it includes.            </li>
          </ul>
         </description>
          <version>
 1.0
          </version>
          <Code> // Define success callback
 function successCallback(contacts) {
   console.log(contacts.length + &quot; contacts found.&quot;);
 }

 // Define error callback
 function errorCallback(error) {
   console.log(&quot;An error occurred: &quot; + error.message);
 }

 // Create an attribute filter based on first name: &quot;First name should contain 'Chris' (case insensitive)
 var firstNameFilter = new tizen.AttributeFilter(&quot;name.firstName&quot;, &quot;CONTAINS&quot;, &quot;Chris&quot;);

 // Create an attribute filter based on last name: &quot;Last name should be exactly 'Smith' (case insensitive)
 var lastNameFilter = new tizen.AttributeFilter(&quot;name.lastName&quot;, &quot;EXACTLY&quot;, &quot;Smith&quot;};

 // Create a filter based on the intersection of these two filter:
 // &quot;First name should contain 'Chris' AND last name should be 'Smith'&quot;.
 var filter = new tizen.CompositeFilter(&quot;INTERSECTION&quot;, [firstNameFilter, lastNameFilter]);

 // Send request on contact address book.
 tizen.contact.getDefaultAddressBook().find(successCallback, errorCallback, filter);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(<ref>CompositeFilterType</ref> type, optional <ref>AbstractFilter</ref>[]? filters)</webidl>
          <ArgumentList>
            <Argument name="type">
              <Type name="CompositeFilterType"/>
            </Argument>
            <Argument optional="optional" name="filters">
              <Type type="array" nullable="nullable">
                <Type name="AbstractFilter"/>
              </Type>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <InterfaceInheritance>
        <Name name="AbstractFilter"/>
      </InterfaceInheritance>
      <Attribute name="type" id="::Tizen::CompositeFilter::type">
        <webidl>    attribute <ref>CompositeFilterType</ref> type;</webidl>
        <descriptive>
            <brief>
 The composite filter type.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="CompositeFilterType"/>
      </Attribute>
      <Attribute name="filters" id="::Tizen::CompositeFilter::filters">
        <webidl>    attribute <ref>AbstractFilter</ref>[] filters;</webidl>
        <descriptive>
            <brief>
 The list of filters in the composite filter.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="array">
          <Type name="AbstractFilter"/>
        </Type>
      </Attribute>
    </Interface>
    <Interface name="SortMode" id="::Tizen::SortMode">
      <webidl>  [Constructor(DOMString attributeName, optional <ref>SortModeOrder</ref>? order)]
  interface SortMode {
    attribute DOMString attributeName;

    attribute <ref>SortModeOrder</ref> order setraises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 <em>SortMode</em> is a common interface used for sorting of queried data.
          </brief>
         <description>
          <p>
Note that the sorting result of list type attributes is not determined.
          </p>
         </description>
          <version>
 1.0
          </version>
          <Code> // Define a success callback
 function successCallback(contacts) {
   // The returned contacts are sorted by first name (ascending)
   console.log(contacts.length + &quot; contacts found.&quot;);
 }

 // Define an error callback
 function errorCallback(error) {
   console.log(&quot;An error occurred: &quot; + error.message);
 }

 // Create an attribute filter based on first name: &quot;First name should contain 'Chris' (case insensitive)&quot;
 var filter = new tizen.AttributeFilter(&quot;name.firstName&quot;, &quot;CONTAINS&quot;, &quot;Chris&quot;);
 // Sort by first name, ascending
 var sortMode = new tizen.SortMode(&quot;name.firstName&quot;, &quot;ASC&quot;);
 // Send request on contact address book.
 tizen.contact.getDefaultAddressBook().find(successCallback, errorCallback, filter, sortMode);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(DOMString attributeName, optional <ref>SortModeOrder</ref>? order)</webidl>
          <ArgumentList>
            <Argument name="attributeName">
              <Type type="DOMString"/>
            </Argument>
            <Argument optional="optional" name="order">
              <Type name="SortModeOrder" nullable="nullable"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="attributeName" id="::Tizen::SortMode::attributeName">
        <webidl>    attribute DOMString attributeName;</webidl>
        <descriptive>
            <brief>
 The name of the object attribute used for sorting.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute name="order" id="::Tizen::SortMode::order">
        <webidl>    attribute <ref>SortModeOrder</ref> order setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 The type of the sorting.
            </brief>
           <description>
            <p>
By default, this attribute is set to <var>ASC</var>.
            </p>
           </description>
            <version>
 1.0
            </version>
        </descriptive>
        <Type name="SortModeOrder"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
    </Interface>
    <Interface name="SimpleCoordinates" id="::Tizen::SimpleCoordinates">
      <webidl>  [Constructor(double latitude, double longitude)]
  interface SimpleCoordinates {
    attribute double latitude setraises(<ref>WebAPIException</ref>);

    attribute double longitude setraises(<ref>WebAPIException</ref>);
  };</webidl>
      <descriptive>
          <brief>
 <em>SimpleCoordinates</em> represents a point (latitude and longitude) in map coordinate system.
          </brief>
         <description>
          <p>
Latitude and longitude are of the WGS84 datum.
          </p>
         </description>
          <version>
 1.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Constructor">
          <webidl>Constructor(double latitude, double longitude)</webidl>
          <ArgumentList>
            <Argument name="latitude">
              <Type type="double"/>
            </Argument>
            <Argument name="longitude">
              <Type type="double"/>
            </Argument>
          </ArgumentList>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute name="latitude" id="::Tizen::SimpleCoordinates::latitude">
        <webidl>    attribute double latitude setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Latitude.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
      <Attribute name="longitude" id="::Tizen::SimpleCoordinates::longitude">
        <webidl>    attribute double longitude setraises(<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Longitude.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="double"/>
        <SetRaises>
          <RaiseException name="WebAPIException"/>
        </SetRaises>
      </Attribute>
    </Interface>
    <Interface name="WebAPIException" id="::Tizen::WebAPIException">
      <webidl>  [NoInterfaceObject]
  interface WebAPIException {
    readonly attribute unsigned short code;

    readonly attribute DOMString name;

    readonly attribute DOMString message;

    const unsigned short INDEX_SIZE_ERR = 1;
    const unsigned short DOMSTRING_SIZE_ERR = 2;
    const unsigned short HIERARCHY_REQUEST_ERR = 3;
    const unsigned short WRONG_DOCUMENT_ERR = 4;
    const unsigned short INVALID_CHARACTER_ERR = 5;
    const unsigned short NO_DATA_ALLOWED_ERR = 6;
    const unsigned short NO_MODIFICATION_ALLOWED_ERR = 7;
    const unsigned short NOT_FOUND_ERR = 8;
    const unsigned short NOT_SUPPORTED_ERR = 9;
    const unsigned short INUSE_ATTRIBUTE_ERR = 10;
    const unsigned short INVALID_STATE_ERR = 11;
    const unsigned short SYNTAX_ERR = 12;
    const unsigned short INVALID_MODIFICATION_ERR = 13;
    const unsigned short NAMESPACE_ERR = 14;
    const unsigned short INVALID_ACCESS_ERR = 15;
    const unsigned short VALIDATION_ERR = 16;
    const unsigned short TYPE_MISMATCH_ERR = 17;
    const unsigned short SECURITY_ERR = 18;
    const unsigned short NETWORK_ERR = 19;
    const unsigned short ABORT_ERR = 20;
    const unsigned short URL_MISMATCH_ERR = 21;
    const unsigned short QUOTA_EXCEEDED_ERR = 22;
    const unsigned short TIMEOUT_ERR = 23;
    const unsigned short INVALID_NODE_TYPE_ERR = 24;
    const unsigned short DATA_CLONE_ERR = 25;
  };</webidl>
      <descriptive>
          <brief>
 Generic exception interface.
          </brief>
         <description>
          <p>
This interface will be used by the APIs to throw errors synchronously.
          </p>
          <p>
The attempt to set an attribute value may or may not raise WebAPIException synchronously with error type TypeMismatchError or InvalidValuesError.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="code" id="::Tizen::WebAPIException::code">
        <webidl>    readonly attribute unsigned short code;</webidl>
        <descriptive>
            <brief>
 16-bit error code.
For the possible values for this attribute, see <a href="http://www.w3.org/TR/dom/#domexception">DOMException</a>.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Tizen::WebAPIException::name">
        <webidl>    readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 An error type. The name attribute must return the value it was initialized with.
This attribute can have one of the following values:
            </brief>
           <description>
            <ul>
              <li>
UnknownError - An unknown error has occurred.              </li>
              <li>
InvalidValuesError - The content of an object does not contain valid values.              </li>
              <li>
IOError - An error occurred in communication with the underlying implementation and so the requested method cannot be completed.              </li>
              <li>
ServiceNotAvailableError - The requested service is not available.              </li>
            </ul>
            <p>
For other possible values for this attribute, see the values defined in <a href="http://www.w3.org/TR/dom/#error-types">DOM error types</a>
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="message" id="::Tizen::WebAPIException::message">
        <webidl>    readonly attribute DOMString message;</webidl>
        <descriptive>
            <brief>
 An error message that describes the details of an encountered error.
This attribute is mainly intended to be used for developers rather than end users, so it should not be used directly in the user interfaces as it is.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Const name="INDEX_SIZE_ERR" value="1" id="::Tizen::WebAPIException::INDEX_SIZE_ERR">
        <webidl>    const unsigned short INDEX_SIZE_ERR = 1;</webidl>
        <descriptive>
            <brief>
 The index is not in the allowed range.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DOMSTRING_SIZE_ERR" value="2" id="::Tizen::WebAPIException::DOMSTRING_SIZE_ERR">
        <webidl>    const unsigned short DOMSTRING_SIZE_ERR = 2;</webidl>
        <descriptive>
            <brief>
 The specified range of text is too large.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="HIERARCHY_REQUEST_ERR" value="3" id="::Tizen::WebAPIException::HIERARCHY_REQUEST_ERR">
        <webidl>    const unsigned short HIERARCHY_REQUEST_ERR = 3;</webidl>
        <descriptive>
            <brief>
 The operation would yield an incorrect node tree.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="WRONG_DOCUMENT_ERR" value="4" id="::Tizen::WebAPIException::WRONG_DOCUMENT_ERR">
        <webidl>    const unsigned short WRONG_DOCUMENT_ERR = 4;</webidl>
        <descriptive>
            <brief>
 The object is in the wrong document.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_CHARACTER_ERR" value="5" id="::Tizen::WebAPIException::INVALID_CHARACTER_ERR">
        <webidl>    const unsigned short INVALID_CHARACTER_ERR = 5;</webidl>
        <descriptive>
            <brief>
 The string contains invalid characters.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NO_DATA_ALLOWED_ERR" value="6" id="::Tizen::WebAPIException::NO_DATA_ALLOWED_ERR">
        <webidl>    const unsigned short NO_DATA_ALLOWED_ERR = 6;</webidl>
        <descriptive>
            <brief>
 Data is specified for a node that does not support data.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NO_MODIFICATION_ALLOWED_ERR" value="7" id="::Tizen::WebAPIException::NO_MODIFICATION_ALLOWED_ERR">
        <webidl>    const unsigned short NO_MODIFICATION_ALLOWED_ERR = 7;</webidl>
        <descriptive>
            <brief>
 The object cannot be modified.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NOT_FOUND_ERR" value="8" id="::Tizen::WebAPIException::NOT_FOUND_ERR">
        <webidl>    const unsigned short NOT_FOUND_ERR = 8;</webidl>
        <descriptive>
            <brief>
 The object cannot be found here.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NOT_SUPPORTED_ERR" value="9" id="::Tizen::WebAPIException::NOT_SUPPORTED_ERR">
        <webidl>    const unsigned short NOT_SUPPORTED_ERR = 9;</webidl>
        <descriptive>
            <brief>
 The operation is not supported.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="INUSE_ATTRIBUTE_ERR" value="10" id="::Tizen::WebAPIException::INUSE_ATTRIBUTE_ERR">
        <webidl>    const unsigned short INUSE_ATTRIBUTE_ERR = 10;</webidl>
        <descriptive>
            <brief>
 The specified attribute is already in use elsewhere.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_STATE_ERR" value="11" id="::Tizen::WebAPIException::INVALID_STATE_ERR">
        <webidl>    const unsigned short INVALID_STATE_ERR = 11;</webidl>
        <descriptive>
            <brief>
 The object is in an invalid state.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="SYNTAX_ERR" value="12" id="::Tizen::WebAPIException::SYNTAX_ERR">
        <webidl>    const unsigned short SYNTAX_ERR = 12;</webidl>
        <descriptive>
            <brief>
 The string did not match the expected pattern.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_MODIFICATION_ERR" value="13" id="::Tizen::WebAPIException::INVALID_MODIFICATION_ERR">
        <webidl>    const unsigned short INVALID_MODIFICATION_ERR = 13;</webidl>
        <descriptive>
            <brief>
 The object cannot be modified in this way.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NAMESPACE_ERR" value="14" id="::Tizen::WebAPIException::NAMESPACE_ERR">
        <webidl>    const unsigned short NAMESPACE_ERR = 14;</webidl>
        <descriptive>
            <brief>
 The operation is not allowed by Namespaces in XML.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_ACCESS_ERR" value="15" id="::Tizen::WebAPIException::INVALID_ACCESS_ERR">
        <webidl>    const unsigned short INVALID_ACCESS_ERR = 15;</webidl>
        <descriptive>
            <brief>
 The object does not support the operation or argument.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="VALIDATION_ERR" value="16" id="::Tizen::WebAPIException::VALIDATION_ERR">
        <webidl>    const unsigned short VALIDATION_ERR = 16;</webidl>
        <descriptive>
            <brief>
 The operation would cause the node to fail validation.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="TYPE_MISMATCH_ERR" value="17" id="::Tizen::WebAPIException::TYPE_MISMATCH_ERR">
        <webidl>    const unsigned short TYPE_MISMATCH_ERR = 17;</webidl>
        <descriptive>
            <brief>
 The type of the object does not match the expected type.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="SECURITY_ERR" value="18" id="::Tizen::WebAPIException::SECURITY_ERR">
        <webidl>    const unsigned short SECURITY_ERR = 18;</webidl>
        <descriptive>
            <brief>
 The operation is insecure.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="NETWORK_ERR" value="19" id="::Tizen::WebAPIException::NETWORK_ERR">
        <webidl>    const unsigned short NETWORK_ERR = 19;</webidl>
        <descriptive>
            <brief>
 A network error occurred.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="ABORT_ERR" value="20" id="::Tizen::WebAPIException::ABORT_ERR">
        <webidl>    const unsigned short ABORT_ERR = 20;</webidl>
        <descriptive>
            <brief>
 The operation was aborted.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="URL_MISMATCH_ERR" value="21" id="::Tizen::WebAPIException::URL_MISMATCH_ERR">
        <webidl>    const unsigned short URL_MISMATCH_ERR = 21;</webidl>
        <descriptive>
            <brief>
 The given URL does not match another URL.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="QUOTA_EXCEEDED_ERR" value="22" id="::Tizen::WebAPIException::QUOTA_EXCEEDED_ERR">
        <webidl>    const unsigned short QUOTA_EXCEEDED_ERR = 22;</webidl>
        <descriptive>
            <brief>
 The quota has been exceeded.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="TIMEOUT_ERR" value="23" id="::Tizen::WebAPIException::TIMEOUT_ERR">
        <webidl>    const unsigned short TIMEOUT_ERR = 23;</webidl>
        <descriptive>
            <brief>
 The operation timed out.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="INVALID_NODE_TYPE_ERR" value="24" id="::Tizen::WebAPIException::INVALID_NODE_TYPE_ERR">
        <webidl>    const unsigned short INVALID_NODE_TYPE_ERR = 24;</webidl>
        <descriptive>
            <brief>
 The supplied node is incorrect or has an incorrect ancestor for this operation.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
      <Const name="DATA_CLONE_ERR" value="25" id="::Tizen::WebAPIException::DATA_CLONE_ERR">
        <webidl>    const unsigned short DATA_CLONE_ERR = 25;</webidl>
        <descriptive>
            <brief>
 The object cannot be cloned.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Const>
    </Interface>
    <Interface name="WebAPIError" id="::Tizen::WebAPIError">
      <webidl>  [NoInterfaceObject]
  interface WebAPIError {
    readonly attribute unsigned short code;

    readonly attribute DOMString name;

    readonly attribute DOMString message;
  };</webidl>
      <descriptive>
          <brief>
 Generic error interface.
          </brief>
         <description>
          <p>
This interface will be used by the APIs in order to return them in the error callback of asynchronous methods.
          </p>
         </description>
          <version>
 2.0
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="code" id="::Tizen::WebAPIError::code">
        <webidl>    readonly attribute unsigned short code;</webidl>
        <descriptive>
            <brief>
 16-bit error code.
Possible values are defined in <a href="http://www.w3.org/TR/dom/#domexception">DOMException</a>.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="unsigned short"/>
      </Attribute>
      <Attribute readonly="readonly" name="name" id="::Tizen::WebAPIError::name">
        <webidl>    readonly attribute DOMString name;</webidl>
        <descriptive>
            <brief>
 An error type. The name attribute must return the value it was initialized with.
This attribute can have one of the following values:
            </brief>
           <description>
            <ul>
              <li>
UnknownError - An unknown error has occurred.              </li>
              <li>
InvalidValuesError - The content of an object does not contain valid values.              </li>
              <li>
IOError - An error occurred in communication with the underlying implementation and so the requested method cannot be completed.              </li>
              <li>
ServiceNotAvailableError - The requested service is not available.              </li>
            </ul>
            <p>
For other possible values for this attribute, see the values defined in <a href="http://www.w3.org/TR/dom/#error-types">DOM error types</a>
            </p>
           </description>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
      <Attribute readonly="readonly" name="message" id="::Tizen::WebAPIError::message">
        <webidl>    readonly attribute DOMString message;</webidl>
        <descriptive>
            <brief>
 An error message that describes the details of the error encountered. This attribute is not intended
to be used directly in the user interfaces as it is mainly intended to be useful for developers rather than end users.
            </brief>
            <version>
 2.0
            </version>
        </descriptive>
        <Type type="DOMString"/>
      </Attribute>
    </Interface>
    <Interface name="SuccessCallback" id="::Tizen::SuccessCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject]
  interface SuccessCallback {
    void onsuccess ();
  };</webidl>
      <descriptive>
          <brief>
 This interface is used in methods that do not require any return value in the success callback.
In case of successful execution of an asynchronous call, <em>SuccessCallback</em> or an API defined callback must be called immediately to notify the user.
          </brief>
          <version>
 1.0
          </version>
          <Code>     function onSuccess() {
         console.log(&quot;Application launched successfully&quot;);
     }
     tizen.application.launch('0pnxz8hbsr.MyFiles', onSuccess);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onsuccess" id="::Tizen::SuccessCallback::onsuccess">
        <webidl>    void onsuccess ();</webidl>
        <descriptive>
            <brief>
 Method invoked when the asynchronous call completes successfully.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList/>
      </Operation>
    </Interface>
    <Interface name="ErrorCallback" id="::Tizen::ErrorCallback">
      <webidl>  [Callback=FunctionOnly, NoInterfaceObject]
  interface ErrorCallback {

    void onerror (<ref>WebAPIError</ref> error);
  };</webidl>
      <descriptive>
          <brief>
 This interface is used in methods that require only an error as input parameter in the error callback.
If an invalid function (such as null) is passed to the API that accepts ErrorCallback,
it silently fails and there is no further action.
          </brief>
          <version>
 1.0
          </version>
          <Code>  // Define the error callback.
  function onError(error) {
    console.log(error.message);
  }

  // Define the success callback.
  function onSuccess(services) {
     //send a message using the found service
  }
  tizen.messaging.getMessageServices(&quot;messaging.sms&quot;, onSuccess, onError);
 </Code>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="Callback" value="FunctionOnly">
          <webidl>Callback</webidl>
        </ExtendedAttribute>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl> NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="onerror" id="::Tizen::ErrorCallback::onerror">
        <webidl>    void onerror (<ref>WebAPIError</ref> error);</webidl>
        <descriptive>
            <brief>
 Method that is invoked when the error occurs.
            </brief>
            <version>
 1.0
            </version>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="error">
            <descriptive>
                <description><p>
 Generic error.
                </p></description>
            </descriptive>
            <Type name="WebAPIError"/>
          </Argument>
        </ArgumentList>
      </Operation>
    </Interface>
  </Module>
  <Module name="WebSetting" id="::WebSetting">
    <webidl>module WebSetting {

  [NoInterfaceObject] interface WebSettingObject {
    readonly attribute <ref>WebSettingManager</ref> websetting;
  };
    <ref>Tizen</ref> implements <ref>WebSettingObject</ref>;

  [NoInterfaceObject] interface WebSettingManager {

   void setUserAgentString(DOMString userAgent,
              optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);

   void removeAllCookies(optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);

   };
};</webidl>
    <descriptive>
        <brief>
 This Web setting API defines a set of APIs that manages the setting states of the Web view in your Web application.
        </brief>
       <description>
        <p>
A Tizen Web application includes a web view and the properties below of the web view can be managed via the Web setting API:
        </p>
        <ul>
          <li>
 Delete all the cookies saved for the web view in the Web application.           </li>
          <li>
 Set a custom user agent string of the web view in the Web application.          </li>
        </ul>
        <p>
Note that all the settings using the Web setting API is bound to your application; thus, no other applications are affected via the Web setting API calls within your application.
        </p>
       </description>
        <version>
 2.2
        </version>
    </descriptive>
    <Interface name="WebSettingObject" id="::WebSetting::WebSettingObject">
      <webidl>  [NoInterfaceObject] interface WebSettingObject {
    readonly attribute <ref>WebSettingManager</ref> websetting;
  };</webidl>
      <descriptive>
          <brief>
 This interface defines what is instantiated for the Web setting API by the <em>Tizen</em> object from the Tizen Platform.
          </brief>
         <description>
          <p>
<em>tizen.websetting</em> object is available to manage the settings of the Web view in your Web application.
          </p>
         </description>
          <version>
 2.2
          </version>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Attribute readonly="readonly" name="websetting" id="::WebSetting::WebSettingObject::websetting">
        <webidl>    readonly attribute <ref>WebSettingManager</ref> websetting;</webidl>
        <Type name="WebSettingManager"/>
      </Attribute>
    </Interface>
    <Implements name1="Tizen" name2="WebSettingObject">
      <webidl>    <ref>Tizen</ref> implements <ref>WebSettingObject</ref>;</webidl>
    </Implements>
    <Interface name="WebSettingManager" id="::WebSetting::WebSettingManager">
      <webidl>  [NoInterfaceObject] interface WebSettingManager {

   void setUserAgentString(DOMString userAgent,
              optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);

   void removeAllCookies(optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);

   };</webidl>
      <descriptive>
          <brief>
 This is the top-level interface for the WebSetting API that managed the settings of the Web view in your Web application.
          </brief>
      </descriptive>
      <ExtendedAttributeList>
        <ExtendedAttribute name="NoInterfaceObject">
          <webidl>NoInterfaceObject</webidl>
        </ExtendedAttribute>
      </ExtendedAttributeList>
      <Operation name="setUserAgentString" id="::WebSetting::WebSettingManager::setUserAgentString">
        <webidl>   void setUserAgentString(DOMString userAgent,
              optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Sets the custom user agent string for your Web application.
            </brief>
           <description>
            <p>
This method allows the user to set the user agent string of the Web view in the Web application.  By default, the Web view in your application
has the same user agent string as the Tizen browser on the device.
            </p>
            <p>
The <em>ErrorCallback</em> is launched with these error types:
            </p>
            <ul>
              <li>
UnknownError - If any error occurs while setting the user agent string.              </li>
              <li>
InvalidValuesError - If any of the input parameters contain an invalid value.              </li>
            </ul>
           </description>
            <version>
 2.2
            </version>
            <Code> function successCallback() {
     console.log(&quot;The requested user agent string has just been set successfully.&quot;);
 }

 tizen.websetting.setUserAgentString(&quot;the new user agent string to set&quot;, successCallback);

</Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument name="userAgent">
            <descriptive>
                <description><p>
 User agent to set for the Web view in your Web application.
                </p></description>
            </descriptive>
            <Type type="DOMString"/>
          </Argument>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 To be invoked if the requested setting operation succeeds.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 To be invoked if the requested setting operation fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
      <Operation name="removeAllCookies" id="::WebSetting::WebSettingManager::removeAllCookies">
        <webidl>   void removeAllCookies(optional <ref>SuccessCallback</ref>? successCallback,
              optional <ref>ErrorCallback</ref>? errorCallback) raises (<ref>WebAPIException</ref>);</webidl>
        <descriptive>
            <brief>
 Removes all the cookies saved for the Web view in your Web application.
            </brief>
           <description>
            <p>
The Web view in your Web application can store cookies like a browser. This method allows the user to remove all the cookies saved for the Web application.
            </p>
            <p>
The <em>ErrorCallback</em> is launched with these error types:
            </p>
            <ul>
              <li>
UnknownError - If any error occurs while deleting the cookies.              </li>
            </ul>
           </description>
            <version>
 2.2
            </version>
            <privilegelevel>
 public
            </privilegelevel>
            <privilege>
 http://tizen.org/privilege/websetting
            </privilege>
            <Code> function successCallback() {
     console.log(&quot;The cookies saved for your application have just been removed.&quot;);
 }

 tizen.websetting.removeAllCookies(successCallback);

</Code>
        </descriptive>
        <Type type="void"/>
        <ArgumentList>
          <Argument optional="optional" name="successCallback">
            <descriptive>
                <description><p>
 To be invoked if the requested delete operation succeeds.
                </p></description>
            </descriptive>
            <Type name="SuccessCallback" nullable="nullable"/>
          </Argument>
          <Argument optional="optional" name="errorCallback">
            <descriptive>
                <description><p>
 To be invoked if the requested delete operation fails.
                </p></description>
            </descriptive>
            <Type name="ErrorCallback" nullable="nullable"/>
          </Argument>
        </ArgumentList>
        <Raises>
          <RaiseException name="WebAPIException">
            <descriptive>
                <description><p>
 with error type TypeMismatchError, if any input parameter is not compatible with the expected type for that parameter.
                </p></description>
                <description><p>
 with error type SecurityError, if the application does not have the privilege to call this method.
                </p></description>
            </descriptive>
          </RaiseException>
        </Raises>
      </Operation>
    </Interface>
  </Module>
</Definitions>
